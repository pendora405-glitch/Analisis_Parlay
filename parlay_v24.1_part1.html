<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Parlay Titan ‚Äî v24.1 Clean</title>

<style>
:root{
  --bg: #f2f6fb;
  --card: #ffffff;
  --accent: #196bff;
  --muted: #6b778d;
  --line: #dbe7fb;
  --success: #28a745;
  --danger: #e63946;
}
*{box-sizing:border-box}
body{margin:0;font-family:Inter, "Segoe UI", Roboto, sans-serif;background:var(--bg);color:#111}
.container{max-width:1200px;margin:18px auto;padding:14px}
.card{background:var(--card);padding:16px;border-radius:12px;margin-bottom:14px;box-shadow:0 2px 10px rgba(13,38,76,0.04)}
.header-row{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
.title{font-size:20px;font-weight:700}
.note{color:var(--muted);font-size:13px}
.grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:10px}
.input,select,textarea{padding:9px;border-radius:8px;border:1px solid var(--line);font-size:14px;width:100%;background:#fff}
.btn{background:var(--accent);color:white;padding:10px 14px;border-radius:8px;border:0;cursor:pointer;font-weight:600}
.btn.small{padding:7px 10px;font-size:13px;background:#2b7bff}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.legacy-note{font-size:12px;color:#445566}
.canvas-wrap{display:flex;gap:12px;flex-wrap:wrap}
.canvas{background:#fff;border-radius:10px;border:1px solid var(--line);padding:8px}
.history-item{background:#f6f9ff;padding:8px;border-radius:8px;margin-bottom:6px}
.flex-col{display:flex;flex-direction:column}
.small-note{font-size:12px;color:var(--muted)}
.legend{font-size:12px;color:var(--muted);margin-top:6px}
.footer-note{font-size:13px;color:var(--muted);text-align:center;margin-top:6px}
</style>

</head>
<body>
<div class="container">

  <!-- HEADER -->
  <div class="card header-row">
    <div>
      <div class="title">‚öΩ Parlay Titan ‚Äî v24.1 Clean</div>
      <div class="note">Engine: v24.1 (XG+v4, PCS v4, Momentum, MEL++) ‚Äî clean build (no v23 cruft)</div>
    </div>
    <div class="row">
      <button id="btnAnalyze" class="btn">üîç ANALYZE MATCH</button>
      <button id="btnReset" class="btn small">Reset</button>
      <button id="btnExport" class="btn small">Export History</button>
    </div>
  </div>

  <!-- INPUT: HOME -->
  <div class="card">
    <div class="title">HOME TEAM</div>
    <div class="grid" style="margin-top:10px">
      <input id="h_team" class="input" placeholder="Home team name">
      <input id="h_goals" class="input" placeholder="GPG (goals per game) e.g. 1.2">
      <input id="h_gc" class="input" placeholder="GC (conceded per game)">
      <input id="h_shots" class="input" placeholder="Shots per match">
      <input id="h_sot" class="input" placeholder="Shots on target">
      <input id="h_final3" class="input" placeholder="Final third entries">
      <input id="h_prog" class="input" placeholder="Progressive passes">
      <input id="h_poss" class="input" placeholder="Possession %">
      <input id="h_build" class="input" placeholder="Build-up rating (1-10)">
      <input id="h_cross" class="input" placeholder="Crosses per match">
      <input id="h_inter" class="input" placeholder="Interceptions per match">
      <input id="h_dzc" class="input" placeholder="Danger zone conceded">
      <input id="h_rest" class="input" placeholder="Rest days">
      <input id="h_rotation" class="input" placeholder="Rotation level (0-10)">
      <select id="h_press" class="input">
        <option value="low">Low press</option>
        <option value="medium" selected>Medium press</option>
        <option value="high">High press</option>
      </select>
      <input id="h_abs" class="input" placeholder="Absensi format GK:x,DF:x,MD:x,FW:x">
      <input id="h_tier" class="input" placeholder="Tier Œ© (0-1 scale, e.g. 0.65)">
      <input id="h_elo" class="input" placeholder="ELO (optional)">
    </div>
  </div>

  <!-- INPUT: AWAY -->
  <div class="card">
    <div class="title">AWAY TEAM</div>
    <div class="grid" style="margin-top:10px">
      <input id="a_team" class="input" placeholder="Away team name">
      <input id="a_goals" class="input" placeholder="GPG (goals per game) e.g. 1.0">
      <input id="a_gc" class="input" placeholder="GC (conceded per game)">
      <input id="a_shots" class="input" placeholder="Shots per match">
      <input id="a_sot" class="input" placeholder="Shots on target">
      <input id="a_final3" class="input" placeholder="Final third entries">
      <input id="a_prog" class="input" placeholder="Progressive passes">
      <input id="a_poss" class="input" placeholder="Possession %">
      <input id="a_build" class="input" placeholder="Build-up rating (1-10)">
      <input id="a_cross" class="input" placeholder="Crosses per match">
      <input id="a_inter" class="input" placeholder="Interceptions per match">
      <input id="a_dzc" class="input" placeholder="Danger zone conceded">
      <input id="a_rest" class="input" placeholder="Rest days">
      <input id="a_rotation" class="input" placeholder="Rotation level (0-10)">
      <select id="a_press" class="input">
        <option value="low">Low press</option>
        <option value="medium" selected>Medium press</option>
        <option value="high">High press</option>
      </select>
      <input id="a_abs" class="input" placeholder="Absensi format GK:x,DF:x,MD:x,FW:x">
      <input id="a_tier" class="input" placeholder="Tier Œ© (0-1 scale, e.g. 0.35)">
      <input id="a_elo" class="input" placeholder="ELO (optional)">
    </div>
  </div>

  <!-- CONTROLS: MEL & MARKET (basic placeholders; actual hooks in Part 2/3) -->
  <div class="card">
    <div class="title">v24 Controls (MEL & Market)</div>
    <div class="row" style="margin-top:8px">
      <div class="small-note">MEL calibration: <input id="melSliderPlaceholder" type="range" min="0.7" max="1.3" step="0.01" value="1" style="vertical-align:middle"></div>
      <div class="small-note" style="margin-left:10px">Market HDP open <input id="market_hdp_open" class="input" style="width:90px" placeholder="1.95"></div>
      <div class="small-note">now <input id="market_hdp_now" class="input" style="width:90px" placeholder="1.85"></div>
      <div class="small-note" style="margin-left:10px">OU open <input id="market_ou_open" class="input" style="width:90px" placeholder="2.05"></div>
      <div class="small-note">now <input id="market_ou_now" class="input" style="width:90px" placeholder="2.05"></div>
    </div>
    <div class="legend">Note: MEL & market controls are placeholders in Part 1 ‚Äî actual persistent MEL, seeded RNG and engine live in Part 2/3.</div>
  </div>

  <!-- RESULT + VISUAL PLACEHOLDERS -->
  <div class="card">
    <div class="title">Result</div>
    <div id="resultBox" class="small-note" style="margin-top:8px">No analysis yet.</div>
    <div style="margin-top:12px;" class="canvas-wrap">
      <div class="canvas" style="flex:1">
        <div class="section-title">Shot Map</div>
        <canvas id="shotMap" width="520" height="320"></canvas>
        <div class="legend">Home (blue) ‚Äî Away (red)</div>
      </div>
      <div class="canvas" style="width:360px">
        <div class="section-title">Defensive Pressure Field</div>
        <canvas id="dpfMap" width="340" height="220"></canvas>
        <div class="legend">Pressure visualization</div>
      </div>
    </div>
  </div>

  <!-- HISTORY -->
  <div class="card">
    <div class="title">History</div>
    <div id="historyList" style="margin-top:10px"></div>
    <div class="footer-note">History stored in-memory; v24.1 will support persistent MEL in Part 2.</div>
  </div>
<!-- ===========================
      PART 2 ‚Äî ENGINE v24.1 CLEAN
=========================== -->
<script>
/* ===========================
      BASIC SAFE HELPERS
=========================== */
function safeNum(v, d=0){
  v = parseFloat(v);
  return Number.isFinite(v) ? v : d;
}
function clamp(v,a,b){ return v<a?a : v>b?b : v; }
function roundTo(v,n){ return Number(v.toFixed(n)); }
function isValidNumber(x){ return typeof x==="number" && Number.isFinite(x); }
function lerp(a,b,t){ return a + (b-a)*t; }

/* ===========================
      RNG v24 (DETERMINISTIC)
=========================== */
if(!window.V24) window.V24 = {};
window.V24._seed = Date.now() & 0xffffffff;

function v24_seed(s){
  window.V24._seed = (s>>>0);
}
function v24_rand(){
  window.V24._seed = (1664525 * window.V24._seed + 1013904223) & 0xffffffff;
  return (window.V24._seed >>> 0) / 4294967296;
}
function v24_randRange(a,b){
  return a + v24_rand()*(b-a);
}

/* ===========================
      MEL++ v24 PERSISTENT
=========================== */
window.MEL_STORE_KEY = "titan_mel_v24.1";
function mel_load(){
  try{
    const raw = localStorage.getItem(window.MEL_STORE_KEY);
    if(!raw) return {calibration:1, auto:false, updated:0};
    return JSON.parse(raw);
  }catch(e){
    return {calibration:1, auto:false, updated:0};
  }
}
function mel_save(x){
  try{
    x.updated = Date.now();
    localStorage.setItem(window.MEL_STORE_KEY, JSON.stringify(x));
  }catch(e){}
}
window.MEL = mel_load();

/* ===========================
      PRESS VALUE
=========================== */
function pressToNum(v){
  if(!v) return 0.5;
  v = v.toString().toLowerCase();
  if(v==="low") return 0.30;
  if(v==="medium") return 0.50;
  if(v==="high") return 0.75;
  return 0.50;
}

/* ===========================
   PARSE ABSENSI GK/DF/MD/FW
=========================== */
function parseAbsensi(str){
  if(!str) return {GK:0,DF:0,MD:0,FW:0};
  let o={GK:0,DF:0,MD:0,FW:0};
  str.split(",").forEach(x=>{
    const p=x.split(":");
    if(p.length===2){
      const k=p[0].trim().toUpperCase();
      const v=safeNum(p[1],0);
      if(o.hasOwnProperty(k)) o[k]=v;
    }
  });
  return o;
}
function computeICM(abs){
  const GK = clamp(1 - abs.GK*0.20, 0.65, 1.00);
  const DF = clamp(1 - abs.DF*0.10, 0.65, 1.00);
  const MD = clamp(1 - abs.MD*0.07, 0.75, 1.00);
  const FW = clamp(1 - abs.FW*0.10, 0.75, 1.00);
  return {
    atkPenalty: clamp(FW * MD, 0.55, 1.00),
    defPenalty: clamp(GK * DF, 0.55, 1.00)
  };
}

/* ===========================
      DPF v24
=========================== */
function computeDPF(team, opp, hist){
  const press = pressToNum(team.press);
  const inter = safeNum(team.inter,5);
  const dzc   = safeNum(team.dzc,5);
  const raw   = clamp(press*0.65 + inter/40 - dzc/40, 0,1);
  const grid = [];
  for(let r=0;r<8;r++){
    let row=[];
    for(let c=0;c<12;c++){
      const base = raw * (0.6 + (r/7)*0.4); 
      row.push(roundTo(base,3));
    }
    grid.push(row);
  }
  return {pressure: raw, grid:grid};
}

/* ===========================
   AUTOEXTRACT OFFENSE v24.1
=========================== */
function autoExtractOff_v24(t){
  const shots = safeNum(t.shots,10);
  const sot   = safeNum(t.sot,3);
  const f3    = safeNum(t.final3,4);
  const prog  = safeNum(t.prog,7);
  const build = safeNum(t.build,5);
  const cross = clamp(safeNum(t.cross,0)/100,0,1);

  let dist = 15 - clamp(f3/12,0,4) - clamp(prog/15,0,3) - clamp((build-5)*0.25,-2,2)
               + clamp((0.40 - sot/Math.max(1,shots))*10, -3,4);
  dist = clamp(dist,7,26);

  let angle = 18 - clamp(f3/12*8,0,12) + clamp((0.38 - sot/Math.max(1,shots))*25,-4,8)
                + clamp((0.25 - cross)*10,-3,6);
  angle = clamp(angle,6,45);

  return {
    dist: roundTo(dist,2),
    angle: roundTo(angle,2)
  };
}

/* ===========================
   AUTOEXTRACT DEFENSE v24.1
=========================== */
function autoExtractDef_v24(team, opp){
  const s = safeNum(opp.shots,10);
  const sot = safeNum(opp.sot,3);
  const f3 = safeNum(opp.final3,4);
  const inter = safeNum(team.inter,5);

  let dist = 16 + clamp((s-10)*0.3,-3,4) - clamp(f3/10*4,0,5)
             + clamp((0.42 - sot/Math.max(1,s))*14,-3,6);
  dist = clamp(dist,8,28);

  let angle = 22 - clamp(f3/10*6,0,10)
              + clamp((0.40 - sot/Math.max(1,s))*28,-4,12)
              + clamp((1 - inter/8)*5,-4,6);
  angle = clamp(angle,8,48);

  return { dist:roundTo(dist,2), angle:roundTo(angle,1) };
}

/* ===========================
       XG+ v4
=========================== */
function calcXGplus_v4(t){
  try{
    const shots = Math.max(1, safeNum(t.shots,10));
    const sot   = safeNum(t.sot,3);
    const f3    = safeNum(t.final3,4);
    const prog  = safeNum(t.prog,7);
    const build = safeNum(t.build,5);
    const cross = clamp(safeNum(t.cross,0)/100,0,1);

    const dist  = t.dist_off;
    const angle = t.angle_off;

    let base = 0.05 + (sot/shots)*0.22 + (f3/60)*0.11 + (prog/120)*0.04;
    base = clamp(base,0.015,0.48);

    let loc = 1 + ((20 - dist)/30)*0.40 + ((25 - angle)/50)*0.28;
    loc = clamp(loc * (1 + cross*0.14), 0.55, 1.95);

    let per = clamp(base * loc * (1 + (build-5)/55), 0.006, 0.70);
    per *= safeNum(window.MEL.calibration,1);

    const total = clamp(per * shots, 0.01, 11);

    return { total:roundTo(total,4), perShot:roundTo(per,4) };
  }catch(e){
    return { total:0.9, perShot:0.08 };
  }
}

/* ===========================
    PCS MONTE CARLO v4
=========================== */
function pcsSim_v4(t, opp, iters=900){
  const per  = safeNum(t.xg_per,0.08);
  const shots= Math.max(1, safeNum(t.shots,10));
  const f3   = safeNum(t.final3,4);

  const dist = t.dist_off;
  const angle= t.angle_off;

  let sum=0, sq=0;

  for(let i=0;i<iters;i++){
    let chain = 0;
    let seg = 1 + Math.floor(v24_randRange(0, Math.max(2, (t.prog||7)/6 + (t.build||5)/3)));

    for(let k=0;k<seg;k++){
      if(v24_rand() < pressToNum(opp.press)*0.12){
        chain *= 0.55;
        break;
      }
      chain += 0.006 + v24_rand()*0.05;
    }

    if(v24_rand() < (0.10 + f3/60 + (t.prog||7)/240)){
      const loc = clamp(
        1 + ((16-dist)/26)*0.25 + ((22-angle)/50)*0.15,
        0.75,1.55
      );
      const q = per * loc * clamp(1 + ((t.sot||3)/shots -0.33)*0.8,0.75,1.35);
      chain += q * (0.045 + v24_rand()*0.10) * clamp(shots/12,0.4,3);
    }

    sum += chain;
    sq  += chain*chain;
  }

  const mean = sum/iters;
  const xTF  = clamp(mean*(1 + f3/34), 0.01, 7.5);

  return {
    xTF: roundTo(xTF,4),
    sd:  roundTo(Math.sqrt(Math.max(0,sq/iters - mean*mean)),4),
    mean:roundTo(mean,4)
  };
}

/* ===========================
     MOMENTUM v24
=========================== */
function momentum_v24(h,a){
  const sd = clamp(
    (safeNum(h.shots,10)-safeNum(a.shots,10))/
    Math.max(1,safeNum(h.shots,10)+safeNum(a.shots,10)),
  -1,1);

  const pd = clamp((safeNum(h.poss,50)-safeNum(a.poss,50))/100, -1,1);

  let m = 1 + sd*0.22 + pd*0.18;
  m = clamp(m,0.72,1.32);

  return m;
}

/* ===========================
     VARIANCE SENSITIVITY
=========================== */
function computeVSM(h,a){
  const d = Math.abs(safeNum(h.goals,1.2) - safeNum(a.goals,1));
  return clamp(d/3,0,1);
}

/* ===========================
     FINALIZE v24.1
=========================== */
function finalize_v241(base, h, a, pcs){
  const absH = computeICM(h.abs);
  const absA = computeICM(a.abs);

  let ŒªH = base.H * absH.atkPenalty;
  let ŒªA = base.A * absA.atkPenalty;

  const dpfH = computeDPF(h,a);
  const dpfA = computeDPF(a,h);

  ŒªA *= clamp(1 - dpfH.pressure*0.15, 0.6,1.05);
  ŒªH *= clamp(1 - dpfA.pressure*0.15, 0.6,1.05);

  ŒªH = lerp(ŒªH, pcs.H, 0.28);
  ŒªA = lerp(ŒªA, pcs.A, 0.28);

  const mom = momentum_v24(h,a);
  ŒªH *= mom;
  ŒªA *= (2-mom);

  const tierH = clamp(1 + (safeNum(h.tier,0)-0.5)*0.18, 0.8,1.26);
  const tierA = clamp(1 + (safeNum(a.tier,0)-0.5)*0.18, 0.8,1.26);
  ŒªH *= tierH;
  ŒªA *= tierA;

  ŒªH *= clamp(1 + (pressToNum(h.press)-0.5)*0.12,0.85,1.18);
  ŒªA *= clamp(1 + (pressToNum(a.press)-0.5)*0.12,0.85,1.18);

  const vsm = computeVSM(h,a);
  ŒªH *= clamp(1 + (vsm*0.05)*(v24_rand()-0.5), 0.9,1.08);
  ŒªA *= clamp(1 + (vsm*0.05)*(v24_rand()-0.5), 0.9,1.08);

  return {
    H: roundTo(clamp(ŒªH,0.02,12),4),
    A: roundTo(clamp(ŒªA,0.02,12),4),
    dpfH, dpfA, mom
  };
}

/* ===========================
     SCORE DISTRIBUTION
=========================== */
function poisson(k, lambda){
  return Math.exp(-lambda) * Math.pow(lambda,k) / factorial(k);
}
function factorial(k){
  if(k<0) return 1;
  let r=1; for(let i=1;i<=k;i++) r*=i;
  return r;
}
function scoreDist(ŒªH, ŒªA, max=8){
  let dist=[];
  for(let h=0;h<=max;h++){
    for(let a=0;a<=max;a++){
      const p = poisson(h,ŒªH)*poisson(a,ŒªA);
      dist.push({h,a,p});
    }
  }
  return dist;
}
function prob3W(ŒªH,ŒªA){
  let pH=0,pA=0,pX=0;
  for(let h=0;h<=8;h++){
    for(let a=0;a<=8;a++){
      const p=poisson(h,ŒªH)*poisson(a,ŒªA);
      if(h>a) pH+=p;
      else if(a>h) pA+=p;
      else pX+=p;
    }
  }
  return {home:pH,draw:pX,away:pA};
}

/* ===========================
     READ TEAM INPUT
=========================== */
function readTeam_v24(prefix){
  return {
    name: document.getElementById(prefix+"_team").value || prefix.toUpperCase(),
    goals: safeNum(document.getElementById(prefix+"_goals").value,1),
    gc: safeNum(document.getElementById(prefix+"_gc").value,1),
    shots: safeNum(document.getElementById(prefix+"_shots").value,10),
    sot: safeNum(document.getElementById(prefix+"_sot").value,3),
    final3: safeNum(document.getElementById(prefix+"_final3").value,4),
    prog: safeNum(document.getElementById(prefix+"_prog").value,7),
    poss: safeNum(document.getElementById(prefix+"_poss").value,50),
    build: safeNum(document.getElementById(prefix+"_build").value,5),
    cross: safeNum(document.getElementById(prefix+"_cross").value,0),
    inter: safeNum(document.getElementById(prefix+"_inter").value,5),
    dzc: safeNum(document.getElementById(prefix+"_dzc").value,5),
    rest: safeNum(document.getElementById(prefix+"_rest").value,3),
    rotation: safeNum(document.getElementById(prefix+"_rotation").value,0),
    press: document.getElementById(prefix+"_press").value,
    abs: parseAbsensi(document.getElementById(prefix+"_abs").value),
    tier: safeNum(document.getElementById(prefix+"_tier").value,0.5),
    elo: safeNum(document.getElementById(prefix+"_elo").value,1500)
  };
}

/* ===========================
     ANALYZE MATCH v24.1
=========================== */
window.analyzeMatch = function(){
  const h = readTeam_v24("h");
  const a = readTeam_v24("a");

  // autoextract
  const offH = autoExtractOff_v24(h);
  const offA = autoExtractOff_v24(a);
  h.dist_off = offH.dist; h.angle_off = offH.angle;
  a.dist_off = offA.dist; a.angle_off = offA.angle;

  const defH = autoExtractDef_v24(h,a);
  const defA = autoExtractDef_v24(a,h);
  h.dist_def = defH.dist; h.angle_def = defH.angle;
  a.dist_def = defA.dist; a.angle_def = defA.angle;

  // XG+
  const xgH = calcXGplus_v4(h);
  const xgA = calcXGplus_v4(a);
  h.xg_total = xgH.total; h.xg_per = xgH.perShot;
  a.xg_total = xgA.total; a.xg_per = xgA.perShot;

  // PCS
  const pcsH = pcsSim_v4(h,a,800);
  const pcsA = pcsSim_v4(a,h,800);

  // final
  const base = {H:h.goals, A:a.goals};
  const pcsRes = {H:pcsH.xTF, A:pcsA.xTF};
  const final = finalize_v241(base, h, a, pcsRes);

  // distribution
  const dist = scoreDist(final.H, final.A, 7);
  const prob = prob3W(final.H, final.A);
  const total = final.H + final.A;

  const pickOU = total>2.55 ? "Over" : "Under";
  const pick1x2 = prob.home>0.48 ? "1" : prob.away>0.48 ? "2" : "X";

  // DISPLAY
  document.getElementById("resultBox").innerHTML =
    `<b>${h.name}</b> vs <b>${a.name}</b><br>
     ŒªH=${final.H} ‚Äî ŒªA=${final.A}<br>
     Picks: 1X2 <b>${pick1x2}</b>, OU <b>${pickOU}</b><br>
     Confidence: ${(Math.abs(prob.home-prob.away)*100).toFixed(1)}%`;

  // SHOTMAP & DPF (render in Part 3)
  window._renderShotMap && window._renderShotMap(h,a);
  window._renderDPF && window._renderDPF(final.dpfH, final.dpfA);

  return final;
};

/* ===========================
      HISTORY & CONTROLS
=========================== */
document.getElementById("btnAnalyze").onclick = ()=> analyzeMatch();
document.getElementById("btnReset").onclick = ()=> location.reload();
document.getElementById("btnExport").onclick = ()=>{
  const txt = "Export belum di-implement v24.1 (bisa ditambah Part 3).";
  alert(txt);
};

</script>

<!-- ===========================
      PART 3 ‚Äî WORKER, VISUAL, HISTORY, CLOSE
=========================== -->
<script>
/* ===========================
    SAFE WORKER (if supported)
   - enableWorkerFuture()
   - titanWorkerPost()
   - disableWorkerFuture()
=========================== */
(function(){
  if(window.TITAN_WORKER && typeof window.TITAN_WORKER.terminate === 'function'){
    try{ window.TITAN_WORKER.terminate(); }catch(e){}
    window.TITAN_WORKER = null;
  }

  window.enableWorkerFuture = function(){
    try{
      if(window.TITAN_WORKER) return window.TITAN_WORKER;
      const code = `
        self.onmessage = function(e){
          try{
            const d = e.data || {};
            if(d.cmd==='echo'){ self.postMessage({ok:true, echo:d.msg||null, t:Date.now()}); return; }
            if(d.cmd==='mc_stub'){ let iter = d.iter||200; let s=0; for(let i=0;i<iter;i++){ s += Math.random(); } self.postMessage({ok:true, mc:{iter:iter, avg:s/iter}}); return; }
            self.postMessage({ok:true, msg:'worker alive', recv:d});
          }catch(err){ self.postMessage({ok:false, error:String(err)}); }
        };
      `;
      const blob = new Blob([code], {type:'application/javascript'});
      const url = URL.createObjectURL(blob);
      const w = new Worker(url);
      w.onmessage = function(evt){ console.log('TITAN_WORKER>', evt.data); };
      w.onerror = function(evt){ console.warn('TITAN_WORKER ERR', evt); };
      window.TITAN_WORKER = w;
      return w;
    }catch(e){
      console.warn('enableWorkerFuture failed', e);
      return null;
    }
  };

  window.titanWorkerPost = function(msg, cb, timeout=4000){
    try{
      if(!window.TITAN_WORKER){ if(cb) cb({ok:false, error:'no-worker'}); return; }
      function handler(evt){ try{ if(cb) cb(evt.data); }catch(e){} finally{ window.TITAN_WORKER.removeEventListener('message', handler); } }
      window.TITAN_WORKER.addEventListener('message', handler);
      window.TITAN_WORKER.postMessage(msg);
      if(timeout>0) setTimeout(()=>{ try{ window.TITAN_WORKER.removeEventListener('message', handler); if(cb) cb({ok:false, error:'timeout'}); }catch(e){} }, timeout);
    }catch(e){ if(cb) cb({ok:false, error:String(e)}); }
  };

  window.disableWorkerFuture = function(){
    try{ if(window.TITAN_WORKER) window.TITAN_WORKER.terminate(); window.TITAN_WORKER=null; return true; }catch(e){ return false; }
  };

  // UI: small worker controls (if container exists)
  try{
    const cont = document.querySelector('.container');
    if(cont && !document.getElementById('v241_worker_ui')){
      const card = document.createElement('div'); card.className='card'; card.id='v241_worker_ui';
      card.innerHTML = '<div class="title">Worker (optional)</div><div class="row" style="margin-top:8px"><button id="wInit" class="btn small">Init Worker</button><button id="wEcho" class="btn small" style="margin-left:8px">Echo</button><button id="wMC" class="btn small" style="margin-left:8px">MC Stub</button><span id="wStatus" class="small-note" style="margin-left:10px"></span></div>';
      cont.insertBefore(card, cont.children[3]||null);
      document.getElementById('wInit').onclick = function(){ const w = enableWorkerFuture(); document.getElementById('wStatus').textContent = w ? 'ready' : 'failed'; };
      document.getElementById('wEcho').onclick = function(){ titanWorkerPost({cmd:'echo', msg:'hello'}, function(r){ document.getElementById('wStatus').textContent = JSON.stringify(r); }); };
      document.getElementById('wMC').onclick = function(){ titanWorkerPost({cmd:'mc_stub', iter:500}, function(r){ document.getElementById('wStatus').textContent = r && r.mc ? 'avg='+r.mc.avg.toFixed(3) : JSON.stringify(r); }, 8000); };
    }
  }catch(e){}
})();

/* ===========================
    SHOT MAP RENDERER
    - uses canvas #shotMap
    - exposes window._renderShotMap(h,a)
=========================== */
window._renderShotMap = function(h,a){
  try{
    const c = document.getElementById('shotMap'); if(!c) return;
    const ctx = c.getContext('2d'); ctx.clearRect(0,0,c.width,c.height);
    // background
    ctx.fillStyle = '#fbfdff'; ctx.fillRect(0,0,c.width,c.height);
    ctx.strokeStyle = '#e6eefc'; ctx.strokeRect(6,6,c.width-12,c.height-12);

    // pick counts
    const nH = Math.min(18, Math.max(4, Math.round((safeNum(h.shots,10))/1.1)));
    const nA = Math.min(18, Math.max(4, Math.round((safeNum(a.shots,10))/1.1)));

    function place(dist, angle, side){
      const w=c.width, hgt=c.height;
      const minD=7, maxD=28;
      const r = clamp((dist-minD)/(maxD-minD),0,1);
      const radius = (0.18 + r*0.78) * (Math.min(w,hgt)/2 - 28);
      const theta = (angle/45) * (Math.PI/2);
      const xOff = Math.sin(theta) * radius;
      const yOff = Math.cos(theta) * radius;
      const centerX = side==='home' ? w*0.35 : w*0.65;
      const centerY = hgt*0.48;
      const jitterX = (Math.random()-0.5)*10;
      const jitterY = (Math.random()-0.5)*8;
      return { x: clamp(centerX + (side==='home'?xOff:-xOff) + jitterX, 12, w-12), y: clamp(centerY - yOff + jitterY, 12, hgt-12) };
    }

    const points=[];
    const dH = safeNum(h.dist_off, h.dist_def || 16);
    const aH = safeNum(h.angle_off, 20);
    const dA = safeNum(a.dist_off, a.dist_def || 16);
    const aA = safeNum(a.angle_off, 20);

    for(let i=0;i<nH;i++) points.push({side:'home', dist: clamp(dH + (Math.random()-0.5)*3,8,28), ang: clamp(aH + (Math.random()-0.5)*8,6,48), w: 0.8 + Math.random()*1.6});
    for(let i=0;i<nA;i++) points.push({side:'away', dist: clamp(dA + (Math.random()-0.5)*3,8,28), ang: clamp(aA + (Math.random()-0.5)*8,6,48), w: 0.8 + Math.random()*1.6});

    for(const p of points){
      const pos = place(p.dist, p.ang, p.side);
      const rad = 18 * p.w;
      const g = ctx.createRadialGradient(pos.x,pos.y,1,pos.x,pos.y,rad);
      if(p.side==='home'){ g.addColorStop(0,'rgba(34,120,220,0.92)'); g.addColorStop(1,'rgba(34,120,220,0.06)'); }
      else { g.addColorStop(0,'rgba(220,60,60,0.92)'); g.addColorStop(1,'rgba(220,60,60,0.06)'); }
      ctx.fillStyle = g; ctx.beginPath(); ctx.arc(pos.x,pos.y,rad,0,Math.PI*2); ctx.fill();
    }

    ctx.fillStyle = '#223'; ctx.font = '12px Arial';
    ctx.fillText('Home (blue) ‚Äî Away (red)', 12, c.height-8);
  }catch(e){ console.warn('renderShotMap err', e); }
};

/* ===========================
    DPF RENDERER
    - takes two grids (dpfH.grid,dpfA.grid) and draws combined heatmap
    - exposes window._renderDPF(dpfH,dpfA)
=========================== */
window._renderDPF = function(dpfH, dpfA){
  try{
    const c = document.getElementById('dpfMap'); if(!c) return;
    const ctx = c.getContext('2d'); ctx.clearRect(0,0,c.width,c.height);
    // build combined grid
    const g1 = dpfH && dpfH.grid ? dpfH.grid : [[0.4]];
    const g2 = dpfA && dpfA.grid ? dpfA.grid : [[0.4]];
    const rows = Math.max(g1.length, g2.length);
    const cols = Math.max((g1[0]||[]).length, (g2[0]||[]).length);
    const out = [];
    for(let r=0;r<rows;r++){
      const row=[];
      for(let cidx=0;cidx<cols;cidx++){
        const v1 = (g1[r] && g1[r][cidx]) ? g1[r][cidx] : (g1[Math.floor(g1.length/2)] || [0.4])[cidx] || 0.4;
        const v2 = (g2[r] && g2[r][cidx]) ? g2[r][cidx] : (g2[Math.floor(g2.length/2)] || [0.4])[cidx] || 0.4;
        row.push(clamp((v1 + v2)/2, 0, 1));
      }
      out.push(row);
    }
    // draw heatmap
    const rw = c.width / out[0].length;
    const rh = c.height / out.length;
    // find min/max
    let min=1, max=0;
    out.forEach(r=> r.forEach(v=>{ if(v<min)min=v; if(v>max)max=v; }));
    const range = Math.max(1e-6, max-min);
    function colorFor(v){
      const t = (v-min)/range;
      const r = Math.round(50 + (220-50)*t);
      const g = Math.round(200 - 160*t);
      const b = Math.round(255 - 210*t);
      return `rgb(${r},${g},${b})`;
    }
    for(let r=0;r<out.length;r++){
      for(let cidx=0;cidx<out[r].length;cidx++){
        ctx.fillStyle = colorFor(out[r][cidx]);
        ctx.fillRect(cidx*rw, r*rh, rw, rh);
      }
    }
  }catch(e){ console.warn('renderDPF err', e); }
};

/* ===========================
    HISTORY (in-memory) + EXPORT
=========================== */
window._PARLAY_HISTORY = window._PARLAY_HISTORY || [];

window.addHistoryEntry = function(h,a,final){
  try{
    const entry = {
      time: (new Date()).toISOString(),
      h: Object.assign({}, h),
      a: Object.assign({}, a),
      final: Object.assign({}, final)
    };
    window._PARLAY_HISTORY.push(entry);
    renderHistoryUI();
  }catch(e){ console.warn('addHistoryEntry err', e); }
};

function renderHistoryUI(){
  try{
    const box = document.getElementById('historyList'); if(!box) return;
    box.innerHTML = '';
    const arr = window._PARLAY_HISTORY.slice().reverse();
    if(arr.length===0){ box.innerHTML = '<div class="small-note">No history yet.</div>'; return; }
    arr.forEach(it=>{
      const div = document.createElement('div');
      div.className = 'history-item';
      div.innerHTML = `<b>${it.h.name} vs ${it.a.name}</b><div class="small-note">ŒªH:${safeNum(it.final.H||it.final.lambdaH||0).toFixed(2)} ŒªA:${safeNum(it.final.A||it.final.lambdaA||0).toFixed(2)} ‚Äî ${new Date(it.time).toLocaleString()}</div>`;
      box.appendChild(div);
    });
  }catch(e){ console.warn('renderHistoryUI err', e); }
}

window.exportHistoryJSON = function(){
  try{
    const data = JSON.stringify(window._PARLAY_HISTORY, null, 2);
    const blob = new Blob([data], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'parlay_history_v24.1.json';
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=> URL.revokeObjectURL(url), 4000);
  }catch(e){ console.warn('exportHistory err', e); alert('Export failed'); }
}

// hook export button
try{ document.getElementById('btnExport').onclick = exportHistoryJSON; }catch(e){}

/* ===========================
    CONNECT analyzeMatch -> history + renderers
    (wrap existing analyzeMatch if present)
=========================== */
(function connectAnalyzeHook(){
  if(typeof window.analyzeMatch !== 'function') return;
  const orig = window.analyzeMatch;
  window.analyzeMatch = function(){
    try{
      const res = orig();
      // res might be final object or {H,A,...}
      // normalize final
      let final = res;
      if(res && res.lambdaH!==undefined) final = { H: res.lambdaH, A: res.lambdaA, meta: res.meta || {} };
      // add history
      try{
        const h = (typeof readTeam_v24 === 'function') ? readTeam_v24('h') : (res && res.h) || {name:'H'};
        const a = (typeof readTeam_v24 === 'function') ? readTeam_v24('a') : (res && res.a) || {name:'A'};
        addHistoryEntry(h,a, final);
      }catch(e){}
      return res;
    }catch(e){
      console.warn('wrapped analyzeMatch err', e);
      return null;
    }
  };
})();

/* ===========================
    INITIAL UI RENDER / SAFE FALLBACKS
=========================== */
try{
  renderHistoryUI();
  // seed MEL slider placeholder if present
  const melSlider = document.getElementById('melSliderPlaceholder');
  if(melSlider){
    melSlider.value = safeNum(window.MEL.calibration,1);
    melSlider.oninput = function(){ if(!window.MEL) window.MEL={calibration:1,auto:false}; window.MEL.calibration = parseFloat(this.value); mel_save(window.MEL); };
  }
}catch(e){}

</script>

</body>
</html>
