<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Prediksi Global — v18.8 Full Engine (International Mode)</title>
  <style>
    :root{--bg:#071026;--card:#081428;--muted:#9aa3b2;--accent:#7dd3c8;color-scheme:dark}
    body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:#e6eef8;margin:12px}
    h1{font-size:18px;margin:6px 0}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:12px;border-radius:10px;margin-bottom:10px}
    .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    label{font-size:13px;color:var(--muted)}
    input[type=number], input[type=text], select{width:120px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
    input[type=checkbox]{transform:scale(1.05);margin-left:6px}
    button{background:var(--accent);border:0;padding:8px 12px;border-radius:8px;color:#04201a;cursor:pointer}
    pre{white-space:pre-wrap;background:#001122;padding:10px;border-radius:8px;color:#d6f8ee; max-height:420px; overflow:auto;}
    .muted{color:var(--muted);font-size:13px}
    .grid{display:grid;grid-template-columns:1fr 520px;gap:12px;align-items:start}
    canvas{background:transparent;border-radius:8px}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    .small{font-size:12px;color:var(--muted)}
    .abs-input{width:80px}
    .legend-rows{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    .legend-item{min-width:220px}
    .note{font-size:12px;color:#9aa3b2;margin-top:6px}
  </style>
</head>
<body>
  <h1>Prediksi Global — v18.8 Full Engine (International Mode)</h1>
  <div class="card">
    <div class="muted">
      Versi v18.8 — Full engine (v18.6 core) + Absence Enhanced (GK/DF/MD/FW) + H2H + International Mode (manual toggle) + Dual-workers + Visual + Export/Import + History.  
      Pastikan menempel semua Part (1→4) agar script lengkap dan berjalan.
    </div>
  </div>

  <!-- Top controls -->
  <div class="card">
    <div class="row controls">
      <label>League GPG<input id="league_gpg" type="number" step="0.01" value="2.6"></label>
      <label>Market OU<input id="market_ou" type="number" step="0.1" value="2.5"></label>
      <label>MC Iter<input id="mc_select" type="number" value="100000" step="1000"></label>
      <label>Fast<input id="fastMC" type="checkbox"></label>
      <label>Match Type<select id="match_type"><option>Regular</option><option>Derby</option><option>Final</option><option>Friendly</option><option>WC/Euro</option></select></label>
      <label>Competition<select id="comp_mode"><option>Club</option><option>Cup</option><option>Playoff</option><option>Super Cup</option><option>Friendly</option></select></label>
      <label style="display:flex;align-items:center">International Match<input id="international_toggle" type="checkbox" title="Centang jika pertandingan antar negara (tim nasional)"></label>
    </div>
    <div class="note">Jika <em>International Match</em> dicentang, engine akan menyesuaikan bobot Elo, mengurangi dampak PAF, dan memakai learning profile terpisah untuk data internasional.</div>
  </div>

  <div class="grid">
    <!-- Left: Inputs (Home) -->
    <div class="card">
      <strong>INPUT DETAIL — HOME</strong>
      <div class="row" style="margin-top:8px">
        <label>GPG<input id="h_gpg" type="number" step="0.01" placeholder="gpg"></label>
        <label>Shots<input id="h_shots" type="number" step="0.1" placeholder="shots"></label>
        <label>SOT<input id="h_sot" type="number" step="0.1" placeholder="sot"></label>
        <label>Conv%<input id="h_conv" type="number" step="0.1" placeholder="conv%"></label>
        <label>Poss%<input id="h_poss" type="number" step="0.1" placeholder="poss%"></label>
      </div>
      <div class="row" style="margin-top:8px">
        <label>GC<input id="h_gc" type="number" step="0.01" placeholder="gc"></label>
        <label>ShotsConceded<input id="h_shotsC" type="number" step="0.1" placeholder="shots conceded"></label>
        <label>CrossRate%<input id="h_cr" type="number" step="0.1" placeholder="cross%"></label>
        <label>OppELO<input id="h_oppelo" type="number" step="1" placeholder="opp elo"></label>
      </div>
      <div class="row" style="margin-top:8px">
        <label>FormG(5)<input id="h_formG" type="number" step="0.1" placeholder="goals last5"></label>
        <label>FormGA(5)<input id="h_formGA" type="number" step="0.1" placeholder="ga last5"></label>
        <label>W-D-L<input id="h_wdl" type="text" placeholder="3-1-1"></label>
        <label>Elo<input id="h_elo" type="number" step="1" placeholder="elo"></label>
        <label>PAF%<input id="h_paf" type="number" step="1" placeholder="player avail %" value=""></label>
      </div>

      <div style="margin-top:8px"><strong>Absensi Home (input angka)</strong></div>
      <div class="row" style="margin-top:6px">
        <label>GK absen<input id="h_gk_abs" class="abs-input" type="number" min="0" max="1" step="1" value="0"></label>
        <label>DF absen<input id="h_df_abs" class="abs-input" type="number" min="0" max="4" step="1" value="0"></label>
        <label>MD absen<input id="h_md_abs" class="abs-input" type="number" min="0" max="5" step="1" value="0"></label>
        <label>FW absen<input id="h_fw_abs" class="abs-input" type="number" min="0" max="3" step="1" value="0"></label>
      </div>

      <div style="margin-top:8px">
        <label>Odds HDP Open<input id="odds_hdp_open" type="number" step="0.25" placeholder="-0.75"></label>
        <label>Odds HDP Now<input id="odds_hdp_now" type="number" step="0.25" placeholder="-1.0"></label>
      </div>
    </div>

    <!-- Right: Inputs (Away) -->
    <div class="card">
      <strong>INPUT DETAIL — AWAY</strong>
      <div class="row" style="margin-top:8px">
        <label>GPG<input id="a_gpg" type="number" step="0.01" placeholder="gpg"></label>
        <label>Shots<input id="a_shots" type="number" step="0.1" placeholder="shots"></label>
        <label>SOT<input id="a_sot" type="number" step="0.1" placeholder="sot"></label>
        <label>Conv%<input id="a_conv" type="number" step="0.1" placeholder="conv%"></label>
        <label>Poss%<input id="a_poss" type="number" step="0.1" placeholder="poss%"></label>
      </div>
      <div class="row" style="margin-top:8px">
        <label>GC<input id="a_gc" type="number" step="0.01" placeholder="gc"></label>
        <label>ShotsConceded<input id="a_shotsC" type="number" step="0.1" placeholder="shots conceded"></label>
        <label>CrossRate%<input id="a_cr" type="number" step="0.1" placeholder="cross%"></label>
        <label>OppELO<input id="a_oppelo" type="number" step="1" placeholder="opp elo"></label>
      </div>
      <div class="row" style="margin-top:8px">
        <label>FormG(5)<input id="a_formG" type="number" step="0.1" placeholder="goals last5"></label>
        <label>FormGA(5)<input id="a_formGA" type="number" step="0.1" placeholder="ga last5"></label>
        <label>W-D-L<input id="a_wdl" type="text" placeholder="2-2-1"></label>
        <label>Elo<input id="a_elo" type="number" step="1" placeholder="elo"></label>
        <label>PAF%<input id="a_paf" type="number" step="1" placeholder="player avail %" value=""></label>
      </div>

      <div style="margin-top:8px"><strong>Absensi Away (input angka)</strong></div>
      <div class="row" style="margin-top:6px">
        <label>GK absen<input id="a_gk_abs" class="abs-input" type="number" min="0" max="1" step="1" value="0"></label>
        <label>DF absen<input id="a_df_abs" class="abs-input" type="number" min="0" max="4" step="1" value="0"></label>
        <label>MD absen<input id="a_md_abs" class="abs-input" type="number" min="0" max="5" step="1" value="0"></label>
        <label>FW absen<input id="a_fw_abs" class="abs-input" type="number" min="0" max="3" step="1" value="0"></label>
      </div>

      <div style="margin-top:8px">
        <label>Odds Home<input id="odds_home" type="number" step="0.01" placeholder="1.85"></label>
        <label>Odds Away<input id="odds_away" type="number" step="0.01" placeholder="2.05"></label>
      </div>
    </div>
  </div>

  <!-- H2H block -->
  <div class="card">
    <strong>Head to Head (H2H)</strong>
    <div class="small muted">Isi jumlah pertemuan sebelumnya. Jika kedua tim baru bertemu, biarkan kosong atau isi 0.</div>
    <div class="row" style="margin-top:8px">
      <label>H2H Home Win<input id="h2h_home" type="number" step="1" placeholder="0"></label>
      <label>H2H Draw<input id="h2h_draw" type="number" step="1" placeholder="0"></label>
      <label>H2H Away Win<input id="h2h_away" type="number" step="1" placeholder="0"></label>
    </div>

    <div class="row legend-rows">
      <div class="legend-item"><strong>Auto-PAF rule</strong><div class="muted">PAF% = 100 - (GK*6 + DF*2 + MD*1.5 + FW*4) clamped 65..100. Manual PAF overrides auto when provided. In <em>International Mode</em>, PAF impact is halved.</div></div>
      <div class="legend-item"><strong>International Mode</strong><div class="muted">Jika dicentang, Elo influence dikurangi 30%, PAF dampak dikurangi 50%, dan learning profile terpisah digunakan.</div></div>
    </div>
  </div>

  <div class="card">
    <div class="row controls">
      <button id="auto_home">Hitung Statistik Home</button>
      <button id="auto_away">Hitung Statistik Away</button>
      <button id="neutralize_btn">Normalisasi & Kalibrasi</button>
      <button id="exportProfileBtn">Export Profile</button>
      <input id="importProfileInput" type="file" accept=".json">
      <button id="viewHistoryBtn">View History</button>
      <button id="clearHistoryBtn">Clear History</button>
    </div>
  </div>

  <div class="card">
    <strong>OUTPUT</strong>
    <pre id="out">Hasil akan tampil di sini.</pre>
  </div>

  <!-- Visual panel -->
  <div class="card" id="visualPanel" style="margin-top:12px">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <strong>Visual Insight</strong>
      <div class="small muted">Bar (H/D/A) • Pie (Over/Under) • Gauge (Confidence) • Top scorelines • Absence & H2H notes • International indicator</div>
    </div>
    <canvas id="v_bar" width="820" height="200" style="width:100%;height:200px;border-radius:8px;background:transparent;margin-top:8px"></canvas>
    <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
      <canvas id="v_pie" width="160" height="160"></canvas>
      <canvas id="v_gauge" width="240" height="160"></canvas>
      <pre id="v_scores" style="background:#001122;padding:8px;border-radius:6px;color:#d6f8ee;max-height:120px;overflow:auto;margin-top:6px">-</pre>
    </div>
    <div id="paf_notes" class="small muted" style="margin-top:8px"></div>
    <div id="intl_note" class="small muted" style="margin-top:6px"></div>
  </div>
<script>
// -------------------- CORE UTILITIES --------------------
function _safeNum(v, fallback=null){ const n = Number(v); return Number.isFinite(n) ? n : fallback; }
function getNum(id, fallback=null){ const el=document.getElementById(id); if(!el) return fallback; return _safeNum(el.value, fallback); }
function parseNumSafe(v,f=0){ return Number.isFinite(v)?v:f; }
function clamp(v,a,b){ if(!Number.isFinite(v)) return a; return v<a? a : v>b? b : v; }
function round(v,d=3){ if(!Number.isFinite(v)) return v; return Math.round(v*Math.pow(10,d))/Math.pow(10,d); }
function safeJSONParse(s, fallback){ try{ return JSON.parse(s); }catch(e){ return fallback; } }

// parse W-D-L helper -> small performance multiplier
function parseWDL(str){
  try{
    if(!str) return 1;
    const parts = str.split('-').map(x=>parseInt(x,10)||0);
    if(parts.length!==3) return 1;
    const [w,d,l] = parts;
    const score = w*3 + d*1;
    const total = w+d+l || 1;
    const ratio = score / (total*3);
    return clamp(0.8 + ratio*0.6, 0.6, 1.4);
  }catch(e){ return 1; }
}

// -------------------- PAF positions helper --------------------
function computePAFfromPositions(gk,df,md,fw){
  const g = parseInt(gk)||0, d = parseInt(df)||0, m = parseInt(md)||0, f = parseInt(fw)||0;
  const loss = g*6 + d*2 + m*1.5 + f*4;
  return clamp(100 - loss, 65, 100);
}

// -------------------- STAT/CALC FUNCTIONS --------------------
function computeTrust(inputs){
  try{
    const keys = Object.keys(inputs||{});
    const filled = keys.filter(k=> Number.isFinite(inputs[k]) && inputs[k] !== null && inputs[k] !== '' ).length;
    return clamp(filled / Math.max(3, keys.length), 0.3, 1.0);
  }catch(e){ return 0.5; }
}

function computeDynamicWeights(inputs){
  const tempo = (parseNumSafe(inputs.shots,10) + parseNumSafe(inputs.poss,50)/2)/10;
  const stability = 1 - Math.abs((parseNumSafe(inputs.formG,0) - parseNumSafe(inputs.formGA,0))/10);
  const trust = computeTrust(inputs);
  return {
    shots: clamp(0.05 + tempo*0.005, 0.04, 0.09),
    sot: clamp(0.04 + trust*0.01, 0.03, 0.07),
    conv: clamp(0.03 + stability*0.02, 0.03, 0.06),
    poss: clamp(0.02 + tempo*0.002, 0.015, 0.04),
    cr: clamp(0.02 + trust*0.005, 0.015, 0.04)
  };
}

function computeXGplus(shots, sot, conv, poss, cr, leagueAvgXG, weights){
  shots = parseNumSafe(shots,0);
  sot = parseNumSafe(sot,0);
  conv = parseNumSafe(conv,0);
  poss = parseNumSafe(poss,50);
  cr = parseNumSafe(cr,25);
  weights = weights || {shots:0.065, sot:0.045, conv:0.035, poss:0.02, cr:0.025};
  const base = shots*weights.shots + sot*weights.sot + (conv/100)*shots*weights.conv + poss*weights.poss + cr*weights.cr;
  const blended = 0.65*base + 0.35*(leagueAvgXG||1.15);
  return clamp(blended, 0.01, 12);
}

function computeXGA(opShots, opSOT, opConv, leagueAvgXG, weights){
  const baseOpp = computeXGplus(opShots, opSOT, opConv, 50, 25, leagueAvgXG, weights);
  return clamp(baseOpp, 0.01, 12);
}

function computeDSIplus(gc, shotsC, oppElo, leagueAvgElo=1500){
  gc = parseNumSafe(gc,0); shotsC = parseNumSafe(shotsC,8); oppElo = parseNumSafe(oppElo, leagueAvgElo);
  const defensePressure = shotsC * 0.03;
  const eloAdj = (oppElo / leagueAvgElo);
  const base = gc*0.4 + defensePressure*0.6;
  return clamp(base * eloAdj, 0.12, 6);
}

function computeMomentum(g, ga){
  g = parseNumSafe(g,0); ga = parseNumSafe(ga,0);
  return clamp(1 + (g-ga)*0.05, 0.5, 1.5);
}

function computeIdentity(shots, poss, conv, cr, gc){
  shots = parseNumSafe(shots,10); poss = parseNumSafe(poss,50); conv = parseNumSafe(conv,10); cr = parseNumSafe(cr,25); gc = parseNumSafe(gc,1);
  const attack = shots * conv/100 + (cr/10);
  const control = poss/50;
  const risk = gc / Math.max(attack,1);
  const style = attack*0.5 + control*0.3 - risk*0.2;
  return clamp(style, 0.7, 1.35);
}

function computeFVF(g, ga){
  g = parseNumSafe(g,0); ga = parseNumSafe(ga,0);
  const total = g + ga; const ratio = Math.abs(g-ga) / (total || 1);
  return clamp(1 - ratio*0.32, 0.6, 1.15);
}

function calcFEI(gpg, estXG){
  gpg = parseNumSafe(gpg,0); estXG = parseNumSafe(estXG,0.8);
  if(estXG <= 1e-6) return 1;
  const raw = gpg / estXG;
  return clamp(0.6*raw + 0.4, 0.45, 1.8);
}

// -------------------- PROB SUPPORT --------------------
function factorial(n){ if(n<0) return 1; let r=1; for(let i=2;i<=n;i++) r*=i; return r; }
function poissonPMF(k,lambda){ if(k<0) return 0; return Math.exp(-lambda) * Math.pow(lambda,k) / factorial(k); }
function samplePoisson(lambda){
  lambda = parseNumSafe(lambda,0);
  if(lambda <= 0) return 0;
  if(lambda > 80){ const v = Math.round(lambda + Math.sqrt(lambda)*(Math.random()*2-1)); return Math.max(0,v); }
  const L = Math.exp(-lambda); let k=0, p=1; do{ k++; p *= Math.random(); } while(p > L); return k-1;
}
function skellamOutcomeProbs(lambdaH, lambdaA, maxrange=9){
  const probs = {home:0, draw:0, away:0};
  for(let gh=0; gh<=maxrange; gh++){
    for(let ga=0; ga<=maxrange; ga++){
      const p = poissonPMF(gh,lambdaH) * poissonPMF(ga,lambdaA);
      if(gh>ga) probs.home += p;
      else if(gh===ga) probs.draw += p;
      else probs.away += p;
    }
  }
  const s = probs.home + probs.draw + probs.away;
  if(s>0){ probs.home/=s; probs.draw/=s; probs.away/=s; }
  return probs;
}

function poissonOutcomeAnalytic(lambdaH, lambdaA, maxR=10){ return skellamOutcomeProbs(lambdaH, lambdaA, maxR); }
function ensembleMerge(p1,p2,p3){ const out={}; for(const k in p1) out[k] = (p1[k]||0)*0.5 + (p2[k]||0)*0.3 + (p3[k]||0)*0.2; return out; }
function bayesianBlend(pMC, pSkel, wt=0.65){ const out={}; for(const k in pMC) out[k] = (pMC[k]||0)*wt + (pSkel[k]||0)*(1-wt); return out; }

// -------------------- TRAP & CONFIDENCE --------------------
function computeAdvancedTrapOdds(hdpOpen, hdpNow, oddsHome, oddsAway){
  hdpOpen = _safeNum(hdpOpen, 0); hdpNow = _safeNum(hdpNow, 0);
  oddsHome = _safeNum(oddsHome, 2.0); oddsAway = _safeNum(oddsAway, 2.0);
  const lineShift = hdpNow - hdpOpen;
  const oddsDiff = Math.abs(oddsHome - oddsAway);
  const trapDivergence = (lineShift < 0 && oddsHome < oddsAway) ? 1.08 : 1.0;
  const symmetry = 1 - Math.min(oddsDiff/0.6,1) * 0.4;
  const linePressure = 1 - Math.min(Math.abs(lineShift)/0.5,1) * 0.2;
  return round(clamp(symmetry * linePressure * trapDivergence, 0.75, 1.25), 3);
}

function computeConfidence(prob){
  const p = prob || {home:0,draw:0,away:0};
  const maxP = Math.max(p.home||0, p.draw||0, p.away||0);
  const entropy = -((p.home||0)*Math.log((p.home||0)+1e-9) + (p.draw||0)*Math.log((p.draw||0)+1e-9) + (p.away||0)*Math.log((p.away||0)+1e-9));
  const normEnt = entropy / Math.log(3);
  return clamp((maxP - 1/3) * (1 - normEnt) * 2, 0, 1);
}

function computeQuantumConfidence(scores){
  const vals = Object.values(scores || {});
  if(vals.length===0) return 0;
  const mean = vals.reduce((a,b)=>a+b,0)/vals.length;
  const variance = vals.reduce((a,b)=>a + (b-mean)**2, 0)/vals.length;
  const spread = Math.sqrt(variance);
  return clamp(1 - spread*4, 0, 1);
}

// -------------------- LEARNING PROFILE & HISTORY (club + international separate) --------------------
const PROFILE_KEY_CLUB = 'qpe_learning_profile_v18_club';
const PROFILE_KEY_INTL = 'qpe_learning_profile_v18_international';
const HISTORY_KEY_CLUB = 'qpe_history_v18_club';
const HISTORY_KEY_INTL = 'qpe_history_v18_international';

function loadLearningProfile(isInternational){
  try{
    const key = isInternational ? PROFILE_KEY_INTL : PROFILE_KEY_CLUB;
    return JSON.parse(localStorage.getItem(key)) || {version:1, weights:{confidence:1, feedback:1}};
  }catch(e){
    return {version:1, weights:{confidence:1, feedback:1}};
  }
}
function saveLearningProfile(prof, isInternational){
  try{
    const key = isInternational ? PROFILE_KEY_INTL : PROFILE_KEY_CLUB;
    localStorage.setItem(key, JSON.stringify(prof));
    return true;
  }catch(e){ return false; }
}
function exportLearningProfile(isInternational){
  const prof = loadLearningProfile(isInternational);
  const blob = new Blob([JSON.stringify(prof,null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url;
  a.download = (isInternational ? 'qpe_learning_profile_v18_intl.json' : 'qpe_learning_profile_v18_club.json');
  document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
}
function importLearningProfile(file, isInternational){
  const r = new FileReader();
  r.onload = function(){
    try{ const obj = JSON.parse(r.result); saveLearningProfile(obj, isInternational); alert('Profile diimport berhasil'); }catch(e){ alert('File invalid'); }
  };
  r.readAsText(file);
}

function autoLearnFromHistory(isInternational){
  try{
    const key = isInternational ? HISTORY_KEY_INTL : HISTORY_KEY_CLUB;
    const hist = JSON.parse(localStorage.getItem(key)) || [];
    if(hist.length===0) return;
    let sumError=0, count=0;
    hist.forEach(h=>{
      if(h.real && h.probabilities){
        const err = Math.abs((h.real.home||0) - (h.probabilities.home||0));
        sumError += err; count++;
      }
    });
    const avgErr = count? (sumError/count) : 0.1;
    const prof = loadLearningProfile(isInternational);
    prof.weights.confidence = clamp(1 - avgErr*1.1, 0.6, 1.05);
    prof.weights.feedback = clamp(1 - avgErr*0.8, 0.7, 1.12);
    saveLearningProfile(prof, isInternational);
  }catch(e){ console.warn('autolearn failed', e); }
}

// -------------------- WORKER TEMPLATE --------------------
const workerScript = `
self.onmessage = function(e){
  const d = e.data;
  function parseNumSafe(v,f=0){ return (typeof v === 'number' && isFinite(v)) ? v : f; }
  function samplePoisson(lambda){
    lambda = parseNumSafe(lambda,0);
    if(lambda <= 0) return 0;
    if(lambda > 80){ const v = Math.round(lambda + Math.sqrt(lambda)*(Math.random()*2-1)); return Math.max(0,v); }
    const L = Math.exp(-lambda); let k=0,p=1; do{ k++; p *= Math.random(); } while(p > L); return k-1;
  }
  const counts = {home:0, draw:0, away:0, over:0, under:0, scores:{}};
  for(let t=0; t<d.mcIters; t++){
    const gh = samplePoisson(d.lambdaH);
    const ga = samplePoisson(d.lambdaA);
    if(gh > ga) counts.home++; else if(gh === ga) counts.draw++; else counts.away++;
    if(gh + ga > d.ouLine) counts.over++; else counts.under++;
    const k = gh + '-' + ga; counts.scores[k] = (counts.scores[k]||0) + 1;
  }
  ['home','draw','away','over','under'].forEach(k=>counts[k] = counts[k] / d.mcIters);
  for(const k in counts.scores) counts.scores[k] = counts.scores[k] / d.mcIters;
  postMessage({counts: counts});
};
`;
const blobA = new Blob([workerScript], {type: 'application/javascript'});
const blobB = new Blob([workerScript], {type: 'application/javascript'});
const workerUrlA = URL.createObjectURL(blobA);
const workerUrlB = URL.createObjectURL(blobB);
let workerA = null, workerB = null;
try{ workerA = new Worker(workerUrlA); workerB = new Worker(workerUrlB); }catch(e){ console.warn('Worker init failed — fallback to main thread', e); workerA=null; workerB=null; }

// -------------------- MAIN ANALYZE (with International adjustments) --------------------
document.getElementById('analyzeBtn').addEventListener('click', async function(){
  try{
    // read international toggle
    const isIntl = !!(document.getElementById('international_toggle') && document.getElementById('international_toggle').checked);

    // auto-learn per-mode
    autoLearnFromHistory(isIntl);

    // compute auto PAF from positions if PAF field empty
    const hPafField = document.getElementById('h_paf'), aPafField = document.getElementById('a_paf');
    const hManual = hPafField && hPafField.value!=='' && Number.isFinite(parseFloat(hPafField.value));
    const aManual = aPafField && aPafField.value!=='' && Number.isFinite(parseFloat(aPafField.value));
    const raw_hPAFauto = computePAFfromPositions(getNum('h_gk_abs')||0, getNum('h_df_abs')||0, getNum('h_md_abs')||0, getNum('h_fw_abs')||0);
    const raw_aPAFauto = computePAFfromPositions(getNum('a_gk_abs')||0, getNum('a_df_abs')||0, getNum('a_md_abs')||0, getNum('a_fw_abs')||0);
    // if international mode -> PAF impact halved for calculation (but still show auto)
    const hPAFauto = isIntl ? Math.round( (raw_hPAFauto - 100) * 0.5 + 100 ) : Math.round(raw_hPAFauto);
    const aPAFauto = isIntl ? Math.round( (raw_aPAFauto - 100) * 0.5 + 100 ) : Math.round(raw_aPAFauto);
    if(!hManual && hPafField) hPafField.value = String(Math.round(hPAFauto));
    if(!aManual && aPafField) aPafField.value = String(Math.round(aPAFauto));

    // inputs & basic params
    const leagueAvgXG = Math.max(0.3, parseNumSafe(getNum('league_gpg'),2.6)/2);
    const marketOU = parseNumSafe(getNum('market_ou'),2.5);
    const mcTotal = Math.max(1000, Math.min(500000, parseInt(getNum('mc_select',100000),10) || 100000));
    const matchType = document.getElementById('match_type') ? document.getElementById('match_type').value : 'Regular';
    const compMode = document.getElementById('comp_mode') ? document.getElementById('comp_mode').value : 'Club';

    // gather inputs
    const h = {
      gpg: getNum('h_gpg', null), shots: getNum('h_shots', null), sot: getNum('h_sot', null),
      conv: getNum('h_conv', null), poss: getNum('h_poss', null), gc: getNum('h_gc', null),
      shotsC: getNum('h_shotsC', null), cr: getNum('h_cr', null), oppelo: getNum('h_oppelo', null),
      formG: getNum('h_formG', null), formGA: getNum('h_formGA', null), wdl: (document.getElementById('h_wdl')||{}).value||'',
      elo: getNum('h_elo', null), paf: parseNumSafe(getNum('h_paf'), 100)
    };
    const a = {
      gpg: getNum('a_gpg', null), shots: getNum('a_shots', null), sot: getNum('a_sot', null),
      conv: getNum('a_conv', null), poss: getNum('a_poss', null), gc: getNum('a_gc', null),
      shotsC: getNum('a_shotsC', null), cr: getNum('a_cr', null), oppelo: getNum('a_oppelo', null),
      formG: getNum('a_formG', null), formGA: getNum('a_formGA', null), wdl: (document.getElementById('a_wdl')||{}).value||'',
      elo: getNum('a_elo', null), paf: parseNumSafe(getNum('a_paf'), 100)
    };

    // derived stats
    const weightsH = computeDynamicWeights(h), weightsA = computeDynamicWeights(a);
    const h_xg = computeXGplus(h.shots, h.sot, h.conv, h.poss, h.cr, leagueAvgXG, weightsH);
    const a_xg = computeXGplus(a.shots, a.sot, a.conv, a.poss, a.cr, leagueAvgXG, weightsA);
    const h_xga = computeXGA(a.shots, a.sot, a.conv, leagueAvgXG, weightsA);
    const a_xga = computeXGA(h.shots, h.sot, h.conv, leagueAvgXG, weightsH);
    const h_dsi = computeDSIplus(h.gc, h.shotsC, h.oppelo);
    const a_dsi = computeDSIplus(a.gc, a.shotsC, a.oppelo);
    const h_mom = computeMomentum(h.formG, h.formGA);
    const a_mom = computeMomentum(a.formG, a.formGA);
    const h_ident = computeIdentity(h.shots, h.poss, h.conv, h.cr, h.gc);
    const a_ident = computeIdentity(a.shots, a.poss, a.conv, a.cr, a.gc);
    const h_fvf = computeFVF(h.formG, h.formGA);
    const a_fvf = computeFVF(a.formG, a.formGA);
    const h_cei = (function(shots,gc){ shots=parseNumSafe(shots,10); gc=parseNumSafe(gc,1); const e = Math.log((shots+gc+1)); return clamp(1 + (e-3)*0.05, 0.8, 1.3); })(h.shots, h.gc);
    const a_cei = (function(shots,gc){ shots=parseNumSafe(shots,10); gc=parseNumSafe(gc,1); const e = Math.log((shots+gc+1)); return clamp(1 + (e-3)*0.05, 0.8, 1.3); })(a.shots, a.gc);

    // adjust PAF influence: if international, dampen PAF effect by 50%
    const h_paf_effect = isIntl ? clamp(parseNumSafe(h.paf,100)/100 * 0.5, 0.5, 1.0) : clamp(parseNumSafe(h.paf,100)/100, 0.5, 1.0);
    const a_paf_effect = isIntl ? clamp(parseNumSafe(a.paf,100)/100 * 0.5, 0.5, 1.0) : clamp(parseNumSafe(a.paf,100)/100, 0.5, 1.0);

    // FEI
    const h_fei = calcFEI(h.gpg, h_xg) * h_mom * h_fvf * h_paf_effect;
    const a_fei = calcFEI(a.gpg, a_xg) * a_mom * a_fvf * a_paf_effect;

    // Elo factor: if international, reduce Elo influence by 30%
    function computeEloDifferenceFactor(aElo,bElo, isInternational){
      const diff = (parseNumSafe(aElo,1500) - parseNumSafe(bElo,1500)) / 400;
      const base = clamp(1 + diff*0.35, 0.6, 1.4);
      return isInternational ? (1 - 0.3) * base + 0.3 * 1.0 : base;
    }
    const eloFactorHome = computeEloDifferenceFactor(h.elo||h.oppelo, a.elo||a.oppelo, isIntl);
    const eloFactorAway = computeEloDifferenceFactor(a.elo||a.oppelo, h.elo||h.oppelo, isIntl);

    // base lambdas
    let lambdaH = clamp((h_xg * (h_fei / (a_dsi||1)) * h_ident * h_cei * eloFactorHome) * (1 + h_xga*0.05), 0.01, 14);
    let lambdaA = clamp((a_xg * (a_fei / (h_dsi||1)) * a_ident * a_cei * eloFactorAway) * (1 + a_xga*0.05), 0.01, 14);

    // competition adjustments (if international and tournament like WC/Euro, boost knockout focus)
    const compMapClub = {"Club":{focus:1,rotation:1,knockout:1},"Cup":{focus:1.08,rotation:0.93,knockout:1.12},"Playoff":{focus:1.16,rotation:0.95,knockout:1.18},"Super Cup":{focus:1.05,rotation:0.9,knockout:1.08},"Friendly":{focus:0.85,rotation:1.2,knockout:0.9}};
    const compMapIntl = {"Club":{focus:1,rotation:1,knockout:1},"Cup":{focus:1.12,rotation:0.95,knockout:1.18},"Playoff":{focus:1.18,rotation:0.96,knockout:1.2},"Super Cup":{focus:1.08,rotation:0.9,knockout:1.12},"Friendly":{focus:0.9,rotation:1.15,knockout:0.95},"WC/Euro":{focus:1.22,rotation:0.92,knockout:1.25}};
    const comp = isIntl ? (compMapIntl[matchType] || compMapIntl['Friendly']) : (compMapClub[compMode] || compMapClub['Club']);
    lambdaH *= comp.focus/comp.rotation; lambdaA *= comp.focus/comp.rotation;
    const compAdj = clamp(((lambdaH+lambdaA)/2)*comp.knockout, 0.8, 1.45);
    lambdaH *= compAdj; lambdaA *= compAdj;

    const chaosMap = {Regular:1,Derby:1.08,Final:0.96,Friendly:0.94,'WC/Euro':1.02};
    const chaos = chaosMap[matchType] || 1;
    lambdaH *= chaos; lambdaA *= chaos;

    // H2H handling: if empty -> "Baru bertemu". If present, apply small tweak; stronger tweak if international.
    const h2hHome = parseInt(getNum('h2h_home',0)) || 0;
    const h2hDraw = parseInt(getNum('h2h_draw',0)) || 0;
    const h2hAway = parseInt(getNum('h2h_away',0)) || 0;
    const h2hTotal = h2hHome + h2hDraw + h2hAway;
    let h2hNote = 'Baru bertemu';
    if(h2hTotal > 0){
      const homeRatio = h2hHome / h2hTotal;
      const awayRatio = h2hAway / h2hTotal;
      const diff = clamp(homeRatio - awayRatio, -0.6, 0.6);
      // stronger influence in international mode (scale by 1.3)
      const scale = isIntl ? 1.3 : 1.0;
      lambdaH *= (1 + diff*0.07*scale);
      lambdaA *= (1 - diff*0.03*scale);
      h2hNote = `H2H present — home:${homeRatio.toFixed(2)} draw:${(h2hDraw/h2hTotal).toFixed(2)} away:${awayRatio.toFixed(2)}`;
    }

    // run MC with dual workers (fallback safe)
    const partA = Math.floor(mcTotal/2), partB = mcTotal - partA;
    document.getElementById('out').textContent = `Running MC (${mcTotal} iters) — mode: ${isIntl? 'International' : 'Club'} ...`;
    const payloadA = { lambdaH: lambdaH, lambdaA: lambdaA, mcIters: partA, ouLine: marketOU };
    const payloadB = { lambdaH: lambdaA, lambdaA: lambdaH, mcIters: partB, ouLine: marketOU };

    function simulateMainThread(payload){
      const counts = {home:0, draw:0, away:0, over:0, under:0, scores:{}};
      for(let t=0; t<payload.mcIters; t++){
        const gh = samplePoisson(payload.lambdaH);
        const ga = samplePoisson(payload.lambdaA);
        if(gh>ga) counts.home++; else if(gh===ga) counts.draw++; else counts.away++;
        if(gh+ga > payload.ouLine) counts.over++; else counts.under++;
        const k = gh + '-' + ga; counts.scores[k] = (counts.scores[k]||0) + 1;
      }
      ['home','draw','away','over','under'].forEach(k=>counts[k] = counts[k]/payload.mcIters);
      for(const k in counts.scores) counts.scores[k] = counts.scores[k]/payload.mcIters;
      return counts;
    }

    function runWorkerOnce(worker, payload){
      return new Promise((resolve)=>{
        if(worker){
          const hnd = (ev)=>{ worker.removeEventListener('message', hnd); resolve(ev.data.counts); };
          worker.addEventListener('message', hnd);
          try{ worker.postMessage(payload); }catch(e){ resolve(simulateMainThread(payload)); }
        } else { resolve(simulateMainThread(payload)); }
      });
    }

    const [outA, outB] = await Promise.all([ runWorkerOnce(workerA, payloadA), runWorkerOnce(workerB, payloadB) ]);

    // neutral merge
    const neutral = {
      home: (outA.home + outB.away) / 2,
      draw: (outA.draw + outB.draw) / 2,
      away: (outA.away + outB.home) / 2,
      over: (outA.over + outB.over) / 2,
      under: (outA.under + outB.under) / 2
    };

    const skel = skellamOutcomeProbs(lambdaH, lambdaA, 9);
    const analytic = poissonOutcomeAnalytic(lambdaH, lambdaA, 10);
    const merged = ensembleMerge(neutral, skel, analytic);
    const blended = bayesianBlend(merged, skel, 0.65);

    // trap & confidence
    const trapIndex = computeAdvancedTrapOdds(getNum('odds_hdp_open'), getNum('odds_hdp_now'), getNum('odds_home'), getNum('odds_away'));
    const trust = computeTrust(h) * computeTrust(a);
    let confidence = computeConfidence(blended) * trust;
    confidence *= clamp(trapIndex, 0.8, 1.12);
    const quantum_conf = computeQuantumConfidence(outA.scores);
    const prof = loadLearningProfile(isIntl);
    confidence *= clamp(prof.weights.feedback || 1, 0.7, 1.12);

    // elo expectation (reduced effect if international)
    function computeEloExpected(aE,bE){ if(!Number.isFinite(aE)||!Number.isFinite(bE)) return 0.5; return 1/(1+Math.pow(10,(bE-aE)/400)); }
    const eloExpect = computeEloExpected(h.elo||h.oppelo, a.elo||a.oppelo);
    const eloBalance = Math.abs(eloExpect - 0.5);
    const eloBoost = 1 - eloBalance * (isIntl ? 0.28*0.7 : 0.28); // slightly smaller effect if international
    confidence *= eloBoost;

    // prepare top scorelines
    const combinedScores = {};
    for(const k in outA.scores) combinedScores[k] = ((outA.scores[k]||0) + (outB.scores[k]||0)) / 2;
    const scoreEntries = Object.entries(combinedScores).map(([k,v])=>[k,v]).sort((a,b)=>b[1]-a[1]).slice(0,12).map(s=>({score:s[0], prob: round(s[1],4)}));

    // final probs normalized
    const sumP = (blended.home||0) + (blended.draw||0) + (blended.away||0);
    const norm = sumP > 0 ? sumP : 1;
    const finalProbs = {
      home: (blended.home||0)/norm,
      draw: (blended.draw||0)/norm,
      away: (blended.away||0)/norm,
      over: blended.over || 0,
      under: blended.under || 0
    };

    // package final
    const final = {
      meta: {
        mcTotal: mcTotal,
        parts: [partA, partB],
        trapIndex: round(trapIndex,3),
        trust: round(trust,3),
        confidence: round(clamp(confidence,0,1),3),
        quantum_conf: round(quantum_conf,3),
        feedbackWeight: prof.weights.feedback || 1,
        paf_auto_raw: { home: Math.round(raw_hPAFauto), away: Math.round(raw_aPAFauto) },
        paf_auto_effective: { home: Math.round(hPAFauto), away: Math.round(aPAFauto) },
        h2h_note: h2hNote,
        mode: isIntl ? 'international' : 'club'
      },
      inputs: { home: h, away: a, leagueAvg: { gpg: leagueAvgXG*2 }, compMode: compMode, matchType: matchType },
      core: { h_xg: round(h_xg,4), a_xg: round(a_xg,4), h_xga: round(h_xga,4), a_xga: round(a_xga,4), h_dsi: round(h_dsi,4), a_dsi: round(a_dsi,4), h_fei: round(h_fei,4), a_fei: round(a_fei,4), lambdaH: round(lambdaH,4), lambdaA: round(lambdaA,4), eloExpect: round(eloExpect,3) },
      probabilities: finalProbs,
      topScorelines: scoreEntries,
      market: { trapIndex: round(trapIndex,3), odds_home: _safeNum(getNum('odds_home')), odds_away: _safeNum(getNum('odds_away')) }
    };

    // save to history (separate keys)
    try{
      const hkey = isIntl ? HISTORY_KEY_INTL : HISTORY_KEY_CLUB;
      const hist = JSON.parse(localStorage.getItem(hkey)) || [];
      hist.push({ time: new Date().toISOString(), input: final.inputs, core: final.core, probabilities: final.probabilities, meta: final.meta, market: final.market });
      localStorage.setItem(hkey, JSON.stringify(hist));
    }catch(e){ console.warn('history save failed', e); }

    // auto-learn update
    autoLearnFromHistory(isIntl);

    // attach and display
    window._lastResult = final;
    document.getElementById('out').textContent = JSON.stringify(final, null, 2);

    // visual notes
    const pafNotesEl = document.getElementById('paf_notes');
    if(pafNotesEl){
      pafNotesEl.textContent = `Absensi Home: GK=${getNum('h_gk_abs')||0} DF=${getNum('h_df_abs')||0} MD=${getNum('h_md_abs')||0} FW=${getNum('h_fw_abs')||0} → rawPAF=${Math.round(raw_hPAFauto)}% effPAF=${Math.round(hPAFauto)}%.  Absensi Away: GK=${getNum('a_gk_abs')||0} DF=${getNum('a_df_abs')||0} MD=${getNum('a_md_abs')||0} FW=${getNum('a_fw_abs')||0} → rawPAF=${Math.round(raw_aPAFauto)}% effPAF=${Math.round(aPAFauto)}%.`;
    }
    const intlNoteEl = document.getElementById('intl_note');
    if(intlNoteEl) intlNoteEl.textContent = isIntl ? 'International Mode: ON (Elo reduced 30%, PAF effect halved)' : 'International Mode: OFF';

    // update visuals
    try{ if(typeof updateAllVisuals === 'function') updateAllVisuals(); }catch(e){}

  }catch(err){
    document.getElementById('out').textContent = 'ERROR — ' + String(err);
    console.error(err);
  }
});

// -------------------- EXPORT / HISTORY / PROFILE UI HANDLERS --------------------
// Download JSON
document.getElementById('downloadJsonBtn') && document.getElementById('downloadJsonBtn').addEventListener('click', ()=>{
  const res = window._lastResult;
  if(!res){ alert('Tidak ada hasil. Jalankan Analisis terlebih dahulu.'); return; }
  const blob = new Blob([JSON.stringify(res,null,2)], { type:'application/json' });
  const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url;
  a.download = 'qpe_v18.8_result_' + (new Date()).toISOString().replace(/[:]/g,'-') + '.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
});

// Export CSV (both club and intl combined in one CSV for convenience)
document.getElementById('exportCsvBtn') && document.getElementById('exportCsvBtn').addEventListener('click', ()=>{
  // combine histories
  const club = JSON.parse(localStorage.getItem(HISTORY_KEY_CLUB)) || [];
  const intl = JSON.parse(localStorage.getItem(HISTORY_KEY_INTL)) || [];
  const combined = club.concat(intl);
  if(combined.length===0){ alert('History kosong'); return; }
  const rows = [['time','mode','lambdaH','lambdaA','prob_home','prob_draw','prob_away','confidence','trapIndex','paf_home','paf_away']];
  combined.forEach(r=>{
    rows.push([ r.time, (r.meta && r.meta.mode) || '', r.core.lambdaH, r.core.lambdaA, r.probabilities.home, r.probabilities.draw, r.probabilities.away, r.meta.confidence, (r.market?r.market.trapIndex:''), (r.meta? r.meta.paf_auto_effective.home : ''), (r.meta? r.meta.paf_auto_effective.away : '') ]);
  });
  const csv = rows.map(r=> r.map(c=> typeof c==='string'? ('"'+c.replace(/"/g,'""')+'"') : c ).join(',')).join('\n');
  const blob = new Blob([csv], {type:'text/csv'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'qpe_history_v18_8.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
});

// Export/Import profile buttons: uses club profile by default, prompt user for Intl when needed
document.getElementById('exportProfileBtn') && (document.getElementById('exportProfileBtn').addEventListener('click', ()=>{
  const isIntl = confirm('Export learning profile for INTERNATIONAL mode? (OK = International, Cancel = Club)');
  exportLearningProfile(isIntl);
}));

document.getElementById('importProfileInput') && (document.getElementById('importProfileInput').addEventListener('change', (e)=>{
  if(e.target.files && e.target.files[0]){
    const isIntl = confirm('Import learning profile for INTERNATIONAL mode? (OK = International, Cancel = Club)');
    importLearningProfile(e.target.files[0], isIntl);
  }
}));

// View/Clear history (asks which mode)
document.getElementById('viewHistoryBtn') && document.getElementById('viewHistoryBtn').addEventListener('click', ()=>{
  const isIntl = confirm('View INTERNATIONAL history? (OK = International, Cancel = Club)');
  const key = isIntl ? HISTORY_KEY_INTL : HISTORY_KEY_CLUB;
  const hist = JSON.parse(localStorage.getItem(key)) || [];
  document.getElementById('out').textContent = JSON.stringify(hist.slice(-200), null, 2);
});
document.getElementById('clearHistoryBtn') && document.getElementById('clearHistoryBtn').addEventListener('click', ()=>{
  if(confirm('Hapus seluruh history? (OK = Club, Cancel = International)')){
    // if OK -> clear club; else clear intl
    const clearIntl = !confirm('Ingin juga kosongkan International history? (OK = yes clear both; Cancel = only club cleared)');
    if(clearIntl){
      localStorage.removeItem(HISTORY_KEY_CLUB);
      localStorage.removeItem(HISTORY_KEY_INTL);
      document.getElementById('out').textContent = 'All histories cleared';
    } else {
      localStorage.removeItem(HISTORY_KEY_CLUB);
      document.getElementById('out').textContent = 'Club history cleared';
    }
  }
});

// ensure default profiles exist
if(!localStorage.getItem(PROFILE_KEY_CLUB)) saveLearningProfile({version:1,weights:{confidence:1,feedback:1}}, false);
if(!localStorage.getItem(PROFILE_KEY_INTL)) saveLearningProfile({version:1,weights:{confidence:1,feedback:1}}, true);

console.log('QPE v18.8 core loaded.');
</script>
<script>
// -------------------- VISUALIZATION & UI UPDATE --------------------

// warna dasar
const VCOL = {
  home:'#7dd3c8', draw:'#60a5fa', away:'#fb7185',
  over:'#f59e0b', under:'#94a3b8',
  ok:'#10b981', warn:'#f59e0b', bad:'#f43f5e'
};

// warna menurut PAF
function pafColor(paf){
  paf = parseFloat(paf)||100;
  if(paf>=95) return '#7dd3c8';
  if(paf>=85) return '#f59e0b';
  if(paf>=75) return '#fb7185';
  return '#333333';
}

// bar chart H/D/A
function drawBar(ctx, probs, conf, pafH, pafA){
  const w = ctx.canvas.width, h = ctx.canvas.height;
  ctx.clearRect(0,0,w,h);
  const vals = [probs.home||0, probs.draw||0, probs.away||0];
  const labels = ['Home','Draw','Away'];
  const colors = [pafColor(pafH), VCOL.draw, pafColor(pafA)];
  const max = Math.max(...vals, 0.01);
  const baseY = h-30, barW = (w-100)/3;
  ctx.font='12px Inter,Arial'; ctx.fillStyle='#9aa3b2';
  ctx.fillText('Probabilities (H/D/A)',10,16);
  vals.forEach((v,i)=>{
    const bh = (h-80)*(v/max);
    const x = 40+i*(barW+40), y = baseY-bh;
    ctx.fillStyle=colors[i]; ctx.globalAlpha=0.8;
    ctx.fillRect(x,y,barW,bh);
    ctx.globalAlpha=1;
    ctx.fillStyle='#e6eef8';
    ctx.fillText((v*100).toFixed(1)+'%',x+barW/4,y-6);
    ctx.fillText(labels[i],x+barW/4,baseY+16);
  });
  ctx.fillStyle='#9aa3b2';
  ctx.fillText('Confidence: '+((conf||0)*100).toFixed(1)+'%', w-160,16);
}

// pie chart Over/Under
function drawPie(ctx, over){
  const w=ctx.canvas.width,h=ctx.canvas.height,cx=w/2,cy=h/2,r=Math.min(cx,cy)-6;
  const a1=-Math.PI/2,a2=a1+2*Math.PI*(over||0);
  ctx.clearRect(0,0,w,h);
  ctx.beginPath();ctx.arc(cx,cy,r,0,2*Math.PI);ctx.fillStyle='rgba(255,255,255,0.04)';ctx.fill();
  ctx.beginPath();ctx.moveTo(cx,cy);ctx.arc(cx,cy,r,a1,a2);ctx.closePath();ctx.fillStyle=VCOL.over;ctx.fill();
  ctx.beginPath();ctx.moveTo(cx,cy);ctx.arc(cx,cy,r,a2,a1+2*Math.PI);ctx.closePath();ctx.fillStyle=VCOL.under;ctx.fill();
  ctx.fillStyle='#e6eef8';ctx.font='12px Inter,Arial';
  ctx.fillText('Over '+((over||0)*100).toFixed(1)+'%',8,20);
  ctx.fillText('Under '+(((1-over)||0)*100).toFixed(1)+'%',8,h-10);
}

// gauge confidence
function drawGauge(ctx, conf){
  const w=ctx.canvas.width,h=ctx.canvas.height,cx=w/2,cy=h*0.9,r=Math.min(cx,cy)-10;
  ctx.clearRect(0,0,w,h);
  ctx.beginPath();ctx.lineWidth=10;ctx.strokeStyle='rgba(255,255,255,0.05)';
  ctx.arc(cx,cy,r,Math.PI,2*Math.PI);ctx.stroke();
  const a=clamp(conf,0,1),end=Math.PI+a*Math.PI;
  const col=a>0.66?VCOL.ok:a>0.4?VCOL.warn:VCOL.bad;
  ctx.beginPath();ctx.lineWidth=10;ctx.strokeStyle=col;ctx.lineCap='round';
  ctx.arc(cx,cy,r,Math.PI,end);ctx.stroke();
  const nx=cx+Math.cos(end)*(r-5),ny=cy+Math.sin(end)*(r-5);
  ctx.beginPath();ctx.moveTo(cx,cy);ctx.lineTo(nx,ny);ctx.strokeStyle='#e6eef8';ctx.lineWidth=2;ctx.stroke();
  ctx.beginPath();ctx.arc(cx,cy,3,0,2*Math.PI);ctx.fillStyle='#e6eef8';ctx.fill();
  ctx.fillStyle='#9aa3b2';ctx.font='12px Inter,Arial';
  ctx.fillText('Confidence '+(a*100).toFixed(1)+'%',8,16);
}

// updateAllVisuals: sinkronkan hasil
function updateAllVisuals(){
  const res=window._lastResult; if(!res) return;
  const bar=document.getElementById('v_bar').getContext('2d');
  const pie=document.getElementById('v_pie').getContext('2d');
  const gauge=document.getElementById('v_gauge').getContext('2d');
  const scores=document.getElementById('v_scores');
  const paf=res.meta.paf_auto_effective||{home:100,away:100};
  drawBar(bar,res.probabilities,res.meta.confidence,paf.home,paf.away);
  drawPie(pie,res.probabilities.over);
  drawGauge(gauge,res.meta.confidence);
  scores.textContent=(res.topScorelines||[]).map(s=>s.score+' : '+(s.prob*100).toFixed(2)+'%').join('\n');
  const notes=document.getElementById('paf_notes');
  notes.textContent='PAF Home '+paf.home+'% • Away '+paf.away+'% | '+(res.meta.h2h_note||'');
  const intl=document.getElementById('intl_note');
  intl.textContent=res.meta.mode==='international'?'International Mode: ON':'International Mode: OFF';
}

// tombol Visual/Data
let visualMode=true;
document.getElementById('toggleViewBtn').addEventListener('click',()=>{
  visualMode=!visualMode;
  document.getElementById('visualPanel').style.display=visualMode?'block':'none';
  document.getElementById('out').style.display=visualMode?'none':'block';
  document.getElementById('toggleViewBtn').textContent=visualMode?'Visual Mode':'Data Mode';
});

console.log('QPE v18.8 visuals ready.');
</script>
<script>
// -------------------- QUICK TOOLS & SELF CALIBRATION --------------------
function autoCalcHome(){
  const lg=Math.max(0.3,getNum('league_gpg',2.6)/2);
  const w=computeDynamicWeights({shots:getNum('h_shots'),poss:getNum('h_poss'),formG:getNum('h_formG'),formGA:getNum('h_formGA')});
  const xg=computeXGplus(getNum('h_shots'),getNum('h_sot'),getNum('h_conv'),getNum('h_poss'),getNum('h_cr'),lg,w);
  const dsi=computeDSIplus(getNum('h_gc'),getNum('h_shotsC'),getNum('h_oppelo'));
  const mom=computeMomentum(getNum('h_formG'),getNum('h_formGA'))*parseWDL((document.getElementById('h_wdl')||{}).value);
  const fei=calcFEI(getNum('h_gpg'),xg)*mom;
  document.getElementById('out').textContent=`Home auto→ xG:${round(xg,3)} DSI:${round(dsi,3)} MOM:${round(mom,3)} FEI:${round(fei,3)}`;
}
function autoCalcAway(){
  const lg=Math.max(0.3,getNum('league_gpg',2.6)/2);
  const w=computeDynamicWeights({shots:getNum('a_shots'),poss:getNum('a_poss'),formG:getNum('a_formG'),formGA:getNum('a_formGA')});
  const xg=computeXGplus(getNum('a_shots'),getNum('a_sot'),getNum('a_conv'),getNum('a_poss'),getNum('a_cr'),lg,w);
  const dsi=computeDSIplus(getNum('a_gc'),getNum('a_shotsC'),getNum('a_oppelo'));
  const mom=computeMomentum(getNum('a_formG'),getNum('a_formGA'))*parseWDL((document.getElementById('a_wdl')||{}).value);
  const fei=calcFEI(getNum('a_gpg'),xg)*mom;
  document.getElementById('out').textContent=`Away auto→ xG:${round(xg,3)} DSI:${round(dsi,3)} MOM:${round(mom,3)} FEI:${round(fei,3)}`;
}
document.getElementById('auto_home').onclick=autoCalcHome;
document.getElementById('auto_away').onclick=autoCalcAway;

// self-calibration memory (λ balance, confidence)
let qpeCalib=[];
function selfCalibrate(lambdaH,lambdaA,res){
  const bal=Math.abs((res.probabilities.home||0)-(res.probabilities.away||0));
  const stab=1-Math.abs((res.probabilities.home+res.probabilities.draw+res.probabilities.away)-1);
  const k=clamp(1+(0.5-bal)*0.06,0.94,1.06)*stab;
  qpeCalib.push({λH:lambdaH,λA:lambdaA,k,time:Date.now()});
  if(qpeCalib.length>300)qpeCalib.shift();
  return k;
}

// cleanup on exit
window.addEventListener('beforeunload',()=>{try{if(workerA)workerA.terminate();if(workerB)workerB.terminate();}catch(e){}});
console.log('QPE v18.8 final segment ready.');
</script>
</body>
</html>
