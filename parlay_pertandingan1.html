<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Prediksi Global v20.1 — Final Analyst Edition</title>
<style>
:root {
  --bg:#060b1a; --card:#0a1228; --muted:#9aa3b2; --accent:#0d9488;
  --attack:#f97316; --defense:#3b82f6; --strong:#10b981; --weak:#8b5cf6;
  --balanced:#93c5fd;
  color-scheme:dark;
}
body {
  font-family: 'Inter', system-ui, sans-serif;
  background: var(--bg); color:#e6eef8;
  margin: 12px;
}
h1 {
  font-size: 20px; margin: 8px 0; color: #7dd3fc;
}
.card {
  background: var(--card);
  padding: 12px; border-radius: 10px; margin-bottom: 12px;
  box-shadow: 0 0 6px rgba(0,0,0,0.3);
}
.row {
  display: flex; flex-wrap: wrap; gap: 8px; align-items: center;
}
label {
  font-size: 13px; color: var(--muted);
}
input[type=number], input[type=text], select {
  width: 130px; padding: 6px; border-radius: 6px;
  border: 1px solid rgba(255,255,255,0.1);
  background: transparent; color: inherit;
}
button {
  background: var(--accent); border:0; padding:8px 12px;
  border-radius:8px; color:#04201a; cursor:pointer;
}
button:hover {opacity:0.9;}
pre {
  background:#001020; padding:10px; border-radius:8px;
  color:#d6f8ee; white-space:pre-wrap;
}
canvas { background:transparent; border-radius:8px; }
.small { font-size:12px; color:var(--muted);}
.grid-2 { display:grid; grid-template-columns:1fr 520px; gap:12px; }
.legend { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
.radar-container { width:320px; height:320px; margin:auto; }
.trend-container { width:480px; height:200px; margin:auto; }
.tooltip {
  position: absolute; background: rgba(0,0,0,0.8);
  color: #fff; padding: 6px 10px; border-radius: 6px;
  font-size: 12px; display: none; z-index: 100;
}
.conf-meter {
  font-size:14px; text-align:center; margin-top:4px;
}
.summary {
  background:rgba(255,255,255,0.05); padding:8px; border-radius:8px;
  margin-top:6px; line-height:1.4;
}
</style>
</head>
<body>
<h1>⚽ Prediksi Global v20.1 — Hyper Predictive Engine (Final Analyst Edition)</h1>

<div class="card">
  <div class="small">Edisi final: semua algoritma matematis (λ, DSI, FEI, entropy confidence, AI-learning, league tuning) dengan interface analitik penuh — radar, trend, narasi, dan auto-kalibrasi.</div>
</div>

<!-- TOP CONTROL -->
<div class="card row">
  <label>League GPG<input id="league_gpg" type="number" step="0.01" value="2.6"></label>
  <label>Match Type
    <select id="match_type">
      <option>Regular</option><option>Derby</option><option>Final</option>
      <option>Friendly</option><option>Relegation</option>
    </select>
  </label>
  <label>Competition<select id="comp_mode">
    <option>Club</option><option>Cup</option><option>Playoff</option>
    <option>Super Cup</option><option>International</option>
  </select></label>
  <label>Weather<select id="weather">
    <option>Normal</option><option>Rain</option><option>Snow</option><option>Hot</option>
  </select></label>
  <button id="analyzeBtn">Analisis</button>
  <button id="toggleModeBtn">Analyst Mode</button>
</div>

<!-- MAIN GRID -->
<div class="grid-2">
  <div>
    <div class="card">
      <h3>Home Team</h3>
      <div class="row">
        <label>Nama<input id="h_name" type="text" placeholder="Home"></label>
        <label>GPG<input id="h_gpg" type="number" step="0.01"></label>
        <label>GC<input id="h_gc" type="number" step="0.01"></label>
      </div>
      <div class="row">
        <label>Shots<input id="h_shots" type="number" step="0.1"></label>
        <label>SOT<input id="h_sot" type="number" step="0.1"></label>
        <label>Conv%<input id="h_conv" type="number" step="0.1"></label>
      </div>
      <div class="row">
        <label>Poss%<input id="h_poss" type="number" step="0.1"></label>
        <label>ShotsConceded<input id="h_shotsC" type="number" step="0.1"></label>
        <label>CrossRate%<input id="h_cr" type="number" step="0.1"></label>
      </div>
      <div class="row">
        <label>Profil<select id="h_profile">
          <option value="auto">Auto</option>
          <option value="attack">Attack-heavy</option>
          <option value="defense">Defense-heavy</option>
          <option value="strong">Strong Both</option>
          <option value="weak">Weak Both</option>
          <option value="balanced">Balanced</option>
        </select></label>
        <label>ELO<input id="h_elo" type="number"></label>
      </div>
    </div>

    <div class="card">
      <h3>Away Team</h3>
      <div class="row">
        <label>Nama<input id="a_name" type="text" placeholder="Away"></label>
        <label>GPG<input id="a_gpg" type="number" step="0.01"></label>
        <label>GC<input id="a_gc" type="number" step="0.01"></label>
      </div>
      <div class="row">
        <label>Shots<input id="a_shots" type="number" step="0.1"></label>
        <label>SOT<input id="a_sot" type="number" step="0.1"></label>
        <label>Conv%<input id="a_conv" type="number" step="0.1"></label>
      </div>
      <div class="row">
        <label>Poss%<input id="a_poss" type="number" step="0.1"></label>
        <label>ShotsConceded<input id="a_shotsC" type="number" step="0.1"></label>
        <label>CrossRate%<input id="a_cr" type="number" step="0.1"></label>
      </div>
      <div class="row">
        <label>Profil<select id="a_profile">
          <option value="auto">Auto</option>
          <option value="attack">Attack-heavy</option>
          <option value="defense">Defense-heavy</option>
          <option value="strong">Strong Both</option>
          <option value="weak">Weak Both</option>
          <option value="balanced">Balanced</option>
        </select></label>
        <label>ELO<input id="a_elo" type="number"></label>
      </div>
    </div>

    <div class="card">
      <button id="autoExample">Contoh Data</button>
      <button id="exportBtn">Export CSV</button>
      <button id="viewHistory">Lihat History</button>
      <button id="clearHistory">Hapus History</button>
    </div>
  </div>

  <!-- OUTPUT PANEL -->
  <div>
    <div class="card">
      <strong>HASIL PREDIKSI</strong>
      <div id="summary" class="summary">Klik “Analisis” untuk melihat hasil.</div>
      <pre id="resultText"></pre>
      <div id="confMeter" class="conf-meter"></div>
    </div>

    <div class="card">
      <strong>Radar Profil</strong>
      <div class="radar-container"><canvas id="radarCanvas" width="320" height="320"></canvas></div>
    </div>

    <div class="card">
      <strong>Trend Hasil Sebelumnya</strong>
      <div class="trend-container"><canvas id="trendCanvas" width="480" height="200"></canvas></div>
    </div>
  </div>
</div>

<div id="tooltip" class="tooltip"></div>
<script>
/* ========================= Part 2 — Engine Core (v20.1 HPE) ========================= */

/* ---------- Utilities ---------- */
const safeNum = (v, d=0) => { const n = Number(v); return Number.isFinite(n) ? n : d; };
const clamp = (v,a,b) => isFinite(v)? (v<a?a: v>b?b:v) : a;
const rnd = (v,d=3) => Math.round((v||0)*10**d)/10**d;
function factorial(n){ if(n<0) return 1; let r=1; for(let i=2;i<=n;i++) r*=i; return r; }
function poissonPMF(k,λ){ if(k<0) return 0; return Math.exp(-λ)*Math.pow(λ,k)/factorial(k); }
function samplePoisson(λ){
  λ = safeNum(λ,0);
  if(λ<=0) return 0;
  if(λ>80){ const v = Math.round(λ + Math.sqrt(λ)*(Math.random()*2-1)); return Math.max(0,v); }
  const L = Math.exp(-λ); let k=0,p=1; do{ k++; p *= Math.random(); } while(p > L); return k-1;
}
function entropy(arr){ return -arr.reduce((s,x)=> s + (x>0? x*Math.log(x): 0), 0); }

/* ---------- Storage keys ---------- */
const HIST_KEY = 'qpe_v20_history';
const PROFILE_KEY = 'qpe_v20_profiles';

/* ---------- Helper: show tooltip ---------- */
const tooltip = document.getElementById('tooltip');
function showTooltip(html,x,y){ tooltip.style.left = (x+12) + 'px'; tooltip.style.top = (y+12) + 'px'; tooltip.innerHTML = html; tooltip.style.display='block'; }
function hideTooltip(){ tooltip.style.display='none'; }

/* ---------- Profile multipliers ---------- */
function profileMultiplier(code){
  switch(code){
    case 'attack': return {atk:1.12, def:0.88, color:'#f97316'};
    case 'defense': return {atk:0.90, def:1.10, color:'#3b82f6'};
    case 'strong': return {atk:1.10, def:1.10, color:'#10b981'};
    case 'weak': return {atk:0.90, def:0.90, color:'#8b5cf6'};
    case 'balanced': default: return {atk:1.00, def:1.00, color:'#93c5fd'};
  }
}

/* ---------- Auto-classify team style from xG/xGA ---------- */
function classifyTeam(xG,xGA){
  if(xG > 1.6 && xGA < 1.0) return 'strong';
  if(xG > 1.6 && xGA > 1.3) return 'attack';
  if(xG < 1.1 && xGA < 1.0) return 'defense';
  if(xG < 1.1 && xGA > 1.3) return 'weak';
  return 'balanced';
}

/* ---------- Compute dynamic xG proxy ---------- */
function computeXGplus(shots, sot, conv, poss, cr, leagueAvg, weights){
  shots = safeNum(shots,10); sot = safeNum(sot,4); conv = safeNum(conv,10); poss = safeNum(poss,50); cr = safeNum(cr,20);
  weights = weights || {shots:0.065,sot:0.045,conv:0.035,poss:0.02,cr:0.025};
  const base = shots*weights.shots + sot*weights.sot + (conv/100)*shots*weights.conv + (poss/100)*weights.poss*10 + cr*weights.cr;
  const blended = 0.65*base + 0.35*(leagueAvg||1.15);
  return clamp(blended, 0.01, 12);
}

/* ---------- Non-linear Defensive Strength Index (DSI) ---------- */
function computeDSI(gc, shotsC, oppElo, leagueAvgElo=1500){
  gc = safeNum(gc,1); shotsC = safeNum(shotsC,10); oppElo = safeNum(oppElo, leagueAvgElo);
  const defensePressure = Math.log1p(shotsC) * 0.25;
  const base = gc*0.45 + defensePressure*0.55;
  const eloAdj = Math.pow((oppElo/leagueAvgElo), 0.8);
  return clamp(base * eloAdj, 0.12, 6);
}

/* ---------- FEI (Finishing Efficiency) ---------- */
function calcFEI(gpg, estXG, formDelta=0, paf=1){
  gpg = safeNum(gpg,0); estXG = safeNum(estXG,0.8);
  if(estXG <= 1e-6) return 1;
  const raw = gpg/estXG;
  const base = clamp(0.6*raw + 0.4, 0.45, 1.8);
  const formFactor = 1 + clamp(formDelta, -0.5, 0.5) * 0.02;
  return clamp(base * formFactor * paf, 0.4, 2.2);
}

/* ---------- Elo sigmoid factor ---------- */
function eloSigmoidFactor(e1,e2,isIntl){
  const diff = (safeNum(e1,1500)-safeNum(e2,1500))/400;
  const s = 1/(1+Math.exp(-diff*1.8));
  const bias = 1 + (s - 0.5) * 0.8; // scaled
  return isIntl ? (0.7*bias + 0.3) : bias;
}

/* ---------- Context corrections ---------- */
function homeAdvFactor(isIntl, comp, matchType){
  if(isIntl) return 1.03;
  if(matchType === 'Final') return 1.05;
  if(comp === 'Cup') return 1.07;
  return 1.10;
}
function pressureFactor(matchType){
  if(matchType === 'Final' || matchType === 'Derby') return 0.96;
  if(matchType === 'Relegation') return 0.92;
  return 1.0;
}

/* ---------- Ensemble blending (MC + Skellam + EloLog) ---------- */
function skellamOutcome(lambdaH, lambdaA, maxr=10){
  const probs = {home:0,draw:0,away:0};
  for(let gh=0; gh<=maxr; gh++){
    for(let ga=0; ga<=maxr; ga++){
      const p = poissonPMF(gh,lambdaH)*poissonPMF(ga,lambdaA);
      if(gh>ga) probs.home += p; else if(gh===ga) probs.draw += p; else probs.away += p;
    }
  }
  const s = probs.home + probs.draw + probs.away;
  if(s>0){ probs.home/=s; probs.draw/=s; probs.away/=s; }
  return probs;
}
function logisticEloProb(hE,aE){
  const diff = (safeNum(hE,1500)-safeNum(aE,1500))/400;
  const ph = 1/(1+Math.pow(10,-diff));
  const draw = 0.20; // baseline draw rate for logistic proxy
  const home = clamp(ph*(1-draw), 0.05, 0.9);
  const away = clamp((1-ph)*(1-draw), 0.05, 0.9);
  return {home, draw:draw, away};
}

/* ---------- Confidence meta ---------- */
function computeConfidence(probs, lambdaH, lambdaA, trapIndex, pastErr=0){
  const maxP = Math.max(probs.home, probs.draw, probs.away);
  const ent = entropy([probs.home,probs.draw,probs.away]) / Math.log(3);
  let conf = clamp((maxP - 1/3)*(1 - ent)*2, 0, 1);
  // lambda spread boost
  const lambdaDiff = Math.abs(lambdaH - lambdaA);
  conf *= clamp(1 + (lambdaDiff/3)*0.2, 0.85, 1.25);
  // trap penalize
  conf *= clamp(1 - Math.abs(trapIndex-1)*0.28, 0.7, 1.1);
  // historical calibration (lower if past error high)
  conf *= clamp(1 - pastErr*0.5, 0.7, 1.05);
  return clamp(conf, 0, 1);
}

/* ---------- Worker (fallback-safe) ---------- */
let workerUrl = null, workerInstance = null;
const workerSrc = `
self.onmessage = function(e){
  const D = e.data;
  function safeNum(v,d=0){ const n=Number(v); return Number.isFinite(n)?n:d; }
  function samplePoisson(lambda){
    lambda = safeNum(lambda,0); if(lambda<=0) return 0;
    if(lambda>80){ const v=Math.round(lambda + Math.sqrt(lambda)*(Math.random()*2-1)); return Math.max(0,v); }
    const L=Math.exp(-lambda); let k=0,p=1; do{ k++; p*=Math.random(); } while(p>L); return k-1;
  }
  const counts = {home:0,draw:0,away:0,over:0,under:0,scores:{}};
  for(let i=0;i<D.iters;i++){
    const gh = samplePoisson(D.lambdaH);
    const ga = samplePoisson(D.lambdaA);
    if(gh>ga) counts.home++; else if(gh==ga) counts.draw++; else counts.away++;
    if(gh+ga > D.ou) counts.over++; else counts.under++;
    const k = gh + '-' + ga;
    counts.scores[k] = (counts.scores[k]||0) + 1;
  }
  ['home','draw','away','over','under'].forEach(k=>counts[k] = counts[k]/D.iters);
  for(const k in counts.scores) counts.scores[k] = counts.scores[k]/D.iters;
  postMessage(counts);
};
`;
function initWorker(){
  try{
    const b = new Blob([workerSrc],{type:'application/javascript'});
    if(workerUrl) URL.revokeObjectURL(workerUrl);
    workerUrl = URL.createObjectURL(b);
    workerInstance = new Worker(workerUrl);
  }catch(e){ workerInstance = null; }
}
initWorker();

/* ---------- Save history ---------- */
function saveHistory(entry){
  try{
    const arr = JSON.parse(localStorage.getItem(HIST_KEY)) || [];
    arr.push(Object.assign({time: (new Date()).toISOString()}, entry));
    // keep last 1000
    if(arr.length>1000) arr.splice(0, arr.length-1000);
    localStorage.setItem(HIST_KEY, JSON.stringify(arr));
  }catch(e){ console.warn('history save failed', e); }
}

/* ---------- Export CSV helper ---------- */
function exportHistoryCSV(){
  const arr = JSON.parse(localStorage.getItem(HIST_KEY)) || [];
  if(!arr.length){ alert('History kosong'); return; }
  const rows = [['time','mode','home','away','p_home','p_draw','p_away','confidence']];
  arr.forEach(r=>{
    rows.push([r.time, r.mode, r.inputs.home.name, r.inputs.away.name, r.probabilities.home, r.probabilities.draw, r.probabilities.away, r.meta.confidence]);
  });
  const csv = rows.map(r=> r.map(c=> typeof c === 'string' ? '"' + c.replace(/"/g,'""') + '"' : c).join(',')).join('\n');
  const blob = new Blob([csv],{type:'text/csv'}); const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'qpe_history_v20.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
}

/* ---------- Display helpers (radar/trend) ---------- */
const radarCtx = document.getElementById('radarCanvas').getContext('2d');
const trendCtx = document.getElementById('trendCanvas').getContext('2d');

function drawRadar(attackH,defH,attackA,defA){
  const ctx = radarCtx;
  ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);
  const cx = ctx.canvas.width/2, cy = ctx.canvas.height/2, r = Math.min(cx,cy)-20;
  const labels = ['Attack','Defense','Form','PAF','Conv%'];
  // simple radial plotting using attack/def scaled
  function drawPoly(vals, col, alpha){
    ctx.beginPath();
    vals.forEach((v,i)=>{
      const ang = -Math.PI/2 + i*(2*Math.PI/5);
      const rad = r * clamp(v/1.5, 0, 1);
      const x = cx + Math.cos(ang)*rad;
      const y = cy + Math.sin(ang)*rad;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.closePath();
    ctx.fillStyle = col; ctx.globalAlpha = alpha; ctx.fill();
    ctx.globalAlpha = 1; ctx.strokeStyle = '#0f172a'; ctx.stroke();
  }
  // background axes
  ctx.strokeStyle = 'rgba(255,255,255,0.05)';
  for(let ring=0; ring<5; ring++){
    ctx.beginPath();
    const rr = r*(1-ring*0.18);
    for(let i=0;i<5;i++){
      const ang = -Math.PI/2 + i*(2*Math.PI/5);
      const x=cx+Math.cos(ang)*rr, y=cy+Math.sin(ang)*rr;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath(); ctx.stroke();
  }
  // draw two polygons
  drawPoly([attackH,defH, attackH*0.45, attackH*0.6, attackH*0.8], 'rgba(249,115,22,0.6)', 0.35);
  drawPoly([attackA,defA, attackA*0.45, attackA*0.6, attackA*0.8], 'rgba(59,130,246,0.6)', 0.35);
  // labels
  ctx.fillStyle = '#9aa3b2'; ctx.font='12px Inter';
  labels.forEach((lab,i)=>{ const ang = -Math.PI/2 + i*(2*Math.PI/5); const x = cx + Math.cos(ang)*(r+14); const y = cy + Math.sin(ang)*(r+14); ctx.fillText(lab, x-12, y+4); });
}

function drawTrend(history){
  const ctx = trendCtx; ctx.clearRect(0,0, ctx.canvas.width, ctx.canvas.height);
  if(!history || history.length===0) return;
  // plot last up to 30 points of p_home, p_draw, p_away
  const N = Math.min(history.length, 30);
  const slice = history.slice(-N);
  const w = ctx.canvas.width, h = ctx.canvas.height;
  const pad = 30;
  function scaleX(i){ return pad + (i/(N-1))*(w-2*pad); }
  function scaleY(v){ return h - pad - (v)*(h-2*pad); }
  // draw axes
  ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.beginPath(); ctx.moveTo(pad,pad); ctx.lineTo(pad,h-pad); ctx.lineTo(w-pad,h-pad); ctx.stroke();
  // draw lines
  const cols = ['#7dd3c8','#60a5fa','#f59e0b'];
  ['home','draw','away'].forEach((k,idx)=>{
    ctx.beginPath(); ctx.strokeStyle = cols[idx]; ctx.lineWidth=2;
    slice.forEach((it,i)=>{
      const v = it.probabilities[k] || 0;
      const x = scaleX(i); const y = scaleY(v);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.stroke();
  });
}

/* ---------- Main analyze handler ---------- */
document.getElementById('analyzeBtn').addEventListener('click', async function(){
  try{
    // collect UI
    const leagueGPG = Math.max(0.3, safeNum(document.getElementById('league_gpg').value, 2.6));
    const matchType = document.getElementById('match_type').value;
    const comp = document.getElementById('comp_mode').value;
    const weather = document.getElementById('weather').value;
    // inputs home
    const h = {
      name: (document.getElementById('h_name')||{}).value || 'HOME',
      gpg: safeNum(document.getElementById('h_gpg').value, 1.4),
      gc: safeNum(document.getElementById('h_gc').value, 1.2),
      shots: safeNum(document.getElementById('h_shots').value, 11),
      sot: safeNum(document.getElementById('h_sot').value, 4),
      conv: safeNum(document.getElementById('h_conv').value, 12),
      poss: safeNum(document.getElementById('h_poss').value, 52),
      shotsC: safeNum(document.getElementById('h_shotsC').value, 11),
      cr: safeNum(document.getElementById('h_cr').value, 20),
      elo: safeNum(document.getElementById('h_elo').value, 1500),
      profile: (document.getElementById('h_profile')||{}).value || 'auto'
    };
    // inputs away
    const a = {
      name: (document.getElementById('a_name')||{}).value || 'AWAY',
      gpg: safeNum(document.getElementById('a_gpg').value, 1.2),
      gc: safeNum(document.getElementById('a_gc').value, 1.3),
      shots: safeNum(document.getElementById('a_shots').value, 10),
      sot: safeNum(document.getElementById('a_sot').value, 4),
      conv: safeNum(document.getElementById('a_conv').value, 11),
      poss: safeNum(document.getElementById('a_poss').value, 48),
      shotsC: safeNum(document.getElementById('a_shotsC').value, 12),
      cr: safeNum(document.getElementById('a_cr').value, 20),
      elo: safeNum(document.getElementById('a_elo').value, 1500),
      profile: (document.getElementById('a_profile')||{}).value || 'auto'
    };

    // compute auto profile if needed
    // estimate xG proxies first
    const wH = {shots:0.065, sot:0.045, conv:0.035, poss:0.02, cr:0.025};
    const wA = {shots:0.065, sot:0.045, conv:0.035, poss:0.02, cr:0.025};
    const h_xg = computeXGplus(h.shots,h.sot,h.conv,h.poss,h.cr, leagueGPG, wH);
    const a_xg = computeXGplus(a.shots,a.sot,a.conv,a.poss,a.cr, leagueGPG, wA);
    const h_xga = computeXGplus(a.shots,a.sot,a.conv,a.poss,a.cr, leagueGPG, wA);
    const a_xga = computeXGplus(h.shots,h.sot,h.conv,h.poss,h.cr, leagueGPG, wH);

    if(h.profile === 'auto') h.profile = classifyTeam(h_xg, h_xga);
    if(a.profile === 'auto') a.profile = classifyTeam(a_xg, a_xga);

    // compute DSI
    const h_dsi = computeDSI(h.gc, h.shotsC, a.elo);
    const a_dsi = computeDSI(a.gc, a.shotsC, h.elo);

    // FEI
    const h_formDelta = 0; const a_formDelta = 0; // could be filled from form inputs if available
    const h_paf = 1.0; const a_paf = 1.0; // PAF could be integrated from absences if present in UI
    const h_fei = calcFEI(h.gpg, h_xg, h_formDelta, h_paf);
    const a_fei = calcFEI(a.gpg, a_xg, a_formDelta, a_paf);

    // base lambdas (attack vs opponent defense)
    let lambdaH = clamp((h_xg * (h_fei / (a_dsi || 1)) ) * (1 + h_xga*0.04), 0.01, 14);
    let lambdaA = clamp((a_xg * (a_fei / (h_dsi || 1)) ) * (1 + a_xga*0.04), 0.01, 14);

    // apply profile multipliers (responsive vs opponent)
    const ph = profileMultiplier(h.profile);
    const pa = profileMultiplier(a.profile);
    // responsive scaling: reduce extremes against strong DSI
    const adj_h_atk = ph.atk * (1 - 0.12 * Math.min(a_dsi/4, 1));
    const adj_a_atk = pa.atk * (1 - 0.12 * Math.min(h_dsi/4, 1));
    const adj_h_def = ph.def * (1 + 0.08 * Math.min(a_fei/1.2, 1));
    const adj_a_def = pa.def * (1 + 0.08 * Math.min(h_fei/1.2, 1));
    lambdaH *= (adj_h_atk / adj_a_def);
    lambdaA *= (adj_a_atk / adj_h_def);

    // context corrections: home advantage, pressure, weather, league bias
    const isIntl = (comp === 'International');
    lambdaH *= homeAdvFactor(isIntl, comp, matchType);
    lambdaA *= 1.0; // away no boost
    lambdaH *= pressureFactor(matchType);
    lambdaA *= pressureFactor(matchType);
    // weather small penalties
    if(weather === 'Rain' || weather === 'Snow'){ lambdaH *= 0.94; lambdaA *= 0.94; }
    if(weather === 'Hot'){ lambdaH *= 0.97; lambdaA *= 0.97; }

    // league normalization
    const leagueBias = Math.pow((leagueGPG/2.6), 0.7);
    lambdaH *= leagueBias; lambdaA *= leagueBias;

    // Elo sigmoid adjustment
    const eloF = eloSigmoidFactor(h.elo, a.elo, isIntl);
    lambdaH *= eloF; lambdaA *= (1/eloF || 1);

    // small chaos for derby/finals
    if(matchType === 'Derby') { lambdaH *= 1.06; lambdaA *= 1.06; }
    if(matchType === 'Final') { lambdaH *= 0.98; lambdaA *= 0.98; }

    // zero-inflation adjustment for defensive leagues (optional small)
    // if leagueGPG < 2.3 -> higher zero inflation -> reduce lambda slightly
    if(leagueGPG < 2.3){ const z = 1 - (2.3 - leagueGPG)*0.06; lambdaH *= z; lambdaA *= z; }

    // trap index: check odds fields if present
    const oddsHome = safeNum(document.getElementById('odds_home')?.value, null);
    const oddsAway = safeNum(document.getElementById('odds_away')?.value, null);
    const hdpOpen = safeNum(document.getElementById('odds_hdp_open')?.value, 0);
    const hdpNow = safeNum(document.getElementById('odds_hdp_now')?.value, 0);
    function computeTrap(hOpen, hNow, oH, oA){
      const shift = hNow - hOpen;
      const oddsDiff = Math.abs((oH||2) - (oA||2));
      const linePressure = 1 - Math.min(Math.abs(shift)/0.75,1)*0.35;
      const symmetry = 1 - Math.min(oddsDiff/0.6,1)*0.45;
      const directional = (shift<0 && oH < oA) || (shift>0 && oA < oH) ? 1.09 : 1.0;
      return clamp(symmetry * linePressure * directional, 0.6, 1.35);
    }
    const trapIndex = computeTrap(hdpOpen, hdpNow, oddsHome, oddsAway);

    // Monte Carlo: try worker first
    const MC_ITERS = Math.max(2000, Math.floor((safeNum(document.getElementById('mc_select')?.value, 20000) || 20000)));
    const useWorker = !!workerInstance;
    const halfA = Math.floor(MC_ITERS/2), halfB = MC_ITERS - halfA;

    function runMainSim(lambdaH_use, lambdaA_use, iters, ou){
      // fallback main-thread simulation
      const counts = {home:0,draw:0,away:0,over:0,under:0,scores:{}};
      for(let i=0;i<iters;i++){
        const gh = samplePoisson(lambdaH_use);
        const ga = samplePoisson(lambdaA_use);
        if(gh>ga) counts.home++; else if(gh===ga) counts.draw++; else counts.away++;
        if(gh+ga > ou) counts.over++; else counts.under++;
        const k = gh + '-' + ga; counts.scores[k] = (counts.scores[k]||0) + 1;
      }
      ['home','draw','away','over','under'].forEach(k=>counts[k] = counts[k]/iters);
      for(const k in counts.scores) counts.scores[k] = counts.scores[k]/iters;
      return counts;
    }

    function runWorkerSim(lambdaH_use, lambdaA_use, iters, ou){
      return new Promise((resolve)=>{
        if(!workerInstance){ resolve(runMainSim(lambdaH_use, lambdaA_use, iters, ou)); return; }
        const handler = (ev)=>{ workerInstance.removeEventListener('message', handler); resolve(ev.data); };
        workerInstance.addEventListener('message', handler);
        try{ workerInstance.postMessage({lambdaH: lambdaH_use, lambdaA: lambdaA_use, iters: iters, ou: ou}); }
        catch(e){ workerInstance.removeEventListener('message', handler); resolve(runMainSim(lambdaH_use, lambdaA_use, iters, ou)); }
      });
    }

    // run two sims (mirrored)
    const simA = runWorkerSim(lambdaH, lambdaA, halfA, safeNum(document.getElementById('market_ou')?.value, 2.5));
    const simB = runWorkerSim(lambdaA, lambdaH, halfB, safeNum(document.getElementById('market_ou')?.value, 2.5));
    const [outA, outB] = await Promise.all([simA, simB]);

    // merge neutral
    const neutral = {
      home: (outA.home + outB.away)/2,
      draw: (outA.draw + outB.draw)/2,
      away: (outA.away + outB.home)/2,
      over: (outA.over + outB.over)/2,
      under: (outA.under + outB.under)/2
    };

    // skellam analytic
    const sk = skellamOutcome(lambdaH, lambdaA, 10);
    const eloLog = logisticEloProb(h.elo, a.elo);

    // ensemble blend: weighted MC-neutral + skellam + eloLog
    const blended = {
      home: clamp(neutral.home*0.55 + sk.home*0.30 + eloLog.home*0.15, 0, 1),
      draw: clamp(neutral.draw*0.55 + sk.draw*0.30 + eloLog.draw*0.15, 0, 1),
      away: clamp(neutral.away*0.55 + sk.away*0.30 + eloLog.away*0.15, 0, 1),
      over: neutral.over, under: neutral.under
    };
    // normalize H/D/A
    const ssum = blended.home + blended.draw + blended.away;
    const finalProbs = ssum>0 ? {home: blended.home/ssum, draw: blended.draw/ssum, away: blended.away/ssum, over: blended.over, under: blended.under} : {home:0.33,draw:0.34,away:0.33, over:neutral.over, under:neutral.under};

    // compute confidence (use past history error for league/team if available)
    const hist = JSON.parse(localStorage.getItem(HIST_KEY) || "[]");
    let pastErr = 0;
    if(hist.length>0){
      const last = hist.slice(-20);
      const errs = last.map(it => Math.abs((it.real_total_goals||0) - ( (it.inputs.core_lambdaH||0) + (it.inputs.core_lambdaA||0) ) ) );
      pastErr = errs.reduce((s,x)=>s+x,0)/Math.max(1,errs.length);
      pastErr = clamp(pastErr/3, 0, 1); // scale
    }
    const confidence = computeConfidence(finalProbs, lambdaH, lambdaA, trapIndex, pastErr);

    // compose result object
    const result = {
      meta: { mode: comp, matchType, leagueGPG, confidence: rnd(confidence,3), trapIndex: rnd(trapIndex,3), lambdaH: rnd(lambdaH,4), lambdaA: rnd(lambdaA,4), mcIters: MC_ITERS },
      inputs: { home: h, away: a },
      core: { h_xg: rnd(h_xg,3), a_xg: rnd(a_xg,3), h_dsi: rnd(h_dsi,3), a_dsi: rnd(a_dsi,3), h_fei: rnd(h_fei,3), a_fei: rnd(a_fei,3) },
      probabilities: finalProbs,
      topScores: Object.entries(Object.assign({}, outA.scores, outB.scores)).map(e=>({score:e[0],prob: ( (outA.scores[e[0]]||0) + (outB.scores[e[0]]||0) )/2})).sort((x,y)=>y.prob-x.prob).slice(0,12)
    };

    // save to history
    try{ saveHistory(result); }catch(e){}

    // update UI summary & visuals
    const summary = document.getElementById('summary');
    const resText = document.getElementById('resultText');
    summary.innerHTML = `<strong>${h.name}</strong> vs <strong>${a.name}</strong> — Mode: ${comp} — ${matchType}<br/>
      Prob (H/D/A): <strong>${(finalProbs.home*100).toFixed(1)}%</strong> / <strong>${(finalProbs.draw*100).toFixed(1)}%</strong> / <strong>${(finalProbs.away*100).toFixed(1)}%</strong><br/>
      Over ${(finalProbs.over*100).toFixed(1)}% • Under ${(finalProbs.under*100).toFixed(1)}%<br/>
      Confidence: <strong>${(result.meta.confidence*100).toFixed(1)}%</strong> • Trap: ${result.meta.trapIndex}`;

    resText.textContent = JSON.stringify(result, null, 2);

    // draw radar & trend
    const attackH = clamp(h_xg/1.5, 0, 2); const defH = clamp(1/(h_dsi||1), 0, 2);
    const attackA = clamp(a_xg/1.5, 0, 2); const defA = clamp(1/(a_dsi||1), 0, 2);
    drawRadar(attackH, defH, attackA, defA);

    const history = JSON.parse(localStorage.getItem(HIST_KEY) || "[]");
    drawTrend(history);

    // confidence meter
    const confEl = document.getElementById('confMeter');
    const c = result.meta.confidence;
    confEl.innerHTML = `<div style="padding:6px;border-radius:6px;background:rgba(255,255,255,0.03)">Confidence: <strong>${(c*100).toFixed(1)}%</strong></div>`;
    // color bar
    if(c>0.66) confEl.style.color = '#10b981'; else if(c>0.4) confEl.style.color = '#f59e0b'; else confEl.style.color = '#fb7185';

    // store last result for download
    window._qpe_last = result;

  }catch(err){
    console.error('Analyze error:', err);
    alert('Terjadi error saat analisis. Cek console.');
  }
});

/* ---------- Buttons: example, export, history ---------- */
document.getElementById('autoExample').addEventListener('click', ()=>{
  // populate example quick
  document.getElementById('h_name').value = 'Home Example';
  document.getElementById('h_gpg').value = 1.9; document.getElementById('h_gc').value = 0.98;
  document.getElementById('h_shots').value = 13; document.getElementById('h_sot').value = 5; document.getElementById('h_conv').value = 14; document.getElementById('h_poss').value=58;
  document.getElementById('a_name').value = 'Away Example';
  document.getElementById('a_gpg').value = 1.3; document.getElementById('a_gc').value = 1.4;
  document.getElementById('a_shots').value = 10; document.getElementById('a_sot').value = 4; document.getElementById('a_conv').value = 10; document.getElementById('a_poss').value=45;
  alert('Contoh data dimuat. Klik Analisis.');
});
document.getElementById('exportBtn').addEventListener('click', ()=> exportHistoryCSV());
document.getElementById('viewHistory').addEventListener('click', ()=>{
  const h = JSON.parse(localStorage.getItem(HIST_KEY) || "[]");
  document.getElementById('resultText').textContent = JSON.stringify(h.slice(-200), null, 2);
});
document.getElementById('clearHistory').addEventListener('click', ()=>{
  if(confirm('Hapus seluruh history lokal?')){ localStorage.removeItem(HIST_KEY); alert('History dihapus.'); }
});

/* ---------- toggle analyst / compact mode ---------- */
let analystMode = true;
document.getElementById('toggleModeBtn').addEventListener('click', ()=>{
  analystMode = !analystMode;
  document.getElementById('radarCanvas').parentElement.parentElement.style.display = analystMode ? 'block' : 'none';
  document.getElementById('trendCanvas').parentElement.parentElement.style.display = analystMode ? 'block' : 'none';
  document.getElementById('resultText').style.display = analystMode ? 'block' : 'none';
  document.getElementById('summary').style.display = 'block';
  document.getElementById('toggleModeBtn').textContent = analystMode ? 'Analyst Mode' : 'Compact Mode';
});

/* ---------- small tooltip bindings for explainers ---------- */
['h_gpg','h_gc','h_shots','h_sot','h_conv','h_poss','h_shotsC'].forEach(id=>{
  const el = document.getElementById(id);
  if(!el) return;
  el.addEventListener('mouseenter', (ev)=> showTooltip(el.getAttribute('title') || id + ' — masukkan nilai dari SofaScore jika tersedia', ev.pageX, ev.pageY));
  el.addEventListener('mousemove', (ev)=> showTooltip(el.getAttribute('title') || id + ' — masukkan nilai dari SofaScore jika tersedia', ev.pageX, ev.pageY));
  el.addEventListener('mouseleave', hideTooltip);
});

console.log('Part2 (Engine Core) loaded.');
</script>
<script>
/* ========================= Part 3 — Insight & Auto-Learning ========================= */

/* ---------- Auto-calibration ---------- */
function autoCalibrate(result){
  try{
    const hist = JSON.parse(localStorage.getItem('qpe_v20_history')||'[]');
    if(hist.length < 5) return;
    const last = hist.slice(-50);
    // rata-rata error antara lambda dan total gol nyata
    const errors = last.map(x => Math.abs((x.real_total_goals||0) - ((x.meta.lambdaH||0)+(x.meta.lambdaA||0))));
    const avgErr = errors.reduce((s,v)=>s+v,0)/errors.length || 0;
    const adj = clamp(1 - avgErr*0.05, 0.85, 1.15);
    localStorage.setItem('qpe_v20_auto_adj', adj);
    return adj;
  }catch(e){ console.warn('auto-calibrate fail',e); }
}

/* ---------- Apply auto-calibration before next run ---------- */
(function(){
  const adj = Number(localStorage.getItem('qpe_v20_auto_adj'));
  if(adj && adj !== 1){
    console.log('Auto-calibration active ×'+adj);
  }
})();

/* ---------- League-specific tuning ---------- */
function updateLeagueProfile(leagueName, lambdaBias){
  const profiles = JSON.parse(localStorage.getItem('qpe_v20_league')||'{}');
  profiles[leagueName] = { bias: lambdaBias, updated: Date.now() };
  localStorage.setItem('qpe_v20_league', JSON.stringify(profiles));
}
function getLeagueBias(leagueName){
  const profiles = JSON.parse(localStorage.getItem('qpe_v20_league')||'{}');
  const p = profiles[leagueName];
  if(!p) return 1;
  const ageDays = (Date.now() - p.updated)/86400000;
  return clamp(p.bias * (1 - ageDays*0.01), 0.8, 1.2);
}

/* ---------- Post-match input (real score) untuk pelatihan ---------- */
function inputRealScoreDialog(){
  const h = prompt('Masukkan jumlah gol tim Home nyata:','');
  const a = prompt('Masukkan jumlah gol tim Away nyata:','');
  if(h===null || a===null) return;
  const hist = JSON.parse(localStorage.getItem('qpe_v20_history')||'[]');
  if(!hist.length){ alert('Belum ada hasil untuk dicocokkan.'); return; }
  const last = hist[hist.length-1];
  last.real_home = Number(h); last.real_away = Number(a);
  last.real_total_goals = last.real_home + last.real_away;
  hist[hist.length-1] = last;
  localStorage.setItem('qpe_v20_history', JSON.stringify(hist));
  autoCalibrate(last);
  alert('Skor nyata tersimpan & kalibrasi otomatis diperbarui.');
}

/* ---------- Narasi ringkasan otomatis ---------- */
function generateSummaryText(res){
  const p = res.probabilities;
  const conf = res.meta.confidence;
  const high = Object.entries(p).sort((a,b)=>b[1]-a[1])[0][0];
  let narrative = '';
  if(high==='home') narrative = 'Tim kandang berpeluang lebih besar meraih kemenangan.';
  else if(high==='away') narrative = 'Tim tamu memiliki kans lebih besar menang.';
  else narrative = 'Kedua tim berimbang, hasil imbang cukup mungkin.';
  if(p.over>p.under) narrative += ' Potensi total gol tinggi (Over).';
  else narrative += ' Potensi pertandingan ketat (Under).';
  if(conf>0.7) narrative += ' Prediksi ini cukup meyakinkan.';
  else if(conf<0.4) narrative += ' Prediksi ini perlu kehati-hatian.';
  return narrative;
}

/* ---------- Shortcuts UI ---------- */
document.addEventListener('keydown', e=>{
  if(e.ctrlKey && e.key==='s'){ e.preventDefault(); inputRealScoreDialog(); }
  if(e.ctrlKey && e.key==='e'){ e.preventDefault(); exportHistoryCSV(); }
});

/* ---------- Tambahkan narasi ke summary setiap selesai analisis ---------- */
const _origAnalyze = document.getElementById('analyzeBtn').onclick || null;
document.getElementById('analyzeBtn').addEventListener('click', ()=>{
  setTimeout(()=>{
    if(window._qpe_last){
      const txt = generateSummaryText(window._qpe_last);
      document.getElementById('summary').innerHTML += `<div class="summary">${txt}</div>`;
    }
  },1200);
});

/* ---------- Tambah tombol input skor nyata ---------- */
const realBtn = document.createElement('button');
realBtn.textContent='Input Skor Nyata';
realBtn.onclick=inputRealScoreDialog;
document.querySelector('.card.row').appendChild(realBtn);

/* ---------- Akhir Part 3 ---------- */
console.log('Part3 (Insight & Auto-Learning) loaded.');
</script>
<script>
/* ========================= Part 4 — Final Polish & Closing ========================= */

/* ---------- Confidence bar animation ---------- */
function animateConfidence() {
  const el = document.getElementById('confMeter');
  if (!el) return;
  const c = window._qpe_last?.meta?.confidence || 0;
  const bar = document.createElement('div');
  bar.style.height = '6px';
  bar.style.borderRadius = '4px';
  bar.style.marginTop = '4px';
  bar.style.transition = 'width 1s ease';
  bar.style.background =
    c > 0.66
      ? 'linear-gradient(90deg,#10b981,#047857)'
      : c > 0.4
      ? 'linear-gradient(90deg,#fbbf24,#f59e0b)'
      : 'linear-gradient(90deg,#fb7185,#be123c)';
  bar.style.width = '0%';
  el.appendChild(bar);
  setTimeout(() => (bar.style.width = (c * 100).toFixed(1) + '%'), 50);
}
document.getElementById('analyzeBtn').addEventListener('click', () => {
  setTimeout(animateConfidence, 1500);
});

/* ---------- Legend di bawah grafik radar ---------- */
function createLegend() {
  const legend = document.createElement('div');
  legend.className = 'legend';
  legend.innerHTML = `
    <span style="color:#f97316">■ Home Attack</span>
    <span style="color:#3b82f6">■ Away Attack</span>
    <span style="color:#9aa3b2">— Defense scale</span>
  `;
  document
    .getElementById('radarCanvas')
    .parentElement.parentElement.appendChild(legend);
}
createLegend();

/* ---------- Highlight perubahan tren ---------- */
function highlightTrend() {
  const hist = JSON.parse(localStorage.getItem('qpe_v20_history') || '[]');
  if (hist.length < 2) return;
  const last = hist[hist.length - 1];
  const prev = hist[hist.length - 2];
  const diff =
    (last.meta.confidence || 0) - (prev.meta.confidence || 0);
  const el = document.getElementById('confMeter');
  const span = document.createElement('div');
  span.className = 'small';
  span.textContent =
    diff > 0
      ? `↑ Confidence naik ${(diff * 100).toFixed(1)}%`
      : `↓ Confidence turun ${Math.abs(diff * 100).toFixed(1)}%`;
  el.appendChild(span);
}
document.getElementById('analyzeBtn').addEventListener('click', () => {
  setTimeout(highlightTrend, 1600);
});

/* ---------- Transition animation ---------- */
function fadeInResult() {
  const res = document.getElementById('resultText');
  res.style.opacity = 0;
  res.style.transition = 'opacity 0.8s';
  setTimeout(() => (res.style.opacity = 1), 300);
}
document.getElementById('analyzeBtn').addEventListener('click', fadeInResult);

/* ---------- Cleanup Worker ---------- */
window.addEventListener('beforeunload', () => {
  if (workerInstance) {
    workerInstance.terminate();
    workerInstance = null;
  }
  if (workerUrl) URL.revokeObjectURL(workerUrl);
});

/* ---------- Version info ---------- */
console.log('%cQPE v20.1 Final Analyst Edition — All systems operational.','color:#0f0;');

/* ---------- Akhir Part 4 ---------- */
</script>
</body>
</html>
