<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Prediksi Global — v18.6 Full Engine Visual (Ready)</title>
  <style>
    :root{--bg:#071026;--card:#081428;--muted:#9aa3b2;--accent:#7dd3c8;color-scheme:dark}
    body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:#e6eef8;margin:12px}
    h1{font-size:18px;margin:6px 0}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:12px;border-radius:10px;margin-bottom:10px}
    .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    label{font-size:13px;color:var(--muted)}
    input[type=number], input[type=text], select{width:120px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
    button{background:var(--accent);border:0;padding:8px 12px;border-radius:8px;color:#04201a;cursor:pointer}
    pre{white-space:pre-wrap;background:#001122;padding:10px;border-radius:8px;color:#d6f8ee; max-height:380px; overflow:auto;}
    .muted{color:var(--muted);font-size:13px}
    .grid{display:grid;grid-template-columns:1fr 420px;gap:12px;align-items:start}
    canvas{background:transparent;border-radius:8px}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    .small{font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <h1>Prediksi Global — v18.6 Full Engine Visual (Analyst Mode)</h1>
  <div class="card">
    <div class="muted">Versi final: Engine penuh (v18.5) + Visual Insight + Legend. Offline-ready, dual-worker, history, CSV/JSON export, learning profile import/export. Pastikan browser mendukung Web Worker untuk performa terbaik.</div>
  </div>

  <!-- INPUTS -->
  <div class="card">
    <div class="row controls">
      <label>League GPG<input id="league_gpg" type="number" step="0.01" placeholder="2.6"></label>
      <label>Market OU<input id="market_ou" type="number" step="0.1" placeholder="2.5"></label>
      <label>MC Iter<input id="mc_select" type="number" value="100000" step="1000"></label>
      <label>Fast<input id="fastMC" type="checkbox"></label>
      <label>Match Type<select id="match_type"><option>Regular</option><option>Derby</option><option>Final</option><option>Friendly</option></select></label>
      <label>Competition<select id="comp_mode"><option>Liga</option><option>Cup</option><option>Playoff</option><option>Super Cup</option><option>Friendly</option></select></label>
      <button id="analyzeBtn">Analisis (v18.6)</button>
      <button id="toggleViewBtn">Visual Mode</button>
      <button id="downloadJsonBtn">Download JSON</button>
      <button id="exportCsvBtn">Export CSV</button>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <strong>INPUT DETAIL — HOME</strong>
      <div class="row" style="margin-top:8px">
        <label>GPG<input id="h_gpg" type="number" step="0.01" placeholder="gpg"></label>
        <label>Shots<input id="h_shots" type="number" step="0.1" placeholder="shots"></label>
        <label>SOT<input id="h_sot" type="number" step="0.1" placeholder="sot"></label>
        <label>Conv%<input id="h_conv" type="number" step="0.1" placeholder="conv%"></label>
        <label>Poss%<input id="h_poss" type="number" step="0.1" placeholder="poss%"></label>
      </div>
      <div class="row" style="margin-top:8px">
        <label>GoalsConceded<input id="h_gc" type="number" step="0.01" placeholder="gc"></label>
        <label>ShotsConceded<input id="h_shotsC" type="number" step="0.1" placeholder="shots conceded"></label>
        <label>CrossRate%<input id="h_cr" type="number" step="0.1" placeholder="cross%"></label>
        <label>OppELO<input id="h_oppelo" type="number" step="1" placeholder="opp elo"></label>
      </div>
      <div class="row" style="margin-top:8px">
        <label>FormG(5)<input id="h_formG" type="number" step="0.1" placeholder="goals last5"></label>
        <label>FormGA(5)<input id="h_formGA" type="number" step="0.1" placeholder="ga last5"></label>
        <label>W-D-L<input id="h_wdl" type="text" placeholder="3-1-1"></label>
        <label>Elo<input id="h_elo" type="number" step="1" placeholder="elo"></label>
        <label>PAF%<input id="h_paf" type="number" step="1" placeholder="player avail %"></label>
      </div>
    </div>

    <div class="card">
      <strong>INPUT DETAIL — AWAY</strong>
      <div class="row" style="margin-top:8px">
        <label>GPG<input id="a_gpg" type="number" step="0.01" placeholder="gpg"></label>
        <label>Shots<input id="a_shots" type="number" step="0.1" placeholder="shots"></label>
        <label>SOT<input id="a_sot" type="number" step="0.1" placeholder="sot"></label>
        <label>Conv%<input id="a_conv" type="number" step="0.1" placeholder="conv%"></label>
        <label>Poss%<input id="a_poss" type="number" step="0.1" placeholder="poss%"></label>
      </div>
      <div class="row" style="margin-top:8px">
        <label>GoalsConceded<input id="a_gc" type="number" step="0.01" placeholder="gc"></label>
        <label>ShotsConceded<input id="a_shotsC" type="number" step="0.1" placeholder="shots conceded"></label>
        <label>CrossRate%<input id="a_cr" type="number" step="0.1" placeholder="cross%"></label>
        <label>OppELO<input id="a_oppelo" type="number" step="1" placeholder="opp elo"></label>
      </div>
      <div class="row" style="margin-top:8px">
        <label>FormG(5)<input id="a_formG" type="number" step="0.1" placeholder="goals last5"></label>
        <label>FormGA(5)<input id="a_formGA" type="number" step="0.1" placeholder="ga last5"></label>
        <label>W-D-L<input id="a_wdl" type="text" placeholder="2-2-1"></label>
        <label>Elo<input id="a_elo" type="number" step="1" placeholder="elo"></label>
        <label>PAF%<input id="a_paf" type="number" step="1" placeholder="player avail %"></label>
      </div>
    </div>
  </div>

  <div class="card" style="margin-bottom:6px">
    <div class="row controls">
      <button id="auto_home">Hitung Statistik Home</button>
      <button id="auto_away">Hitung Statistik Away</button>
      <button id="neutralize_btn">Normalisasi & Kalibrasi</button>
      <button id="exportProfileBtn">Export Profile</button>
      <input id="importProfileInput" type="file" accept=".json">
      <button id="viewHistoryBtn">View History</button>
      <button id="clearHistoryBtn">Clear History</button>
    </div>
  </div>

  <div class="card">
    <strong>OUTPUT</strong>
    <pre id="out">Hasil akan tampil di sini.</pre>
  </div>

<script>
// ========= CORE SAFE UTILITIES =========
function getNum(id, fallback=null){const el=document.getElementById(id);if(!el)return fallback;const v=parseFloat(el.value);if(!Number.isFinite(v))return fallback;return v;}
function parseNumSafe(v,f=0){return Number.isFinite(v)?v:f;}
function clamp(v,min,max){if(!Number.isFinite(v))return min;if(v<min)return min;if(v>max)return max;return v;}
function round(v,d){if(!Number.isFinite(v))return v;return Math.round(v*Math.pow(10,d||3))/Math.pow(10,d||3);}

// ========= CORE CALCULATION FUNCTIONS =========
function computeDynamicWeights(inputs){const tempo=(parseNumSafe(inputs.shots,10)+parseNumSafe(inputs.poss,50)/2)/10;const stability=1-Math.abs((parseNumSafe(inputs.formG,0)-parseNumSafe(inputs.formGA,0))/10);const trust=computeTrust(inputs);return{shots:clamp(0.05+tempo*0.005,0.04,0.09),sot:clamp(0.04+trust*0.01,0.03,0.07),conv:clamp(0.03+stability*0.02,0.03,0.06),poss:clamp(0.02+tempo*0.002,0.015,0.04),cr:clamp(0.02+trust*0.005,0.015,0.04)};}
function computeXGplus(shots,sot,conv,poss,cr,leagueAvgXG,weights){shots=parseNumSafe(shots,0);sot=parseNumSafe(sot,0);conv=parseNumSafe(conv,0);poss=parseNumSafe(poss,50);cr=parseNumSafe(cr,25);weights=weights||{shots:0.065,sot:0.045,conv:0.035,poss:0.02,cr:0.025};const base=shots*weights.shots+sot*weights.sot+(conv/100)*shots*weights.conv+poss*weights.poss+cr*weights.cr;const blended=0.65*base+0.35*(leagueAvgXG||1.15);return clamp(blended,0.01,12);}
function computeXGA(opShots,opSOT,opConv,leagueAvgXG,weights){const baseOpp=computeXGplus(opShots,opSOT,opConv,50,25,leagueAvgXG,weights);return clamp(baseOpp,0.01,12);}
function computeDSIplus(gc,shotsC,oppElo,leagueAvgElo=1500){gc=parseNumSafe(gc,0);shotsC=parseNumSafe(shotsC,8);oppElo=parseNumSafe(oppElo,leagueAvgElo);const defensePressure=shotsC*0.03;const eloAdj=(oppElo/leagueAvgElo);const base=gc*0.4+defensePressure*0.6;return clamp(base*eloAdj,0.12,6);}
function computeMomentum(g,ga){g=parseNumSafe(g,0);ga=parseNumSafe(ga,0);return clamp(1+(g-ga)*0.05,0.5,1.5);}
function computeTrust(inputs){const total=Object.keys(inputs).length;const filled=Object.values(inputs).filter(v=>Number.isFinite(v)&&v!==null&&v!=='').length;return clamp(filled/total,0.3,1.0);}
function computeCEI(shots,gc){shots=parseNumSafe(shots,10);gc=parseNumSafe(gc,1);const entropy=Math.log((shots+gc+1));return clamp(1+(entropy-3)*0.05,0.8,1.3);}
function computeIdentity(shots,poss,conv,cr,gc){shots=parseNumSafe(shots,10);poss=parseNumSafe(poss,50);conv=parseNumSafe(conv,10);cr=parseNumSafe(cr,25);gc=parseNumSafe(gc,1);const attack=(shots*conv/100)+(cr/10);const control=poss/50;const risk=gc/Math.max(attack,1);const style=attack*0.5+control*0.3-risk*0.2;return clamp(style,0.7,1.35);}
function computeFVF(g,ga){g=parseNumSafe(g,0);ga=parseNumSafe(ga,0);const total=g+ga;const ratio=Math.abs(g-ga)/(total||1);return clamp(1-ratio*0.32,0.6,1.15);}
function calcFEI(gpg,estXG){gpg=parseNumSafe(gpg,0);estXG=parseNumSafe(estXG,0.8);if(estXG<=1e-4)return 1;const raw=gpg/estXG;return clamp(0.6*raw+0.4,0.45,1.8);}
function computeEloExpected(a,b){if(!Number.isFinite(a)||!Number.isFinite(b))return 0.5;return 1/(1+Math.pow(10,(b-a)/400));}
function computeEloDifferenceFactor(a,b){const diff=(parseNumSafe(a,1500)-parseNumSafe(b,1500))/400;return clamp(1+diff*0.35,0.6,1.4);}

// ========= PROBABILITY SUPPORT =========
function factorial(n){if(n<0)return 1;let r=1;for(let i=2;i<=n;i++)r*=i;return r;}
function poissonPMF(k,lambda){if(k<0)return 0;return Math.exp(-lambda)*Math.pow(lambda,k)/factorial(k);}
function samplePoisson(lambda){lambda=parseNumSafe(lambda,0);if(lambda<=0)return 0;if(lambda>80){const v=Math.round(lambda+Math.sqrt(lambda)*(Math.random()*2-1));return Math.max(0,v);}const L=Math.exp(-lambda);let k=0,p=1;do{k++;p*=Math.random();}while(p>L);return k-1;}
function skellamOutcomeProbs(lambdaH,lambdaA,maxrange=9){const probs={home:0,draw:0,away:0};for(let gh=0;gh<=maxrange;gh++){for(let ga=0;ga<=maxrange;ga++){const p=poissonPMF(gh,lambdaH)*poissonPMF(ga,lambdaA);if(gh>ga)probs.home+=p;else if(gh===ga)probs.draw+=p;else probs.away+=p;}}const s=probs.home+probs.draw+probs.away;if(s>0){probs.home/=s;probs.draw/=s;probs.away/=s;}return probs;}
function poissonOutcomeAnalytic(lambdaH,lambdaA,maxR=10){const probs={home:0,draw:0,away:0};for(let gh=0;gh<=maxR;gh++){for(let ga=0;ga<=maxR;ga++){const p=poissonPMF(gh,lambdaH)*poissonPMF(ga,lambdaA);if(gh>ga)probs.home+=p;else if(gh===ga)probs.draw+=p;else probs.away+=p;}}const s=probs.home+probs.draw+probs.away;if(s>0){probs.home/=s;probs.draw/=s;probs.away/=s;}return probs;}
function ensembleMerge(p1,p2,p3){const out={};for(const k in p1)out[k]=(p1[k]||0)*0.5+(p2[k]||0)*0.3+(p3[k]||0)*0.2;return out;}
function bayesianBlend(pMC,pSkel,wt=0.65){const out={};for(const k in pMC)out[k]=(pMC[k]||0)*wt+(pSkel[k]||0)*(1-wt);return out;}

// ========= TRAP & CONFIDENCE =========
function computeAdvancedTrapOdds(hdpOpen,hdpNow,oddsHome,oddsAway){hdpOpen=Number.isFinite(hdpOpen)?hdpOpen:0;hdpNow=Number.isFinite(hdpNow)?hdpNow:0;oddsHome=Number.isFinite(oddsHome)?oddsHome:2.0;oddsAway=Number.isFinite(oddsAway)?oddsAway:2.0;const lineShift=hdpNow-hdpOpen;const oddsDiff=Math.abs(oddsHome-oddsAway);const trapDivergence=(lineShift<0&&oddsHome<oddsAway)?1.08:1.0;const symmetry=1-Math.min(oddsDiff/0.6,1)*0.4;const linePressure=1-Math.min(Math.abs(lineShift)/0.5,1)*0.2;return round(clamp(symmetry*linePressure*trapDivergence,0.75,1.25),3);}
function computeConfidence(prob){const p=prob;const maxP=Math.max(p.home||0,p.draw||0,p.away||0);const entropy=-((p.home||0)*Math.log((p.home||0)+1e-9)+(p.draw||0)*Math.log((p.draw||0)+1e-9)+(p.away||0)*Math.log((p.away||0)+1e-9));const normEnt=entropy/Math.log(3);return clamp((maxP-1/3)*(1-normEnt)*2,0,1);}
function computeQuantumConfidence(scores){const vals=Object.values(scores||{});if(vals.length===0)return 0;const mean=vals.reduce((a,b)=>a+b,0)/vals.length;const variance=vals.reduce((a,b)=>a+(b-mean)**2,0)/vals.length;const spread=Math.sqrt(variance);return clamp(1-spread*4,0,1);}

// ========= AUTO-LEARNING PROFILE =========
const PROFILE_KEY='qpe_learning_profile_v18';
function loadLearningProfile(){try{return JSON.parse(localStorage.getItem(PROFILE_KEY))||{version:1,weights:{confidence:1,feedback:1}};}catch(e){return{version:1,weights:{confidence:1,feedback:1}};}}
function saveLearningProfile(prof){try{localStorage.setItem(PROFILE_KEY,JSON.stringify(prof));return true;}catch(e){return false;}}
function exportLearningProfile(){const prof=loadLearningProfile();const blob=new Blob([JSON.stringify(prof,null,2)],{type:'application/json'});const url=URL.createObjectURL(blob);const a=document.createElement('a');a.href=url;a.download='qpe_learning_profile_v18.json';document.body.appendChild(a);a.click();a.remove();URL.revokeObjectURL(url);}
function importLearningProfile(file){const r=new FileReader();r.onload=function(){try{const obj=JSON.parse(r.result);saveLearningProfile(obj);alert('Profile diimport berhasil');}catch(e){alert('File invalid');}};r.readAsText(file);}
function autoLearnFromHistory(){try{const hist=JSON.parse(localStorage.getItem('qpe_history_v18'))||[];if(hist.length===0)return;let sumError=0,count=0;hist.forEach(h=>{if(h.real&&h.probabilities){const err=Math.abs((h.real.home||0)-(h.probabilities.home||0));sumError+=err;count++;}});const avgErr=count?sumError/count:0.1;const prof=loadLearningProfile();prof.weights.confidence=clamp(1-avgErr*1.1,0.6,1.05);prof.weights.feedback=clamp(1-avgErr*0.8,0.7,1.12);saveLearningProfile(prof);}catch(e){console.warn('autolearn failed',e);}}
// ========= DUAL WORKER SETUP =========
const workerTemplate=`self.onmessage=function(e){const d=e.data;function parseNumSafe(v,f=0){return(typeof v==='number'&&isFinite(v))?v:f;}function samplePoisson(lambda){lambda=parseNumSafe(lambda,0);if(lambda<=0)return 0;if(lambda>80){const v=Math.round(lambda+Math.sqrt(lambda)*(Math.random()*2-1));return Math.max(0,v);}const L=Math.exp(-lambda);let k=0,p=1;do{k++;p*=Math.random();}while(p>L);return k-1;}const counts={home:0,draw:0,away:0,over:0,under:0,scores:{}};for(let t=0;t<d.mcIters;t++){const gh=samplePoisson(d.lambdaH);const ga=samplePoisson(d.lambdaA);if(gh>ga)counts.home++;else if(gh===ga)counts.draw++;else counts.away++;if(gh+ga>d.ouLine)counts.over++;else counts.under++;const k=gh+'-'+ga;counts.scores[k]=(counts.scores[k]||0)+1;}['home','draw','away','over','under'].forEach(k=>counts[k]=counts[k]/d.mcIters);for(const k in counts.scores)counts.scores[k]=counts.scores[k]/d.mcIters;self.postMessage({counts:counts});};`;
const blobA=new Blob([workerTemplate],{type:'application/javascript'});
const blobB=new Blob([workerTemplate],{type:'application/javascript'});
const workerUrlA=URL.createObjectURL(blobA);
const workerUrlB=URL.createObjectURL(blobB);
let workerA=null,workerB=null;
try{workerA=new Worker(workerUrlA);workerB=new Worker(workerUrlB);}catch(e){console.warn('Worker init failed',e);workerA=null;workerB=null;}

// ========= ANALYSIS MAIN ROUTINE =========
document.getElementById('analyzeBtn').addEventListener('click',async()=>{
  try{
    autoLearnFromHistory();
    const profile=loadLearningProfile();

    const leagueAvgXG=Math.max(0.3,parseNumSafe(getNum('league_gpg'),2.6)/2);
    const marketOU=parseNumSafe(getNum('market_ou'),2.5);
    const mcTotal=parseInt(document.getElementById('mc_select').value,10)||100000;
    const matchType=document.getElementById('match_type').value||'Regular';
    const compMode=document.getElementById('comp_mode').value||'Liga';

    const h={gpg:getNum('h_gpg',null),shots:getNum('h_shots',null),sot:getNum('h_sot',null),conv:getNum('h_conv',null),poss:getNum('h_poss',null),gc:getNum('h_gc',null),formG:getNum('h_formG',null),formGA:getNum('h_formGA',null),wdl:document.getElementById('h_wdl').value,elo:getNum('h_elo',null),paf:getNum('h_paf',100)};
    const a={gpg:getNum('a_gpg',null),shots:getNum('a_shots',null),sot:getNum('a_sot',null),conv:getNum('a_conv',null),poss:getNum('a_poss',null),gc:getNum('a_gc',null),formG:getNum('a_formG',null),formGA:getNum('a_formGA',null),wdl:document.getElementById('a_wdl').value,elo:getNum('a_elo',null),paf:getNum('a_paf',100)};

    const weightsH=computeDynamicWeights(h);const weightsA=computeDynamicWeights(a);
    const h_xg=computeXGplus(h.shots,h.sot,h.conv,h.poss,h.conv,leagueAvgXG,weightsH);
    const a_xg=computeXGplus(a.shots,a.sot,a.conv,a.poss,a.conv,leagueAvgXG,weightsA);
    const h_xga=computeXGA(a.shots,a.sot,a.conv,leagueAvgXG,weightsA);
    const a_xga=computeXGA(h.shots,h.sot,h.conv,leagueAvgXG,weightsH);
    const h_dsi=computeDSIplus(h.gc,getNum('h_shotsC'),getNum('h_oppelo'));
    const a_dsi=computeDSIplus(a.gc,getNum('a_shotsC'),getNum('a_oppelo'));

    const h_mom=computeMomentum(h.formG,h.formGA);
    const a_mom=computeMomentum(a.formG,a.formGA);
    const h_ident=computeIdentity(h.shots,h.poss,h.conv,getNum('h_cr'),h.gc);
    const a_ident=computeIdentity(a.shots,a.poss,a.conv,getNum('a_cr'),a.gc);
    const h_fvf=computeFVF(h.formG,h.formGA);
    const a_fvf=computeFVF(a.formG,a.formGA);
    const h_cei=computeCEI(h.shots,h.gc);
    const a_cei=computeCEI(a.shots,a.gc);
    const h_paf=clamp(parseNumSafe(h.paf,100)/100,0.5,1.0);
    const a_paf=clamp(parseNumSafe(a.paf,100)/100,0.5,1.0);

    const h_fei=calcFEI(h.gpg,h_xg)*h_mom*h_fvf*h_paf;
    const a_fei=calcFEI(a.gpg,a_xg)*a_mom*a_fvf*a_paf;
    const eloFactorHome=computeEloDifferenceFactor(h.elo||getNum('h_oppelo'),a.elo||getNum('a_oppelo'));
    const eloFactorAway=computeEloDifferenceFactor(a.elo||getNum('a_oppelo'),h.elo||getNum('h_oppelo'));

    let lambdaH=clamp((h_xg*(h_fei/(a_dsi||1))*h_ident*h_cei*eloFactorHome)*(1+h_xga*0.05),0.01,14);
    let lambdaA=clamp((a_xg*(a_fei/(h_dsi||1))*a_ident*a_cei*eloFactorAway)*(1+a_xga*0.05),0.01,14);

    // ===== COMPETITION MODE =====
    const compMap={"Liga":{focus:1,rotation:1,knockout:1},"Cup":{focus:1.08,rotation:0.93,knockout:1.12},"Playoff":{focus:1.16,rotation:0.95,knockout:1.18},"Super Cup":{focus:1.05,rotation:0.9,knockout:1.08},"Friendly":{focus:0.85,rotation:1.2,knockout:0.9}};
    const comp=compMap[compMode]||compMap["Liga"];
    lambdaH*=comp.focus/comp.rotation;lambdaA*=comp.focus/comp.rotation;
    const compAdj=clamp(((lambdaH+lambdaA)/2)*comp.knockout,0.8,1.35);
    lambdaH*=compAdj;lambdaA*=compAdj;
    const chaosMap={Regular:1,Derby:1.08,Final:0.96,Friendly:0.94};
    const chaos=chaosMap[matchType]||1;
    lambdaH*=chaos;lambdaA*=chaos;

    const mcTotalClamped=Math.max(1000,Math.min(500000,parseInt(mcTotal,10)||100000));
    const partA=Math.floor(mcTotalClamped/2);
    const partB=mcTotalClamped-partA;
    document.getElementById('out').textContent='Running dual workers... ('+mcTotalClamped+' iters)';
    const payloadA={lambdaH:lambdaH,lambdaA:lambdaA,mcIters:partA,ouLine:marketOU};
    const payloadB={lambdaH:lambdaA,lambdaA:lambdaH,mcIters:partB,ouLine:marketOU};

    const runWorkerOnce=(worker,payload)=>new Promise((res)=>{
      if(worker){const hnd=(ev)=>{worker.removeEventListener('message',hnd);res(ev.data.counts);};worker.addEventListener('message',hnd);worker.postMessage(payload);}
      else{setTimeout(()=>{const counts={home:0,draw:0,away:0,over:0,under:0,scores:{}};for(let t=0;t<payload.mcIters;t++){const gh=samplePoisson(payload.lambdaH);const ga=samplePoisson(payload.lambdaA);if(gh>ga)counts.home++;else if(gh===ga)counts.draw++;else counts.away++;if(gh+ga>payload.ouLine)counts.over++;else counts.under++;const k=gh+'-'+ga;counts.scores[k]=(counts.scores[k]||0)+1;}['home','draw','away','over','under'].forEach(k=>counts[k]=counts[k]/payload.mcIters);for(const k in counts.scores)counts.scores[k]=counts.scores[k]/payload.mcIters;res(counts);},10);}
    });

    const [outA,outB]=await Promise.all([runWorkerOnce(workerA,payloadA),runWorkerOnce(workerB,payloadB)]);
    const neutral={home:(outA.home+outB.away)/2,draw:(outA.draw+outB.draw)/2,away:(outA.away+outB.home)/2,over:(outA.over+outB.over)/2,under:(outA.under+outB.under)/2};

    const skel=skellamOutcomeProbs(lambdaH,lambdaA,9);
    const analytic=poissonOutcomeAnalytic(lambdaH,lambdaA);
    const merged=ensembleMerge(neutral,skel,analytic);
    const blended=bayesianBlend(merged,skel,0.65);
// trap index and confidences
    const trapIndex = computeAdvancedTrapOdds(getNum('odds_hdp_open'), getNum('odds_hdp_now'), getNum('odds_home'), getNum('odds_away'));
    const trust = computeTrust(h) * computeTrust(a);
    let confidence = computeConfidence(blended) * trust;

    // apply trap & profile feedback
    confidence *= clamp(trapIndex, 0.8, 1.12);
    const quantum_conf = computeQuantumConfidence(outA.scores);
    const prof = loadLearningProfile();
    const feedbackAdj = clamp(prof.weights.feedback, 0.7, 1.12);
    confidence *= feedbackAdj;

    // elo influence on confidence
    const eloExpect = computeEloExpected(h.elo||getNum('h_oppelo'), a.elo||getNum('a_oppelo'));
    const eloBalance = Math.abs(eloExpect - 0.5);
    const eloBoost = 1 - eloBalance * 0.28;
    confidence *= eloBoost;

    const kFactor = selfCalibrate(lambdaH, lambdaA, blended);

    // combined scorelines average
    const combinedScores = {};
    for(const k in outA.scores) combinedScores[k] = ((outA.scores[k]||0) + (outB.scores[k]||0))/2;
    const scoreEntries = Object.entries(combinedScores).map(([k,v])=>[k,v]).sort((a,b)=>b[1]-a[1]).slice(0,12).map(s=>({score:s[0],prob:round(s[1],4)}));

    const sumP = blended.home + blended.draw + blended.away;
    const norm = sumP > 0 ? sumP : 1;
    const finalProbs = { home: blended.home/norm, draw: blended.draw/norm, away: blended.away/norm, over: blended.over, under: blended.under };

    const final = {
      meta: { mcTotal: mcTotalClamped, parts:[partA, partB], kFactor: round(kFactor,4), trust: round(trust,3), confidence: round(clamp(confidence,0,1),3), quantum_conf: round(quantum_conf,3), feedbackWeight: prof.weights.feedback },
      inputs: { home: h, away: a, leagueAvg: { gpg: leagueAvgXG*2 }, compMode: compMode, matchType: matchType },
      core: { h_xg: round(h_xg,4), a_xg: round(a_xg,4), h_xga: round(h_xga,4), a_xga: round(a_xga,4), h_dsi: round(h_dsi,4), a_dsi: round(a_dsi,4), h_fei: round(h_fei,4), a_fei: round(a_fei,4), lambdaH: round(lambdaH,4), lambdaA: round(lambdaA,4), eloExpect: round(eloExpect,3) },
      probabilities: finalProbs,
      topScorelines: scoreEntries,
      market: { trapIndex: trapIndex }
    };

    // save to history (localStorage)
    try{
      const hist = JSON.parse(localStorage.getItem('qpe_history_v18')) || [];
      hist.push({ time: new Date().toISOString(), input: final.inputs, core: final.core, probabilities: final.probabilities, meta: final.meta, market: final.market });
      localStorage.setItem('qpe_history_v18', JSON.stringify(hist));
    }catch(e){ console.warn('save history failed', e); }

    // update learning profile (auto-learn)
    autoLearnFromHistory();

    // attach last result for UI and downloads
    window._lastResult = final;
    document.getElementById('out').textContent = JSON.stringify(final, null, 2);

    // trigger visuals if visual code loaded
    if(typeof updateAllVisuals === 'function') try{ updateAllVisuals(); }catch(e){}

  }catch(err){
    document.getElementById('out').textContent = 'ERROR — ' + String(err);
    console.error(err);
  }
});

// ========== SMALL HELPERS & UI BUTTONS ==========

// auto calc home/away quick buttons
document.getElementById('auto_home').addEventListener('click', ()=>{
  const leagueAvgXG = Math.max(0.3, parseNumSafe(getNum('league_gpg'),2.6)/2);
  const weightsH = computeDynamicWeights({shots:getNum('h_shots'), poss:getNum('h_poss'), formG:getNum('h_formG'), formGA:getNum('h_formGA')});
  const xg = computeXGplus(getNum('h_shots'), getNum('h_sot'), getNum('h_conv'), getNum('h_poss'), getNum('h_cr'), leagueAvgXG, weightsH);
  const dsi = computeDSIplus(getNum('h_gc'), getNum('h_shotsC'), getNum('h_oppelo'));
  const mom = computeMomentum(getNum('h_formG'), getNum('h_formGA')) * parseNumSafe(parseWDL(document.getElementById('h_wdl').value),1);
  const fei = calcFEI(getNum('h_gpg'), xg) * mom;
  document.getElementById('out').textContent = `Home auto -> xG:${round(xg,4)} DSI:${round(dsi,4)} MOM:${round(mom,4)} FEI:${round(fei,4)}`;
});

document.getElementById('auto_away').addEventListener('click', ()=>{
  const leagueAvgXG = Math.max(0.3, parseNumSafe(getNum('league_gpg'),2.6)/2);
  const weightsA = computeDynamicWeights({shots:getNum('a_shots'), poss:getNum('a_poss'), formG:getNum('a_formG'), formGA:getNum('a_formGA')});
  const xg = computeXGplus(getNum('a_shots'), getNum('a_sot'), getNum('a_conv'), getNum('a_poss'), getNum('a_cr'), leagueAvgXG, weightsA);
  const dsi = computeDSIplus(getNum('a_gc'), getNum('a_shotsC'), getNum('a_oppelo'));
  const mom = computeMomentum(getNum('a_formG'), getNum('a_formGA')) * parseNumSafe(parseWDL(document.getElementById('a_wdl').value),1);
  const fei = calcFEI(getNum('a_gpg'), xg) * mom;
  document.getElementById('out').textContent = `Away auto -> xG:${round(xg,4)} DSI:${round(dsi,4)} MOM:${round(mom,4)} FEI:${round(fei,4)}`;
});

// parse W-D-L helper
function parseWDL(str){
  try{
    if(!str) return 1;
    const parts = str.split('-').map(s=>parseInt(s,10)||0);
    if(parts.length!==3) return 1;
    return computePSM(parts[0], parts[1], parts[2]);
  }catch(e){ return 1; }
}

// ========== History & Export Buttons ==========
document.getElementById('viewHistoryBtn').addEventListener('click', ()=>{
  const hist = JSON.parse(localStorage.getItem('qpe_history_v18')) || [];
  document.getElementById('out').textContent = JSON.stringify(hist.slice(-100), null, 2);
});

document.getElementById('clearHistoryBtn').addEventListener('click', ()=>{
  if(confirm('Hapus seluruh history QPE?')){
    localStorage.removeItem('qpe_history_v18');
    document.getElementById('out').textContent = 'History cleared';
  }
});
// ========== EXPORT / IMPORT HANDLERS ==========

// Download last result as JSON
document.getElementById('downloadJsonBtn').addEventListener('click', ()=>{
  const res = window._lastResult;
  if(!res){ alert('Tidak ada hasil. Jalankan Analisis terlebih dahulu.'); return; }
  const blob = new Blob([JSON.stringify(res,null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url;
  a.download = 'qpe_result_v18.6_' + (new Date()).toISOString().replace(/[:]/g,'-') + '.json';
  document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
});

// Export history as CSV
document.getElementById('exportCsvBtn').addEventListener('click', ()=>{
  const hist = JSON.parse(localStorage.getItem('qpe_history_v18')) || [];
  if(hist.length===0){ alert('History kosong'); return; }
  const rows = [['time','lambdaH','lambdaA','prob_home','prob_draw','prob_away','confidence','trapIndex']];
  hist.forEach(r=>{
    rows.push([ r.time, r.core.lambdaH, r.core.lambdaA, r.probabilities.home, r.probabilities.draw, r.probabilities.away, r.meta.confidence, (r.market?r.market.trapIndex:'') ]);
  });
  const csv = rows.map(r=> r.map(c=> typeof c==='string' ? ('"'+c.replace(/"/g,'""')+'"') : c ).join(',')).join('\n');
  const blob = new Blob([csv], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'qpe_history_v18.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
});

// Export learning profile button
document.getElementById('exportProfileBtn').addEventListener('click', ()=>{
  try{ exportLearningProfile(); }catch(e){ alert('Export profile gagal: '+e); }
});

// Import profile input
document.getElementById('importProfileInput').addEventListener('change', (e)=>{
  if(e.target.files && e.target.files[0]) importLearningProfile(e.target.files[0]);
});

// ========== VISUAL RENDERING (bar / pie / gauge) ==========

// Colors (dark elegant)
const V_COLORS = { home:'#7dd3c8', draw:'#60a5fa', away:'#fb7185', over:'#f59e0b', under:'#94a3b8', gaugeOk:'#10b981', gaugeWarn:'#f59e0b', gaugeBad:'#f43f5e' };

function drawBar(canvas, probs, confidence){
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='rgba(255,255,255,0.02)'; ctx.fillRect(0,0,canvas.width,canvas.height);
  const labels=['Home','Draw','Away']; const vals=[probs.home||0, probs.draw||0, probs.away||0];
  const max = Math.max(...vals, 0.0001);
  const pad = 28; const w = (canvas.width - pad*2)/vals.length - 18;
  ctx.fillStyle='#cdeff2'; ctx.font='13px Inter, Arial'; ctx.fillText('Probability (H / D / A)', pad, 18);
  vals.forEach((v,i)=>{
    const x = pad + i*(w+18);
    const h = (canvas.height - 80) * (v/max);
    const y = canvas.height - 36 - h;
    const color = i===0? V_COLORS.home : i===1? V_COLORS.draw : V_COLORS.away;
    ctx.fillStyle = 'rgba(255,255,255,0.03)'; ctx.fillRect(x, canvas.height-36 - (canvas.height-120), w, canvas.height-70);
    ctx.fillStyle = color; ctx.globalAlpha = Math.max(0.45, 0.5 + (confidence||0)*0.8); ctx.fillRect(x, y, w, h); ctx.globalAlpha=1;
    ctx.fillStyle='#e6eef8'; ctx.font='12px Inter, Arial'; ctx.fillText(((v||0)*100).toFixed(1)+'%', x, y-8);
    ctx.fillStyle='#9aa3b2'; ctx.font='12px Inter, Arial'; ctx.fillText(labels[i], x, canvas.height-14);
  });
  ctx.fillStyle='#9aa3b2'; ctx.font='12px Inter, Arial'; ctx.fillText('Confidence: '+((confidence||0)*100).toFixed(1)+'%', canvas.width-160, 18);
}

function drawPie(canvas, overProb){
  const ctx = canvas.getContext('2d'); ctx.clearRect(0,0,canvas.width,canvas.height);
  const cx = canvas.width/2, cy = canvas.height/2, r = Math.min(cx,cy)-6;
  const a1 = -Math.PI/2; const a2 = a1 + (overProb||0)*2*Math.PI;
  ctx.fillStyle='rgba(255,255,255,0.02)'; ctx.beginPath(); ctx.arc(cx,cy,r,0,2*Math.PI); ctx.fill();
  ctx.beginPath(); ctx.moveTo(cx,cy); ctx.fillStyle=V_COLORS.over; ctx.arc(cx,cy,r,a1,a2); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(cx,cy); ctx.fillStyle=V_COLORS.under; ctx.arc(cx,cy,r,a2,a1+2*Math.PI); ctx.closePath(); ctx.fill();
  ctx.fillStyle='#e6eef8'; ctx.font='12px Inter, Arial'; ctx.fillText('Over', 12, 18); ctx.fillText(((overProb||0)*100).toFixed(1)+'%', 12, 36);
  ctx.fillText('Under', 12, canvas.height-12); ctx.fillText(((1-(overProb||0))*100).toFixed(1)+'%', 12, canvas.height-30);
}

function drawGauge(canvas, confidence){
  const ctx = canvas.getContext('2d'); ctx.clearRect(0,0,canvas.width,canvas.height);
  const cx = canvas.width/2, cy = canvas.height*0.9, r = Math.min(cx,cy)-10;
  ctx.beginPath(); ctx.lineWidth=12; ctx.strokeStyle='rgba(255,255,255,0.04)'; ctx.arc(cx,cy,r,Math.PI,2*Math.PI); ctx.stroke();
  const t = Math.max(0, Math.min(1, confidence||0)); const end = Math.PI + t*Math.PI;
  const color = t>0.66? V_COLORS.gaugeOk : t>0.4? V_COLORS.gaugeWarn : V_COLORS.gaugeBad;
  ctx.beginPath(); ctx.lineWidth=12; ctx.strokeStyle=color; ctx.lineCap='round'; ctx.arc(cx,cy,r,Math.PI,end); ctx.stroke();
  const angle = Math.PI + t*Math.PI; const nx = cx + Math.cos(angle)*(r-8); const ny = cy + Math.sin(angle)*(r-8);
  ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(nx,ny); ctx.lineWidth=3; ctx.strokeStyle='#e6eef8'; ctx.stroke();
  ctx.beginPath(); ctx.fillStyle='#e6eef8'; ctx.arc(cx,cy,4,0,2*Math.PI); ctx.fill();
  ctx.fillStyle='#e6eef8'; ctx.font='12px Inter, Arial'; ctx.fillText('Confidence', 12, 16); ctx.fillStyle='#9aa3b2'; ctx.fillText((t*100).toFixed(1)+'%', 12, 34);
}

// Hook that updates visual panel and legend details (if present)
function updateAllVisuals(){
  const res = window._lastResult;
  const bar = document.getElementById('v_bar') || document.getElementById('barCanvas');
  const pie = document.getElementById('v_pie') || document.getElementById('pieCanvas');
  const gauge = document.getElementById('v_gauge') || document.getElementById('gaugeCanvas');
  const scoresPre = document.getElementById('v_scores') || document.getElementById('v_scores');
  const detailsPre = document.getElementById('v_details') || document.getElementById('v_details');
  if(!res){
    if(bar) bar.getContext('2d').clearRect(0,0,bar.width,bar.height);
    if(pie) pie.getContext('2d').clearRect(0,0,pie.width,pie.height);
    if(gauge) gauge.getContext('2d').clearRect(0,0,gauge.width,gauge.height);
    if(scoresPre) scoresPre.textContent='-';
    if(detailsPre) detailsPre.textContent='No result yet.';
    return;
  }
  const probs = res.probabilities || {home:0,draw:0,away:0,over:0,under:0};
  if(bar) drawBar(bar, probs, res.meta.confidence || 0);
  if(pie) drawPie(pie, probs.over || 0);
  if(gauge) drawGauge(gauge, res.meta.confidence || 0);
  if(scoresPre){
    const s = (res.topScorelines||[]).map(x=> `${x.score} : ${ (x.prob*100).toFixed(2) }%`).join('\n');
    scoresPre.textContent = s || '-';
  }
  if(detailsPre){
    const det = {
      lambdaH: res.core && res.core.lambdaH,
      lambdaA: res.core && res.core.lambdaA,
      h_xg: res.core && res.core.h_xg,
      a_xg: res.core && res.core.a_xg,
      h_xga: res.core && res.core.h_xga,
      a_xga: res.core && res.core.a_xga,
      h_dsi: res.core && res.core.h_dsi,
      a_dsi: res.core && res.core.a_dsi,
      h_fei: res.core && res.core.h_fei,
      a_fei: res.core && res.core.a_fei,
      eloExpect: res.core && res.core.eloExpect
    };
    detailsPre.textContent = JSON.stringify(det, null, 2);
  }
}

// Initialize visual elements if page loaded visuals
setTimeout(()=>{ try{ updateAllVisuals(); }catch(e){} }, 200);

// ========== LEGEND (small) update (if legend exists) ==========
function ensureLegend(){
  const lg = document.getElementById('legendBlock');
  if(!lg) return;
  // legend block already static in HTML; we can add dynamic notes if needed
  // For now, no dynamic updates required.
}
ensureLegend();
<!-- ===== VISUAL PANEL (Analyst Mode) ===== -->
  <div class="card" id="visualPanel" style="margin-top:12px">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <strong>Visual Insight (Analyst Mode)</strong>
      <div class="small muted">Bar (H/D/A), Pie (Over/Under), Gauge (Confidence), Top scorelines, Detailed Analytics</div>
    </div>
    <div style="display:flex;gap:12px;margin-top:8px;align-items:flex-start">
      <div style="flex:1">
        <canvas id="v_bar" width="640" height="220" style="width:100%;height:220px;border-radius:8px;background:transparent"></canvas>
        <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
          <canvas id="v_pie" width="160" height="160"></canvas>
          <canvas id="v_gauge" width="240" height="160"></canvas>
          <div style="flex:1;padding-left:6px">
            <div class="small muted">Top Scorelines</div>
            <pre id="v_scores" style="background:#001122;padding:8px;border-radius:6px;color:#d6f8ee;max-height:120px;overflow:auto;margin-top:6px">-</pre>
          </div>
        </div>
      </div>
      <div style="width:320px">
        <div class="small muted">Detailed Analytics</div>
        <pre id="v_details" style="background:#001122;padding:10px;border-radius:8px;color:#d6f8ee;max-height:360px;overflow:auto;margin-top:8px">No result yet.</pre>
      </div>
    </div>
  </div>

  <!-- ===== LEGEND ===== -->
  <div class="card" id="legendBlock" style="margin-top:12px">
    <strong>Legend & Penjelasan Singkat</strong>
    <div style="margin-top:8px; color:#cfeef6; font-size:13px;">
      <div style="display:flex;gap:12px;flex-wrap:wrap;margin-top:6px">
        <div style="min-width:220px">
          <div style="font-weight:600;color:#7dd3c8">Probability Bars (H / D / A)</div>
          <div class="muted">Menunjukkan probabilitas Home win, Draw, dan Away win berdasarkan simulasi. Nilai ditampilkan dalam persen.</div>
        </div>
        <div style="min-width:220px">
          <div style="font-weight:600;color:#f59e0b">Over / Under (Pie)</div>
          <div class="muted">Menunjukkan probabilitas total gol melewati garis O/U market (Over) vs tidak (Under).</div>
        </div>
        <div style="min-width:220px">
          <div style="font-weight:600;color:#10b981">Confidence Gauge</div>
          <div class="muted">Meter keyakinan model (0–100%). Dipengaruhi oleh entropi distribusi, trap odds, dan learning profile.</div>
        </div>
      </div>

      <div style="margin-top:10px; display:flex;gap:12px; flex-wrap:wrap">
        <div style="min-width:320px">
          <div style="font-weight:600;color:#cdeff2">Detailed Analytics (kolom kanan)</div>
          <div class="muted">
            <ul style="margin:6px 0 0 18px; padding:0; color:#9aa3b2">
              <li><strong>λ (lambda)</strong>: expected goals per team (rata-rata gol yang diprediksi oleh model).</li>
              <li><strong>xG</strong>: expected goals estimate berdasarkan shots / SOT / conv / poss / cross rate.</li>
              <li><strong>FEI</strong>: finishing efficiency index — efektivitas konversi peluang menjadi gol.</li>
              <li><strong>DSI</strong>: defensive stability index — estimasi kemampuan bertahan lawan.</li>
              <li><strong>TrapIndex</strong>: indeks deteksi jebakan odds (nilai &lt;0.9 = potensi trap kuat).</li>
              <li><strong>EloExpect</strong>: probabilitas menang menurut perbandingan Elo.</li>
            </ul>
          </div>
        </div>

        <div style="min-width:320px">
          <div style="font-weight:600;color:#cdeff2">Interaksi Visual</div>
          <div class="muted">
            Klik <em>Analisis</em> untuk memperbarui grafik. Gunakan <em>Download JSON</em> untuk menyimpan hasil, atau <em>Export CSV</em> untuk mengunduh seluruh history. Gunakan Export/Import Profile untuk memindahkan learning profile antar perangkat.
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
// ===== remaining helpers =====

// selfCalibrate: simple QPE internal calibrator (keeps kFactor memory small)
let qpeCalib = [];
function selfCalibrate(lambdaH, lambdaA, result){
  try{
    const balance = Math.abs((result.home||0) - (result.away||0));
    const stability = 1 - Math.abs((result.home||0) + (result.draw||0) + (result.away||0) - 1);
    const newK = clamp(1 + (0.5 - balance) * 0.07, 0.95, 1.06) * stability;
    qpeCalib.push({lambdaH, lambdaA, k:newK, time:Date.now()});
    if(qpeCalib.length>200) qpeCalib.shift();
    return newK;
  }catch(e){ return 1; }
}

// parseWDL defined earlier in Part 4

// Toggle View (Visual/Data)
let visualMode = true;
document.getElementById('toggleViewBtn').addEventListener('click', ()=>{
  visualMode = !visualMode;
  document.getElementById('toggleViewBtn').textContent = visualMode? 'Visual Mode' : 'Data Mode';
  // show/hide panels
  const visual = document.getElementById('visualPanel');
  const out = document.getElementById('out');
  if(visual) visual.style.display = visualMode? 'block' : 'none';
  if(out) out.style.display = visualMode? 'none' : 'block';
});

// initialization: ensure learning profile exists
if(!localStorage.getItem(PROFILE_KEY)) saveLearningProfile({version:1,weights:{confidence:1,feedback:1}});

// safety log (no errors)
console.log('QPE v18.6 ready — engine + visuals initialized.');

// final: keep UI responsive if workers not supported
window.addEventListener('unload', ()=>{
  try{ if(workerA) workerA.terminate(); if(workerB) workerB.terminate(); }catch(e){}
});
</script>

</body>
</html>
