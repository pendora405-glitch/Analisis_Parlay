<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Prediksi Global v20.3.3 — FINAL (Zero Bias + Parkir Bus Pro + Elite Penajam)</title>
<style>
:root{
  --bg:#061026; --card:#0b1a2a; --muted:#9aa3b2; --accent:#06b6d4;
  --attack:#f97316; --defense:#3b82f6; --strong:#10b981; --weak:#8b5cf6; --balanced:#93c5fd;
  color-scheme:dark;
}
*{box-sizing:border-box}
body{font-family:Inter,system-ui,Arial,Segoe UI;background:var(--bg);color:#e6eef8;margin:10px}
h1{font-size:18px;color:#7dd3fc;margin:8px 0}
.card{background:var(--card);padding:12px;border-radius:10px;margin-bottom:10px;box-shadow:0 6px 26px rgba(0,0,0,0.5)}
.row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
label{font-size:13px;color:var(--muted)}
input,select,button{font-size:13px}
input,select{padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.05);background:transparent;color:inherit}
input[type=number]{width:110px}
button{background:var(--accent);border:0;padding:8px 12px;border-radius:8px;color:#04201a;cursor:pointer}
button:hover{opacity:.95}
.small{font-size:12px;color:var(--muted)}
pre{background:#001222;padding:10px;border-radius:8px;color:#d6f8ee;white-space:pre-wrap;max-height:420px;overflow:auto}
canvas{background:transparent;border-radius:8px}
.grid-2{display:grid;grid-template-columns:1fr 560px;gap:12px}
@media(max-width:940px){.grid-2{grid-template-columns:1fr}}
.legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
.toast{position:fixed;bottom:14px;right:14px;background:#0c2438;color:#e8faff;padding:10px 16px;border-radius:6px;opacity:0;transition:opacity .25s;z-index:999;font-size:13px}
.toast.show{opacity:1}
.conf-meter{font-size:14px;text-align:center;margin-top:6px}
.summary{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;margin-top:6px}
.kv{min-width:150px}
.footer-small{font-size:12px;color:var(--muted);text-align:center;margin-top:8px}
.note{font-size:12px;color:#cbd5e1;margin-top:6px}
</style>
</head>
<body>
<h1>⚽ Prediksi Global v20.3.3 — FINAL</h1>

<div class="card small">
v20.3.3 FINAL — Zero Bias + Parkir Bus Pro + Elite Penajam (DTF, TC, RxGC, VoP). Bersih: **tanpa contoh data**. Netral, stabil, ready untuk input real.
</div>

<div id="toast" class="toast"></div>

<!-- Top Controls -->
<div class="card row">
  <label class="kv">League GPG<input id="league_gpg" type="number" step="0.01" placeholder=""></label>
  <label class="kv">Market OU<input id="market_ou" type="number" step="0.1" placeholder=""></label>
  <label class="kv">MC Iter<input id="mc_select" type="number" placeholder=""></label>
  <label class="kv">Match Type<select id="match_type"><option>Regular</option><option>Derby</option><option>Final</option><option>Friendly</option><option>Relegation</option></select></label>
  <label class="kv">Competition<select id="comp_mode"><option>Club</option><option>Cup</option><option>Playoff</option><option>Super Cup</option><option>International</option></select></label>
  <label class="kv">Weather<select id="weather"><option>Normal</option><option>Rain</option><option>Snow</option><option>Hot</option></select></label>
  <button id="analyzeBtn">Analisis</button>
  <label class="kv" style="display:flex;align-items:center;gap:6px;">
    <input id="bayes_mode" type="checkbox" style="width:16px;height:16px;margin:0"> Bayesian
  </label>
  <label class="kv" style="display:flex;align-items:center;gap:6px;">
    <input id="zero_bias_mode" type="checkbox" style="width:16px;height:16px;margin:0" checked> Zero Bias
  </label>
  <label class="kv" style="display:flex;align-items:center;gap:6px;">
    <input id="pb_mode" type="checkbox" style="width:16px;height:16px;margin:0" checked> Parkir Bus Pro (Auto)
  </label>
  <label class="kv" style="display:flex;align-items:center;gap:6px;">
    <input id="elite_mode" type="checkbox" style="width:16px;height:16px;margin:0" checked> Elite Penajam (DTF/TC/RxGC/VoP)
  </label>
  <button id="toggleModeBtn">Analyst Mode</button>
</div>

<div class="grid-2">
  <div>
    <div class="card">
      <h3>Home — Input</h3>
      <div class="row">
        <label class="kv">Team<input id="h_name" type="text" placeholder=""></label>
        <label class="kv">GPG<input id="h_gpg" type="number" step="0.01" placeholder=""></label>
        <label class="kv">GC<input id="h_gc" type="number" step="0.01" placeholder=""></label>
      </div>
      <div class="row">
        <label class="kv">Shots<input id="h_shots" type="number" step="0.1" placeholder=""></label>
        <label class="kv">SOT<input id="h_sot" type="number" step="0.1" placeholder=""></label>
        <label class="kv">Conv%<input id="h_conv" type="number" step="0.1" placeholder=""></label>
        <button onclick="autoConv('h')">Auto Conv</button>
      </div>
      <div class="row">
        <label class="kv">Poss%<input id="h_poss" type="number" step="0.1" placeholder=""></label>
        <label class="kv">ShotsC<input id="h_shotsC" type="number" step="0.1" placeholder=""></label>
        <button onclick="autoShotsC('h')">Auto ShotsC</button>
        <label class="kv">Cross%<input id="h_cr" type="number" step="0.1" placeholder=""></label>
        <button onclick="autoCross('h')">Auto Cross</button>
      </div>
      <div class="row">
        <label class="kv">Profile<select id="h_profile"><option value="auto">Auto</option><option value="attack">Attack-heavy</option><option value="defense">Defense-heavy</option><option value="strong">Strong Both</option><option value="weak">Weak Both</option><option value="balanced">Balanced</option></select></label>
        <label class="kv">ELO<input id="h_elo" type="number" placeholder=""></label>
      </div>
      <div style="margin-top:8px"><strong>Absensi</strong></div>
      <div class="row small">
        <label class="kv">GK abs<input id="h_gk_abs" type="number" min="0" max="1" placeholder=""></label>
        <label class="kv">DF abs<input id="h_df_abs" type="number" min="0" max="4" placeholder=""></label>
        <label class="kv">MD abs<input id="h_md_abs" type="number" min="0" max="5" placeholder=""></label>
        <label class="kv">FW abs<input id="h_fw_abs" type="number" min="0" max="3" placeholder=""></label>
        <label class="kv">PAF%<input id="h_paf" type="number" step="0.1" placeholder=""></label>
        <button onclick="autoPAF('h')">Auto PAF</button>
      </div>
    </div>

    <div class="card">
      <h3>Away — Input</h3>
      <div class="row">
        <label class="kv">Team<input id="a_name" type="text" placeholder=""></label>
        <label class="kv">GPG<input id="a_gpg" type="number" step="0.01" placeholder=""></label>
        <label class="kv">GC<input id="a_gc" type="number" step="0.01" placeholder=""></label>
      </div>
      <div class="row">
        <label class="kv">Shots<input id="a_shots" type="number" step="0.1" placeholder=""></label>
        <label class="kv">SOT<input id="a_sot" type="number" step="0.1" placeholder=""></label>
        <label class="kv">Conv%<input id="a_conv" type="number" step="0.1" placeholder=""></label>
        <button onclick="autoConv('a')">Auto Conv</button>
      </div>
<div class="row">
        <label class="kv">Poss%<input id="a_poss" type="number" step="0.1" placeholder=""></label>
        <label class="kv">ShotsC<input id="a_shotsC" type="number" step="0.1" placeholder=""></label>
        <button onclick="autoShotsC('a')">Auto ShotsC</button>
        <label class="kv">Cross%<input id="a_cr" type="number" step="0.1" placeholder=""></label>
        <button onclick="autoCross('a')">Auto Cross</button>
      </div>
      <div class="row">
        <label class="kv">Profile<select id="a_profile"><option value="auto">Auto</option><option value="attack">Attack-heavy</option><option value="defense">Defense-heavy</option><option value="strong">Strong Both</option><option value="weak">Weak Both</option><option value="balanced">Balanced</option></select></label>
        <label class="kv">ELO<input id="a_elo" type="number" placeholder=""></label>
      </div>
      <div class="row small">
        <label class="kv">GK abs<input id="a_gk_abs" type="number" min="0" max="1" placeholder=""></label>
        <label class="kv">DF abs<input id="a_df_abs" type="number" min="0" max="4" placeholder=""></label>
        <label class="kv">MD abs<input id="a_md_abs" type="number" min="0" max="5" placeholder=""></label>
        <label class="kv">FW abs<input id="a_fw_abs" type="number" min="0" max="3" placeholder=""></label>
        <label class="kv">PAF%<input id="a_paf" type="number" step="0.1" placeholder=""></label>
        <button onclick="autoPAF('a')">Auto PAF</button>
      </div>
    </div>

    <div class="card">
      <h3>Odds Input</h3>
      <div class="row">
        <label class="kv">Home Odds<input id="odds_home" type="number" step="0.01" placeholder=""></label>
        <label class="kv">Away Odds<input id="odds_away" type="number" step="0.01" placeholder=""></label>
      </div>
      <div class="row">
        <label class="kv">HDP Open<input id="odds_hdp_open" type="number" step="0.01" placeholder=""></label>
        <label class="kv">HDP Now<input id="odds_hdp_now" type="number" step="0.01" placeholder=""></label>
      </div>
      <div class="row">
        <label class="kv">Over Odds<input id="odds_over" type="number" step="0.01" placeholder=""></label>
        <label class="kv">Under Odds<input id="odds_under" type="number" step="0.01" placeholder=""></label>
      </div>
    </div>

    <div class="card row">
      <button id="autoCalcStats">Auto Hitung Statistik</button>
      <button id="autoEnhancedBtn">Enhanced Stats (Auto)</button>
      <button id="autoOddsBtn">Auto Isi Odds</button>
      <button id="manualCalcBtn">Hitung Manual</button>
      <button id="exportBtn">Export CSV</button>
      <button id="viewHistory">Lihat History</button>
      <button id="resetBtn">Reset Input</button>
      <button id="inputRealBtn">Input Skor Nyata</button>
    </div>
  </div>

  <div>
    <div class="card">
      <strong>HASIL PREDIKSI</strong>
      <div id="summary" class="summary">Klik “Analisis” untuk melihat hasil.</div>
      <pre id="resultText">(hasil JSON akan tampil di sini)</pre>
      <div id="confMeter" class="conf-meter"></div>
    </div>

    <div class="card">
      <strong>Radar Profil</strong>
      <div style="width:320px;margin:auto"><canvas id="radarCanvas" width="320" height="320"></canvas></div>
      <div class="legend small">Radar: Attack / Defense / Form / PAF / Conv%</div>
    </div>

    <div class="card">
      <strong>Trend Hasil Sebelumnya</strong>
      <div style="width:480px;margin:auto"><canvas id="trendCanvas" width="480" height="200"></canvas></div>
      <div class="legend small">Trend 30 prediksi terakhir (H/D/A)</div>
    </div>
  </div>
</div>

<div class="footer-small">Built: v20.3.3 FINAL — Zero Bias + Parkir Bus Pro + Elite Penajam</div>

<script>
/* ================= Utilities ================= */
const safeNum=(v,d=0)=>{const n=Number(v);return Number.isFinite(n)?n:d;};
const clamp=(v,a,b)=> isFinite(v)?(v<a?a:v>b?b:v):a;
const rnd=(v,d=3)=> Math.round((v||0)*10**d)/10**d;
const toastEl=document.getElementById('toast');
function showToast(msg,ms=1600){ if(!toastEl){ console.log(msg); return; } toastEl.textContent=msg; toastEl.classList.add('show'); clearTimeout(window._qpe_toast_timeout); window._qpe_toast_timeout=setTimeout(()=> toastEl.classList.remove('show'), ms); }

/* ================= Storage Keys & Bayesian helpers ================= */
const BAYES_KEY = 'qpe_v20_3_3_bayes_priors';
const INPUT_SAVE_KEY = 'qpe_v20_3_3_inputs';
const HIST_KEY = 'qpe_v20_3_3_history';
function lognormSample(mu, sigma){ if(!isFinite(sigma) || sigma <= 0.0000001) return Math.max(0.001, Math.exp(mu)); const u1=Math.random(), u2=Math.random(); const z = Math.sqrt(-2*Math.log(u1))*Math.cos(2*Math.PI*u2); return Math.max(0.001, Math.exp(mu + sigma*z)); }
function lognormStats(mu, sigma){ const mean = Math.exp(mu + 0.5 * sigma * sigma); const variance = (Math.exp(sigma*sigma) - 1) * Math.exp(2*mu + sigma*sigma); return {mean, sd: Math.sqrt(variance)}; }
function loadBayesPriors(){ try{ return JSON.parse(localStorage.getItem(BAYES_KEY) || '{}'); }catch(e){ return {}; } }
function saveBayesPriors(obj){ try{ localStorage.setItem(BAYES_KEY, JSON.stringify(obj)); }catch(e){} }

/* ================= Zero Bias & Parkir Bus helpers ================= */
function zeroBiasSigmaNormalize(sigma){ return clamp(sigma * 0.82, 0.08, 1.2); }
function ouCalibrationLambda(lambdaH, lambdaA, targetOU=2.5, power=0.18){ const total = Math.max(0.01, lambdaH + lambdaA); const factor = Math.pow((targetOU / total), power); return [lambdaH * factor, lambdaA * factor]; }
function lambdaSmoothing(prevLambda, newLambda, alpha=0.70){ return prevLambda * alpha + newLambda * (1 - alpha); }

/* ================= Parkir Bus Pro helpers ================= */
function detectParkirBusSignal(home, away, leagueGPG){
  try{
    let score = 0;
    const gapXG = (home.xg_est||0) - (away.xg_est||0);
    if(gapXG > 0.6) score += 0.25;
    if(gapXG > 1.0) score += 0.15;
    if(away.profile === 'defense' || away.profile === 'weak') score += 0.12;
    if((away.poss||50) < 42) score += 0.12;
    if((away.shots||10) < 8) score += 0.10;
    const eloGap = (home.elo||1500) - (away.elo||1500);
    if(eloGap > 180) score += 0.12;
    if(eloGap > 300) score += 0.08;
    if((leagueGPG||2.6) < 2.4) score += 0.06;
    return clamp(score,0,1);
  }catch(e){ return 0; }
}
function parkirBusAdjust(lambdaH, lambdaA, signal, aggressiveness=1.0){
  const reduceHomePct = 0.10 * signal * aggressiveness;
  const reduceAwayPct = 0.06 * signal * aggressiveness;
  const newH = lambdaH * (1 - reduceHomePct);
  const newA = lambdaA * (1 - reduceAwayPct);
  return [clamp(newH,0.01,20), clamp(newA,0.01,20)];
}

/* ================= Elite Penajam — DTF, TC, RxGC, VoP ================= */
/* Dynamic Transition Factor (DTF) */
function computeDTF(shots, sot, inter, shotsC){
  shots = safeNum(shots,10); sot = safeNum(sot,4); inter = safeNum(inter,3); shotsC = safeNum(shotsC,10);
  let dtf = ((sot*1.4 + shots*0.7 + inter*0.5) - shotsC*0.4) / 20;
  return clamp(dtf, -0.6, 0.8);
}
/* Tactical Compression (TC) */
function computeTC(shotsC, duels, pbSignal){
  shotsC = safeNum(shotsC,10); duels = safeNum(duels,20); pbSignal = safeNum(pbSignal,0);
  let tc = ((shotsC * 0.02) + (duels * 0.015)) * (1 + pbSignal*0.8);
  return clamp(tc, 0.02, 0.40);
}
/* Realistic xG Curve Correction (RxGC) */
function computeRxGC(shotsC){
  shotsC = safeNum(shotsC,10);
  let rx = 1 - Math.log(1 + shotsC*0.06);
  return clamp(rx, 0.82, 1.00);
}
/* Velocity of Play (VoP) */
function computeVoP(shots, sot, cross, duels){
  shots = safeNum(shots,10); sot = safeNum(sot,4); cross = safeNum(cross,18); duels = safeNum(duels,20);
  const tempo = (shots*0.06 + sot*0.08 + cross*0.035 + duels*0.02);
  return clamp(tempo / 6.5, 0.75, 1.18);
}

/* ================= Math core ================= */
function factorial(n){ if(n<0) return 1; let r=1; for(let i=2;i<=n;i++) r*=i; return r; }
function poissonPMF(k,λ){ if(k<0) return 0; return Math.exp(-λ)*Math.pow(λ,k)/factorial(k); }
function samplePoisson(λ){ λ = safeNum(λ,0); if(λ<=0) return 0; if(λ>80){ const v=Math.round(λ + Math.sqrt(λ)*(Math.random()*2-1)); return Math.max(0,v); } const L=Math.exp(-λ); let k=0,p=1; do{ k++; p*=Math.random(); } while(p > L); return k-1; }
function entropy(arr){ return -arr.reduce((s,x)=> s + (x>0? x*Math.log(x) : 0), 0); }

/* ================= Profiles (rebalanced) ================= */
function profileMultiplier(code){
  switch(code){
    case 'attack': return {atk:1.07, def:0.94, color:'#f97316'};
    case 'defense': return {atk:0.94, def:1.06, color:'#3b82f6'};
    case 'strong': return {atk:1.06, def:1.06, color:'#10b981'};
    case 'weak': return {atk:0.92, def:0.92, color:'#8b5cf6'};
    default: return {atk:1.00, def:1.00, color:'#93c5fd'};
  }
}
function classifyTeam(xG,xGA){
  if(xG > 1.6 && xGA < 1.0) return 'strong';
  if(xG > 1.6 && xGA > 1.3) return 'attack';
  if(xG < 1.1 && xGA < 1.0) return 'defense';
  if(xG < 1.1 && xGA > 1.3) return 'weak';
  return 'balanced';
}
/* ================= Derived indices ================= */
function computeXGplus(shots, sot, conv, poss, cr, leagueAvg, weights){
  shots = safeNum(shots,10); sot = safeNum(sot,4); conv = safeNum(conv,10); poss = safeNum(poss,50); cr = safeNum(cr,20);
  weights = weights || {shots:0.06,sot:0.04,conv:0.03,poss:0.02,cr:0.02};
  const base = shots*weights.shots + sot*weights.sot + (conv/100)*shots*weights.conv + (poss/100)*weights.poss*10 + cr*weights.cr;
  const blended = 0.65*base + 0.35*(leagueAvg||1.15);
  try{ const hook = window._qpe_xthreat; if(hook && typeof hook === 'object' && hook.mult) return clamp(blended * safeNum(hook.mult,1), 0.01, 12); }catch(e){}
  return clamp(blended, 0.01, 12);
}
function computeDSI(gc, shotsC, oppElo, leagueAvgElo=1500){
  gc = safeNum(gc,1); shotsC = safeNum(shotsC,10); oppElo = safeNum(oppElo, leagueAvgElo);
  const defensePressure = Math.log1p(shotsC) * 0.22;
  const base = gc*0.46 + defensePressure*0.54;
  const eloAdj = Math.pow((oppElo/leagueAvgElo), 0.75);
  return clamp(base * eloAdj, 0.12, 6);
}
function calcFEI(gpg, estXG, formDelta=0, paf=1){
  gpg = safeNum(gpg,0); estXG = safeNum(estXG,0.8);
  if(estXG <= 1e-6) return 1;
  const raw = gpg/estXG;
  const base = clamp(0.6*raw + 0.4, 0.5, 1.6);
  const formFactor = 1 + clamp(formDelta, -0.5, 0.5) * 0.02;
  return clamp(base * formFactor * paf, 0.5, 1.8);
}
function eloSigmoidFactor(e1,e2,isIntl){
  const diff = (safeNum(e1,1500)-safeNum(e2,1500))/400;
  const s = 1/(1+Math.exp(-diff*1.6));
  const bias = 1 + (s - 0.5) * 0.6;
  return isIntl ? (0.75*bias + 0.25) : bias;
}

/* ================= Skellam & logistic proxies ================= */
function skellamOutcome(lambdaH, lambdaA, maxr=12){
  const probs={home:0,draw:0,away:0};
  for(let gh=0; gh<=maxr; gh++){
    for(let ga=0; ga<=maxr; ga++){
      const p = poissonPMF(gh,lambdaH)*poissonPMF(ga,lambdaA);
      if(gh>ga) probs.home += p; else if(gh===ga) probs.draw += p; else probs.away += p;
    }
  }
  const s = probs.home + probs.draw + probs.away;
  if(s>0){ probs.home/=s; probs.draw/=s; probs.away/=s; }
  return probs;
}

/* ================= Confidence ================= */
function computeConfidence(probs, lambdaH, lambdaA, trapIndex, pastErr=0){
  const maxP = Math.max(probs.home, probs.draw, probs.away);
  const ent = entropy([probs.home,probs.draw,probs.away]) / Math.log(3);
  let conf = clamp((maxP - 1/3)*(1 - ent)*2, 0, 1);
  const lambdaDiff = Math.abs(lambdaH - lambdaA);
  conf *= clamp(1 + (lambdaDiff/3)*0.16, 0.88, 1.12);
  conf *= clamp(1 - Math.abs(trapIndex-1)*0.22, 0.75, 1.08);
  conf *= clamp(1 - pastErr*0.45, 0.72, 1.05);
  return clamp(conf, 0, 1);
}

/* ================= Worker (Bayes-ready) ================= */
let workerUrl=null, workerInstance=null;
const workerCode = `
self.onmessage = function(e){
  const D = e.data;
  function safeNum(v,d=0){ const n=Number(v); return Number.isFinite(n)? n: d; }
  function factorial(n){ if(n<0) return 1; let r=1; for(let i=2;i<=n;i++) r*=i; return r; }
  function poissonPMF(k,λ){ if(k<0) return 0; return Math.exp(-λ)*Math.pow(λ,k)/factorial(k); }
  function samplePoisson(lambda){ lambda = safeNum(lambda,0); if(lambda<=0) return 0; if(lambda>80){ const v=Math.round(lambda + Math.sqrt(lambda)*(Math.random()*2-1)); return Math.max(0,v);} const L=Math.exp(-lambda); let k=0,p=1; do{ k++; p*=Math.random(); } while(p > L); return k-1; }
  function boxMuller(){ const u1=Math.random(), u2=Math.random(); const z=Math.sqrt(-2*Math.log(u1))*Math.cos(2*Math.PI*u2); return z; }
  function lognormSample(mu, sigma){ if(!isFinite(sigma) || sigma <= 0.0000001) return Math.max(0.001, Math.exp(mu)); const z = boxMuller(); return Math.max(0.001, Math.exp(mu + sigma * z)); }

  const counts={home:0,draw:0,away:0,over:0,under:0,scores:{}};
  for(let i=0;i<D.iters;i++){
    let lambdaH = D.useBayes ? lognormSample(D.lambdaH.mu, D.lambdaH.sigma) : D.lambdaH;
    let lambdaA = D.useBayes ? lognormSample(D.lambdaA.mu, D.lambdaA.sigma) : D.lambdaA;
    if(!D.useBayes){ lambdaH = safeNum(lambdaH, D.lambdaH); lambdaA = safeNum(lambdaA, D.lambdaA); }
    const gh = samplePoisson(lambdaH);
    const ga = samplePoisson(lambdaA);
    if(gh>ga) counts.home++; else if(gh==ga) counts.draw++; else counts.away++;
    if(gh+ga > D.ou) counts.over++; else counts.under++;
    const k = gh + '-' + ga; counts.scores[k] = (counts.scores[k]||0) + 1;
  }
  ['home','draw','away','over','under'].forEach(k=>counts[k] = counts[k]/D.iters);
  for(const k in counts.scores) counts.scores[k] = counts.scores[k]/D.iters;
  postMessage(counts);
};`;
try{ const b=new Blob([workerCode],{type:'application/javascript'}); workerUrl=URL.createObjectURL(b); workerInstance=new Worker(workerUrl);}catch(e){workerInstance=null;console.warn('Worker not available - fallback.');}

/* ================= Auto-Assist & Enhanced Stats ================= */
function autoConv(side){ try{ const gpg=safeNum(document.getElementById(side+'_gpg').value,null); const shots=safeNum(document.getElementById(side+'_shots').value,null); if(gpg&&shots){ const conv=(gpg/Math.max(shots,1))*100; document.getElementById(side+'_conv').value=conv.toFixed(1); showToast(side.toUpperCase()+' Conv% otomatis: '+conv.toFixed(1)+'%'); return; } showToast('Auto Conv: data kurang'); }catch(e){console.error(e);showToast('Gagal hitung Conv%');} }
function autoShotsC(side){ try{ const shots=safeNum(document.getElementById(side+'_shots').value,10); const poss=safeNum(document.getElementById(side+'_poss').value,50); let est=18 - (shots*(poss/55)); est=Math.max(5,Math.min(est,20)); const comp=document.getElementById('comp_mode').value; if(comp==='International') est*=0.92; document.getElementById(side+'_shotsC').value=est.toFixed(1); showToast(side.toUpperCase()+' ShotsC terestimasi: '+est.toFixed(1)); }catch(e){console.error(e);showToast('Gagal hitung ShotsC');} }
function autoCross(side){ try{ const poss=safeNum(document.getElementById(side+'_poss').value,50); let val=18+(poss-50)*0.1; val=clamp(val,10,35); document.getElementById(side+'_cr').value=val.toFixed(1); showToast(side.toUpperCase()+' Cross% terisi: '+val.toFixed(1)+'%'); }catch(e){console.error(e);showToast('Gagal hitung Cross%');} }
function autoPAF(side){ try{ const gk=safeNum(document.getElementById(side+'_gk_abs').value,0); const df=safeNum(document.getElementById(side+'_df_abs').value,0); const md=safeNum(document.getElementById(side+'_md_abs').value,0); const fw=safeNum(document.getElementById(side+'_fw_abs').value,0); let raw=100-(gk*6 + df*2 + md*1.5 + fw*4); raw=Math.max(65,Math.min(raw,100)); const comp=document.getElementById('comp_mode').value; if(comp==='International') raw = 100 - ((100 - raw) * 0.5); document.getElementById(side+'_paf').value=raw.toFixed(1); showToast(side.toUpperCase()+' PAF terisi: '+raw.toFixed(1)+'%'); }catch(e){console.error(e);showToast('Gagal hitung PAF');} }
function computeEnhancedFor(side){
  const big_sc=safeNum(document.getElementById(side+'_big_sc')?.value,0);
  const big_mis=safeNum(document.getElementById(side+'_big_mis')?.value,0);
  const duels=safeNum(document.getElementById(side+'_duels')?.value,0);
  const inter=safeNum(document.getElementById(side+'_inter')?.value,0);
  const poss_lost=safeNum(document.getElementById(side+'_poss_lost')?.value,0);
  const err_shot=safeNum(document.getElementById(side+'_err_shot')?.value,0);
  const pen_goals=safeNum(document.getElementById(side+'_pen_goals')?.value,0);
  const fk_goals=safeNum(document.getElementById(side+'_fk_goals')?.value,0);
  const matches=Math.max(1,safeNum(document.getElementById(side+'_matches')?.value,1));
  const yellow=safeNum(document.getElementById(side+'_yellow')?.value,0);
  const red=safeNum(document.getElementById(side+'_red')?.value,0);
  const bcci=(big_sc+1)/(big_sc+big_mis+2);
  const pri=(duels+inter+1)/(poss_lost+err_shot+2);
  const spf=(pen_goals+fk_goals+0.1)/((safeNum(document.getElementById(side+'_gpg')?.value,0))+1);
  const di=clamp(1-(yellow*0.02+red*0.05),0.6,1.0);
  const ff=clamp(1-(matches*0.0025),0.96,1.02);
  return { bcci:rnd(bcci,3), pri:rnd(pri,3), spf:rnd(spf,3), di:rnd(di,3), ff:rnd(ff,3) };
}

/* ================= Bayesian priors init & update (same pattern) ================= */
function initTeamPrior(teamName, leagueGPG){
  const priors = loadBayesPriors();
  if(priors[teamName]) return priors[teamName];
  const baseline = Math.max(0.05, leagueGPG/2);
  const mu = Math.log(baseline);
  const sigma = 0.45;
  priors[teamName] = {mu:rnd(mu,6), sigma:rnd(sigma,6), n:0, lastUpdated:(new Date()).toISOString()};
  saveBayesPriors(priors);
  return priors[teamName];
}
function updateTeamPosterior(teamName, observedGoals, exposure=1, leagueGPG=2.6){
  const priors = loadBayesPriors();
  const prior = priors[teamName] || initTeamPrior(teamName, leagueGPG);
  const eps=1e-3;
  const lam_hat = Math.max(eps, observedGoals/Math.max(1,exposure));
  const obsMu = Math.log(lam_hat);
  const obsVar = 1 / Math.max(0.5, Math.sqrt(lam_hat));
  const priorVar = Math.max(1e-6, prior.sigma*prior.sigma);
  const postVar = 1 / (1/priorVar + 1/obsVar);
  const postMu = postVar * (prior.mu/priorVar + obsMu/obsVar);
  const count = (prior.n||0);
  const damp = 1 / (1 + Math.sqrt(count)*0.1);
  const newMu = prior.mu*(1 - damp) + postMu*damp;
  const newSigma = Math.sqrt(postVar) * (1 - 0.15 * Math.min(0.9, Math.log10(1+count)));
  priors[teamName] = {mu:rnd(newMu,6), sigma:rnd(newSigma,6), n:(count||0)+1, lastUpdated:(new Date()).toISOString()};
  saveBayesPriors(priors);
  return priors[teamName];
}
/* ================= run sim wrappers ============ */
function runMainSim(lambdaH_use, lambdaA_use, iters, ou){
  const counts={home:0,draw:0,away:0,over:0,under:0,scores:{}};
  for(let i=0;i<iters;i++){
    const gh = samplePoisson(lambdaH_use);
    const ga = samplePoisson(lambdaA_use);
    if(gh>ga) counts.home++; else if(gh===ga) counts.draw++; else counts.away++;
    if(gh+ga > ou) counts.over++; else counts.under++;
    const k = gh + '-' + ga; counts.scores[k] = (counts.scores[k]||0) + 1;
  }
  ['home','draw','away','over','under'].forEach(k=>counts[k] = counts[k]/iters);
  for(const k in counts.scores) counts.scores[k] = counts.scores[k]/iters;
  return counts;
}
function runWorkerSim(lambdaH_use, lambdaA_use, iters, ou, useBayes=false){
  return new Promise((resolve)=>{
    if(!workerInstance){
      if(useBayes){ const lh = lognormSample(lambdaH_use.mu, lambdaH_use.sigma); const la = lognormSample(lambdaA_use.mu, lambdaA_use.sigma); resolve(runMainSim(lh,la,iters,ou)); return; }
      resolve(runMainSim(lambdaH_use,lambdaA_use,iters,ou)); return;
    }
    const handler=(ev)=>{ workerInstance.removeEventListener('message',handler); resolve(ev.data); };
    workerInstance.addEventListener('message', handler);
    try{ workerInstance.postMessage({ lambdaH: lambdaH_use, lambdaA: lambdaA_use, iters: iters, ou: ou, useBayes: !!useBayes }); }
    catch(e){ workerInstance.removeEventListener('message', handler); if(useBayes){ const lh=lognormSample(lambdaH_use.mu, lambdaH_use.sigma); const la=lognormSample(lambdaA_use.mu, lambdaA_use.sigma); resolve(runMainSim(lh,la,iters,ou)); return; } resolve(runMainSim(lambdaH_use,lambdaA_use,iters,ou)); }
  });
}

/* ================= Main Analyze Handler (Elite penajam integrated) ================= */
document.getElementById('analyzeBtn').addEventListener('click', async function(){
  try{
    showToast('Analisis berjalan...');
    const leagueGPG = Math.max(0.3, safeNum(document.getElementById('league_gpg').value, 2.6));
    const mcIters = Math.max(2000, Math.floor(safeNum(document.getElementById('mc_select').value, 20000)));
    const matchType = document.getElementById('match_type').value;
    const comp = document.getElementById('comp_mode').value;
    const weather = document.getElementById('weather').value;
    const bayesOn = !!document.getElementById('bayes_mode')?.checked;
    const zeroBiasOn = !!document.getElementById('zero_bias_mode')?.checked;
    const pbAutoOn = !!document.getElementById('pb_mode')?.checked;
    const eliteOn = !!document.getElementById('elite_mode')?.checked;

    // read inputs
    const h = {
      name: (document.getElementById('h_name')||{}).value || '',
      gpg: safeNum(document.getElementById('h_gpg').value, 1.4),
      gc: safeNum(document.getElementById('h_gc').value, 1.2),
      shots: safeNum(document.getElementById('h_shots').value, 11),
      sot: safeNum(document.getElementById('h_sot').value, 4),
      conv: safeNum(document.getElementById('h_conv').value, null),
      poss: safeNum(document.getElementById('h_poss').value, 52),
      shotsC: safeNum(document.getElementById('h_shotsC').value, null),
      cr: safeNum(document.getElementById('h_cr').value, null),
      elo: safeNum(document.getElementById('h_elo').value, 1500),
      profile: (document.getElementById('h_profile')||{}).value || 'auto',
      gk_abs: safeNum(document.getElementById('h_gk_abs').value,0),
      df_abs: safeNum(document.getElementById('h_df_abs').value,0),
      md_abs: safeNum(document.getElementById('h_md_abs').value,0),
      fw_abs: safeNum(document.getElementById('h_fw_abs').value,0),
      paf: safeNum(document.getElementById('h_paf').value, null)
    };
    const a = {
      name: (document.getElementById('a_name')||{}).value || '',
      gpg: safeNum(document.getElementById('a_gpg').value, 1.2),
      gc: safeNum(document.getElementById('a_gc').value, 1.3),
      shots: safeNum(document.getElementById('a_shots').value, 10),
      sot: safeNum(document.getElementById('a_sot').value, 4),
      conv: safeNum(document.getElementById('a_conv').value, null),
      poss: safeNum(document.getElementById('a_poss').value, 48),
      shotsC: safeNum(document.getElementById('a_shotsC').value, null),
      cr: safeNum(document.getElementById('a_cr').value, null),
      elo: safeNum(document.getElementById('a_elo').value, 1500),
      profile: (document.getElementById('a_profile')||{}).value || 'auto',
      gk_abs: safeNum(document.getElementById('a_gk_abs').value,0),
      df_abs: safeNum(document.getElementById('a_df_abs').value,0),
      md_abs: safeNum(document.getElementById('a_md_abs').value,0),
      fw_abs: safeNum(document.getElementById('a_fw_abs').value,0),
      paf: safeNum(document.getElementById('a_paf').value, null)
    };

    // auto fills
    if(!h.conv) autoConv('h'); if(!a.conv) autoConv('a');
    if(!h.shotsC) autoShotsC('h'); if(!a.shotsC) autoShotsC('a');
    if(!h.cr) autoCross('h'); if(!a.cr) autoCross('a');
    if(!h.paf) autoPAF('h'); if(!a.paf) autoPAF('a');

    h.conv = safeNum(document.getElementById('h_conv').value, 12);
    a.conv = safeNum(document.getElementById('a_conv').value, 11);
    h.shotsC = safeNum(document.getElementById('h_shotsC').value, 11);
    a.shotsC = safeNum(document.getElementById('a_shotsC').value, 12);
    h.cr = safeNum(document.getElementById('h_cr').value, 20);
    a.cr = safeNum(document.getElementById('a_cr').value, 20);
    h.paf = safeNum(document.getElementById('h_paf').value, 100)/100;
    a.paf = safeNum(document.getElementById('a_paf').value, 100)/100;

    // compute xG est
    const h_xg = computeXGplus(h.shots,h.sot,h.conv,h.poss,h.cr, leagueGPG);
    const a_xg = computeXGplus(a.shots,a.sot,a.conv,a.poss,a.cr, leagueGPG);
    const h_xga = computeXGplus(a.shots,a.sot,a.conv,a.poss,a.cr, leagueGPG);
    const a_xga = computeXGplus(h.shots,h.sot,h.conv,h.poss,h.cr, leagueGPG);
    if(h.profile==='auto') h.profile = classifyTeam(h_xg, h_xga);
    if(a.profile==='auto') a.profile = classifyTeam(a_xg, a_xga);

    // base indices
    const h_dsi = computeDSI(h.gc, h.shotsC, a.elo);
    const a_dsi = computeDSI(a.gc, a.shotsC, h.elo);
    let h_fei = calcFEI(h.gpg, h_xg, 0, h.paf);
    let a_fei = calcFEI(a.gpg, a_xg, 0, a.paf);

    // point lambdas
    let lambdaH_point = clamp((h_xg * (h_fei / (a_dsi || 1)) ) * (1 + h_xga*0.03), 0.01, 20);
    let lambdaA_point = clamp((a_xg * (a_fei / (h_dsi || 1)) ) * (1 + a_xga*0.03), 0.01, 20);

    // profile adjustment
    const ph = profileMultiplier(h.profile);
    const pa = profileMultiplier(a.profile);
    const adj_h_atk = ph.atk * (1 - 0.10 * Math.min(a_dsi/4,1));
    const adj_a_atk = pa.atk * (1 - 0.10 * Math.min(h_dsi/4,1));
    const adj_h_def = ph.def * (1 + 0.06 * Math.min(a_fei/1.2,1));
    const adj_a_def = pa.def * (1 + 0.06 * Math.min(h_fei/1.2,1));
    let lambdaH = lambdaH_point * (adj_h_atk / adj_a_def);
    let lambdaA = lambdaA_point * (adj_a_atk / adj_h_def);

    // dynamic home advantage (mild, adaptive)
    function dynamicHomeAdv(hName,aName){
      try{
        const priors = loadBayesPriors();
        const lh = priors[hName] && priors[hName].n>2 ? Math.exp(priors[hName].mu) : null;
        const la = priors[aName] && priors[aName].n>2 ? Math.exp(priors[aName].mu) : null;
        if(lh!==null && la!==null){
          const diff = (lh - la);
          const ha = 1 + clamp(diff * 0.03, -0.05, 0.06);
          return clamp(ha, 0.97, 1.06);
        }
      }catch(e){}
      const comp = document.getElementById('comp_mode').value;
      if(comp==='International') return 1.02;
      if(comp==='Cup') return 1.03;
      return 1.03;
    }
    lambdaH *= dynamicHomeAdv(h.name, a.name);

    // match pressure/weather adjustments (capped)
    function pressureFactor(matchType){
      if(matchType==='Final') return 0.98;
      if(matchType==='Derby') return 1.03;
      if(matchType==='Relegation') return 0.96;
      return 1.0;
    }
    lambdaH *= pressureFactor(matchType);
    lambdaA *= pressureFactor(matchType);
    if(weather==='Rain' || weather==='Snow'){ lambdaH *= 0.96; lambdaA *= 0.96; }
    if(weather==='Hot'){ lambdaH *= 0.99; lambdaA *= 0.99; }

    // league bias & elo
    const leagueBias = Math.pow((leagueGPG/2.6), 0.6);
    lambdaH *= leagueBias; lambdaA *= leagueBias;
    const eloF = eloSigmoidFactor(h.elo, a.elo, (document.getElementById('comp_mode').value==='International'));
    lambdaH *= eloF; lambdaA *= (1/eloF || 1);

    // enhanced stats
    const enh = window._qpe_enh || { home: computeEnhancedFor('h'), away: computeEnhancedFor('a') };
    const h_en = enh.home; const a_en = enh.away;
    h_fei *= (1 + (h_en.bcci - 0.5)*0.35 + (h_en.spf - 0.1)*0.15);
    a_fei *= (1 + (a_en.bcci - 0.5)*0.35 + (a_en.spf - 0.1)*0.15);
    const h_dsi_adj = h_dsi * (1 - (h_en.pri - 0.5)*0.25);
    const a_dsi_adj = a_dsi * (1 - (a_en.pri - 0.5)*0.25);
    lambdaH *= h_en.ff; lambdaA *= a_en.ff;

    // odds & trap
    const oddsHome = safeNum(document.getElementById('odds_home')?.value, null);
    const oddsAway = safeNum(document.getElementById('odds_away')?.value, null);
    const hdpOpen = safeNum(document.getElementById('odds_hdp_open')?.value, 0);
    const hdpNow = safeNum(document.getElementById('odds_hdp_now')?.value, 0);
    const oddsOver = safeNum(document.getElementById('odds_over')?.value, null);
    const oddsUnder = safeNum(document.getElementById('odds_under')?.value, null);
    const marketOU = safeNum(document.getElementById('market_ou')?.value, 2.5);
    const trapIndex = computeTrap(hdpOpen, hdpNow, oddsHome, oddsAway, marketOU, oddsOver, oddsUnder);

    // Parkir Bus detection & adjustment
    let pbSignal = 0;
    if(pbAutoOn){
      const homeMeta = { xg_est: h_xg, poss: h.poss, shots: h.shots, profile: h.profile, elo: h.elo };
      const awayMeta = { xg_est: a_xg, poss: a.poss, shots: a.shots, profile: a.profile, elo: a.elo };
      pbSignal = detectParkirBusSignal(homeMeta, awayMeta, leagueGPG);
      const aggressiveness = pbSignal > 0.6 ? 1.15 : (pbSignal > 0.35 ? 1.0 : 0.7);
      if(pbSignal > 0.08){
        const [adjH, adjA] = parkirBusAdjust(lambdaH, lambdaA, pbSignal, aggressiveness);
        lambdaH = adjH; lambdaA = adjA;
      }
    }

    // === ELITE PENAJAM APPLICATION (if enabled) ===
    if(eliteOn){
      // compute DTF (transition) for both teams — uses inter (interceptions/duels) from enhanced stats
      const dtfH = computeDTF(h.shots, h.sot, (h_en && h_en.pri? h_en.pri*10 : 3), h.shotsC);
      const dtfA = computeDTF(a.shots, a.sot, (a_en && a_en.pri? a_en.pri*10 : 3), a.shotsC);
      // apply small multiplier symmetric
      lambdaH *= (1 + dtfH * 0.06);
      lambdaA *= (1 + dtfA * 0.06);

      // Tactical Compression (TC) — makes compact defense reduce opponent lambda
      const tcH = computeTC(h.shotsC, (h_en && h_en.pri? h_en.pri*10 : 12), pbSignal);
      const tcA = computeTC(a.shotsC, (a_en && a_en.pri? a_en.pri*10 : 12), pbSignal);
      // apply to opponent attack
      lambdaA *= (1 - tcH * 0.22);
      lambdaH *= (1 - tcA * 0.22);

      // RxGC (xG curve correction) — prevents too many shots -> disproportionate xG
      const rxH = computeRxGC(h.shotsC);
      const rxA = computeRxGC(a.shotsC);
      lambdaH *= rxH; lambdaA *= rxA;

      // VoP (velocity) — tempo factor
      const vopH = computeVoP(h.shots, h.sot, h.cr, (h_en && h_en.pri? h_en.pri*10 : 12));
      const vopA = computeVoP(a.shots, a.sot, a.cr, (a_en && a_en.pri? a_en.pri*10 : 12));
      lambdaH *= vopH; lambdaA *= vopA;

      // Deep Defensive Integrity (DDI) — extra defensive fine tune (small)
      const ddiH = (h_dsi * (1 + h.df_abs*0.03 + h.gk_abs*0.06)) + (h.shotsC * 0.02);
      const ddiA = (a_dsi * (1 + a.df_abs*0.03 + a.gk_abs*0.06)) + (a.shotsC * 0.02);
      lambdaA *= 1 - clamp((ddiH - 1.4)*0.05, -0.08, 0.08);
      lambdaH *= 1 - clamp((ddiA - 1.4)*0.05, -0.08, 0.08);

      // Adaptive Possession Delta (APD) — mitigates inferior attack when possession gap big
      const deltaPoss = Math.abs(h.poss - a.poss);
      if(deltaPoss > 10){
        if(h.poss > a.poss){ lambdaA *= (1 - (deltaPoss/100)*0.12); } else { lambdaH *= (1 - (deltaPoss/100)*0.12); }
      }

      // Shot Pressure Index (SPI) — quality pressure index
      const spiH = (h.shots + h.sot*1.4 + h.cr*0.8) / 20;
      const spiA = (a.shots + a.sot*1.4 + a.cr*0.8) / 20;
      lambdaH *= (0.96 + spiH*0.04);
      lambdaA *= (0.96 + spiA*0.04);
    }

    // Zero Bias: smoothing and OU calibration
    if(zeroBiasOn){
      const prev = (window._qpe_last && window._qpe_last.meta)? {h: safeNum(window._qpe_last.meta.lambdaH, lambdaH), a: safeNum(window._qpe_last.meta.lambdaA, lambdaA)} : null;
      if(prev){ lambdaH = lambdaSmoothing(prev.h, lambdaH, 0.70); lambdaA = lambdaSmoothing(prev.a, lambdaA, 0.70); }
      const [adjH, adjA] = ouCalibrationLambda(lambdaH, lambdaA, marketOU || 2.5, 0.18);
      lambdaH = adjH; lambdaA = adjA;
    }

    // Bayesian: build param or point
    let lambdaH_param = lambdaH, lambdaA_param = lambdaA;
    if(bayesOn){
      const priors = loadBayesPriors();
      const ph_prior = priors[h.name] || initTeamPrior(h.name, leagueGPG);
      const pa_prior = priors[a.name] || initTeamPrior(a.name, leagueGPG);
      const pt_mu_h = Math.log(Math.max(1e-3, lambdaH));
      const pt_mu_a = Math.log(Math.max(1e-3, lambdaA));
      const weight_h = 1 / (1 + Math.sqrt(ph_prior.n || 0) * 0.25);
      const weight_a = 1 / (1 + Math.sqrt(pa_prior.n || 0) * 0.25);
      const combined_mu_h = ph_prior.mu * (1 - weight_h) + pt_mu_h * weight_h;
      const combined_mu_a = pa_prior.mu * (1 - weight_a) + pt_mu_a * weight_a;
      let combined_sigma_h = Math.max(0.12, ph_prior.sigma * (0.92 + 0.08*weight_h));
      let combined_sigma_a = Math.max(0.12, pa_prior.sigma * (0.92 + 0.08*weight_a));
      if(zeroBiasOn){ combined_sigma_h = zeroBiasSigmaNormalize(combined_sigma_h); combined_sigma_a = zeroBiasSigmaNormalize(combined_sigma_a); }
      lambdaH_param = { mu: combined_mu_h, sigma: combined_sigma_h };
      lambdaA_param = { mu: combined_mu_a, sigma: combined_sigma_a };
    }

    // Monte Carlo runs (split)
    const half = Math.floor(mcIters/2);
    const simA = runWorkerSim(lambdaH_param, lambdaA_param, half, marketOU, bayesOn);
    const simB = runWorkerSim(lambdaA_param, lambdaH_param, mcIters-half, marketOU, bayesOn);
    const [outA, outB] = await Promise.all([simA, simB]);

    const neutral = { home: (outA.home + outB.away)/2, draw: (outA.draw + outB.draw)/2, away: (outA.away + outB.home)/2, over: (outA.over+outB.over)/2, under: (outA.under+outB.under)/2 };
    const sk = skellamOutcome(bayesOn? Math.exp(lambdaH_param.mu) : lambdaH, bayesOn? Math.exp(lambdaA_param.mu) : lambdaA, 12);
    const eloLog = logisticEloProb(h.elo, a.elo);
    const blended = { home: clamp(neutral.home*0.55 + sk.home*0.30 + eloLog.home*0.15,0,1), draw: clamp(neutral.draw*0.55 + sk.draw*0.30 + eloLog.draw*0.15,0,1), away: clamp(neutral.away*0.55 + sk.away*0.30 + eloLog.away*0.15,0,1), over: neutral.over, under: neutral.under };
    let ssum = blended.home + blended.draw + blended.away;
    let finalProbs = ssum>0 ? { home: blended.home/ssum, draw: blended.draw/ssum, away: blended.away/ssum, over: blended.over, under: blended.under } : {home:0.33,draw:0.34,away:0.33, over:blended.over, under:blended.under};

    // Zero-bias: stabilize draw & under softly
    if(zeroBiasOn){
      finalProbs.under *= 1.12;
      finalProbs.draw *= 1.06;
      const sumHDA = finalProbs.home + finalProbs.draw + finalProbs.away;
      finalProbs.home /= sumHDA; finalProbs.draw /= sumHDA; finalProbs.away /= sumHDA;
    }

    // confidence
    const hist = JSON.parse(localStorage.getItem(HIST_KEY) || "[]");
    let pastErr = 0;
    if(hist.length>0){
      const last20 = hist.slice(-20);
      const errs = last20.map(it => Math.abs((it.real_total_goals||0) - ((it.meta.lambdaH||0)+(it.meta.lambdaA||0))));
      pastErr = errs.reduce((s,x)=>s+x,0)/Math.max(1,errs.length);
      pastErr = clamp(pastErr/3,0,1);
    }
    let confidence = computeConfidence(finalProbs, bayesOn? Math.exp(lambdaH_param.mu) : lambdaH, bayesOn? Math.exp(lambdaA_param.mu) : lambdaA, trapIndex, pastErr);
    // ou bias adjust on confidence
    let ouBiasFactor = 1.0;
    if(oddsOver !== null && oddsUnder !== null){
      const impOver = 1 / Math.max(0.01, oddsOver);
      const impUnder = 1 / Math.max(0.01, oddsUnder);
      const rel = (impOver / (impOver + impUnder));
      const biasStrength = Math.abs(rel - 0.5) * 2;
      ouBiasFactor = clamp(1 - biasStrength * 0.18, 0.72, 1.0);
    }
    let ouLinePenalty = 1.0;
    if(Math.abs(marketOU - 2.5) > 0.4) ouLinePenalty = clamp(1 - Math.min(Math.abs(marketOU - 2.5)*0.04,0.18), 0.82, 1.0);
    confidence *= h_en.di * a_en.di;
    confidence *= ouBiasFactor * ouLinePenalty;
    confidence = clamp(confidence, 0, 1);

    // assemble result
    const attackH = rnd(h_xg,3), attackA = rnd(a_xg,3), defenseH = rnd(h_dsi_adj,3), defenseA = rnd(a_dsi_adj,3);
    const result = {
      meta:{ mode: comp, matchType, leagueGPG, confidence: rnd(confidence,3), trapIndex: rnd(trapIndex,3), lambdaH: rnd(bayesOn? Math.exp(lambdaH_param.mu) : lambdaH,4), lambdaA: rnd(bayesOn? Math.exp(lambdaA_param.mu) : lambdaA,4), mcIters: mcIters, zeroBias: !!zeroBiasOn, parkirBusSignal: rnd(pbSignal,3), eliteOn: !!eliteOn },
      inputs:{ home: h, away: a },
      core:{ h_xg: rnd(h_xg,3), a_xg: rnd(a_xg,3), h_dsi: rnd(h_dsi,3), a_dsi: rnd(a_dsi,3), h_fei: rnd(h_fei,3), a_fei: rnd(a_fei,3) },
      enhanced:{ home: h_en, away: a_en },
      attack_strength:{ home: attackH, away: attackA },
      defense_strength:{ home: defenseH, away: defenseA },
      probabilities: finalProbs,
      topScores: Object.entries(Object.assign({}, outA.scores, outB.scores)).map(e=>({score:e[0],prob:(((outA.scores[e[0]]||0)+(outB.scores[e[0]]||0))/2)})).sort((x,y)=>y.prob-x.prob).slice(0,12)
    };

    if(bayesOn){
      const priorsNow = loadBayesPriors();
      const homePrior = priorsNow[h.name] || initTeamPrior(h.name, leagueGPG);
      const awayPrior = priorsNow[a.name] || initTeamPrior(a.name, leagueGPG);
      result.posterior = { home_prior: homePrior, away_prior: awayPrior };
      const ciHome = lognormStats(homePrior.mu, homePrior.sigma);
      const ciAway = lognormStats(awayPrior.mu, awayPrior.sigma);
      result.posterior.home_stats = {mean: rnd(ciHome.mean,3), sd: rnd(ciHome.sd,3)};
      result.posterior.away_stats = {mean: rnd(ciAway.mean,3), sd: rnd(ciAway.sd,3)};
    }

    try{ const arr = JSON.parse(localStorage.getItem(HIST_KEY) || "[]"); arr.push(Object.assign({time:(new Date()).toISOString()}, result)); if(arr.length>2000) arr.splice(0, arr.length-2000); localStorage.setItem(HIST_KEY, JSON.stringify(arr)); }catch(e){}

    document.getElementById('summary').innerHTML = `<strong>${h.name||'HOME'}</strong> vs <strong>${a.name||'AWAY'}</strong> — ${comp} · ${matchType}<br/>
      Prob H/D/A: <strong>${(finalProbs.home*100).toFixed(1)}%</strong> / <strong>${(finalProbs.draw*100).toFixed(1)}%</strong> / <strong>${(finalProbs.away*100).toFixed(1)}%</strong><br/>
      Over ${(finalProbs.over*100).toFixed(1)}% • Under ${(finalProbs.under*100).toFixed(1)}%<br/>
      Confidence: <strong>${(result.meta.confidence*100).toFixed(1)}%</strong> • Trap: ${result.meta.trapIndex} • PB:${result.meta.parkirBusSignal} • ELITE:${result.meta.eliteOn}`;
    document.getElementById('resultText').textContent = JSON.stringify(result, null, 2);
    drawRadar(attackH, clamp(1/(h_dsi_adj||1),0,2), attackA, clamp(1/(a_dsi_adj||1),0,2));
    drawTrend(JSON.parse(localStorage.getItem(HIST_KEY) || "[]"));
    const confEl=document.getElementById('confMeter'); confEl.innerHTML=`<div style="padding:6px;border-radius:6px;background:rgba(255,255,255,0.03)">Confidence: <strong>${(result.meta.confidence*100).toFixed(1)}%</strong></div>`;
    confEl.style.color = result.meta.confidence>0.66? '#10b981' : result.meta.confidence>0.4? '#f59e0b' : '#fb7185';
    window._qpe_last = result;
    showToast('Analisis selesai');
  }catch(err){ console.error('Analyze error:', err); showToast('Terjadi error saat analisis (lihat console)',3000); }
});

/* ================= Buttons & Shortcuts ================= */
document.getElementById('autoCalcStats').addEventListener('click', ()=>{ autoConv('h'); autoConv('a'); autoShotsC('h'); autoShotsC('a'); autoCross('h'); autoCross('a'); autoPAF('h'); autoPAF('a'); showToast('Auto Assist: Conv%, ShotsC, Cross%, PAF diisi'); });
document.getElementById('autoEnhancedBtn').addEventListener('click', ()=>{ const hE=computeEnhancedFor('h'); const aE=computeEnhancedFor('a'); window._qpe_enh={home:hE,away:aE}; showToast('Enhanced computed'); document.getElementById('resultText').textContent = JSON.stringify({home:hE,away:aE},null,2); });
document.getElementById('autoOddsBtn').addEventListener('click', ()=> showToast('Auto Odds: placeholder — masukkan odds manual jika ada'));
document.getElementById('manualCalcBtn').addEventListener('click', ()=> showToast('Klik Analisis setelah koreksi input'));
document.getElementById('exportBtn').addEventListener('click', ()=> {
  const arr = JSON.parse(localStorage.getItem(HIST_KEY) || "[]");
  if(!arr.length){ showToast('History kosong'); return; }
  const rows=[['time','mode','home','away','p_home','p_draw','p_away','confidence','lambdaH','lambdaA','pbSignal','elite']];
  arr.forEach(it=> rows.push([it.time, it.meta.mode || '', it.inputs.home.name || '', it.inputs.away.name || '', it.probabilities.home, it.probabilities.draw, it.probabilities.away, it.meta.confidence, it.meta.lambdaH, it.meta.lambdaA, it.meta.parkirBusSignal, it.meta.eliteOn]));
  const csv = rows.map(r=> r.map(c=> typeof c==='string'? ('"'+c.replace(/"/g,'""')+'"') : c).join(',')).join('\n');
  const blob = new Blob([csv],{type:'text/csv'}); const url = URL.createObjectURL(blob); const ael=document.createElement('a'); ael.href=url; ael.download='qpe_v20_3_3_history.csv'; document.body.appendChild(ael); ael.click(); ael.remove(); URL.revokeObjectURL(url); showToast('Export CSV dibuat');
});
document.getElementById('viewHistory').addEventListener('click', ()=>{ const hist = JSON.parse(localStorage.getItem(HIST_KEY) || '[]'); if(!hist.length){ showToast('History kosong'); return; } document.getElementById('resultText').textContent = JSON.stringify(hist.slice(-200), null, 2); showToast('History ditampilkan'); });
document.getElementById('resetBtn').addEventListener('click', ()=>{ if(!confirm('Reset semua input?')) return; const elems=document.querySelectorAll('input,select'); elems.forEach(e=>{ if(e.id){ if(e.tagName==='INPUT'){ if(e.type==='checkbox') e.checked=false; else e.value=''; } if(e.tagName==='SELECT') e.selectedIndex=0; } }); localStorage.removeItem(INPUT_SAVE_KEY); showToast('Input dikosongkan'); });
document.getElementById('inputRealBtn').addEventListener('click', inputRealScoreDialog);
document.addEventListener('keydown',(e)=>{ if(e.ctrlKey && e.key==='s'){ e.preventDefault(); inputRealScoreDialog(); } if(e.ctrlKey && e.key==='e'){ e.preventDefault(); document.getElementById('exportBtn').click(); } if(e.ctrlKey && e.key==='m'){ e.preventDefault(); document.getElementById('toggleModeBtn').click(); } });

/* ================= Input real & calibration ================= */
function inputRealScoreDialog(){
  const h = prompt('Gol Home (angka):',''); const a = prompt('Gol Away (angka):','');
  if(h===null || a===null) return;
  const hist = JSON.parse(localStorage.getItem(HIST_KEY) || '[]');
  if(!hist.length){ showToast('Belum ada prediksi tersimpan'); return; }
  const last = hist[hist.length-1];
  last.real_home = Number(h); last.real_away = Number(a); last.real_total_goals = last.real_home + last.real_away;
  hist[hist.length-1] = last; localStorage.setItem(HIST_KEY, JSON.stringify(hist));
  try{
    const leagueGPG = safeNum(document.getElementById('league_gpg').value, 2.6);
    updateTeamPosterior(last.inputs.home.name || 'HOME', last.real_home, 1, leagueGPG);
    updateTeamPosterior(last.inputs.away.name || 'AWAY', last.real_away, 1, leagueGPG);
  }catch(e){ console.warn('Bayes update fail', e); }
  autoCalibrate();
  showToast('Skor tersimpan & kalibrasi diperbarui');
}
function autoCalibrate(){ try{ const hist = JSON.parse(localStorage.getItem(HIST_KEY) || "[]"); if(hist.length < 6) return; const last = hist.slice(-50); const errors = last.map(x=>Math.abs((x.real_total_goals||0) - ((x.meta.lambdaH||0) + (x.meta.lambdaA||0)))); const avgErr = errors.reduce((s,v)=>s+v,0)/errors.length || 0; const adj = clamp(1 - avgErr*0.05, 0.85, 1.15); localStorage.setItem('qpe_v20_auto_adj', adj); console.log('Auto calibration adj ×'+adj); }catch(e){ console.warn('Auto-calibrate fail', e); } }

/* ================= Toggle & UI niceties ================= */
let analystMode=true;
document.getElementById('toggleModeBtn').addEventListener('click', ()=>{ analystMode=!analystMode; document.getElementById('radarCanvas').parentElement.parentElement.style.display = analystMode ? 'block' : 'none'; document.getElementById('trendCanvas').parentElement.parentElement.style.display = analystMode ? 'block' : 'none'; document.getElementById('resultText').style.display = analystMode ? 'block' : 'none'; document.getElementById('toggleModeBtn').textContent = analystMode ? 'Analyst Mode' : 'Compact Mode'; });
['h_gpg','h_gc','h_shots','h_sot','h_conv','h_poss','h_shotsC','h_cr','h_paf'].forEach(id=>{ const el=document.getElementById(id); if(!el) return; el.addEventListener('mouseenter', ()=> showToast(el.getAttribute('title') || id + ' — isi dari SofaScore jika ada',900)); });

/* ================= Maintenance & load ================= */
function updateLeagueLearning(){ try{ const hist = JSON.parse(localStorage.getItem(HIST_KEY) || "[]"); if(hist.length < 10) return; const last = hist.slice(-60); const goals = last.map(x=>x.real_total_goals).filter(v=>typeof v==='number' && v>0); if(goals.length < 5) return; const avg = goals.reduce((s,v)=>s+v,0)/goals.length; const current = safeNum(document.getElementById('league_gpg').value,2.6); if(Math.abs(avg-current) > 0.12){ document.getElementById('league_gpg').value = rnd((avg*0.7 + current*0.3),2); showToast('League GPG auto-update: ' + rnd(avg,2)); } }catch(e){} }
setInterval(updateLeagueLearning,18000);

setInterval(()=>{ try{ const hist = JSON.parse(localStorage.getItem(HIST_KEY) || "[]"); if(hist.length>0) drawTrend(hist); }catch(e){} },20000);

function refreshInsightSummary(){ const data = window._qpe_last; if(!data || !data.meta) return; const conf = data.meta.confidence || 0; const t = data.meta.trapIndex || 1; const info = `λH ${data.meta.lambdaH.toFixed(2)} λA ${data.meta.lambdaA.toFixed(2)} | Trap ${t.toFixed(2)} | Conf ${(conf*100).toFixed(1)}%`; document.getElementById('confMeter').innerHTML = info; document.getElementById('confMeter').style.color = conf>0.66? '#10b981' : conf>0.4? '#f59e0b' : '#fb7185'; }
setInterval(refreshInsightSummary,7000);

/* ================= Load toast & resize ================= */
window.addEventListener('load', ()=>{ try{ const radar=document.getElementById('radarCanvas'), trend=document.getElementById('trendCanvas'); if(!radar||!trend) return; const resizeCanvas=(c,w,h)=>{c.width=w;c.height=h;}; const handleResize=()=>{ const w=Math.min(480,window.innerWidth-60); resizeCanvas(radar,Math.min(360,w),Math.min(360,w)); resizeCanvas(trend,w,200); drawTrend(JSON.parse(localStorage.getItem(HIST_KEY) || "[]")); }; handleResize(); window.addEventListener('resize',handleResize); showToast('v20.3.3 FINAL siap — Elite Penajam aktif',1600); }catch(e){} });

window.addEventListener('beforeunload', ()=>{ try{ if(workerInstance) workerInstance.terminate(); if(workerUrl) URL.revokeObjectURL(workerUrl); }catch(e){} });
</script>

</body>
</html>
