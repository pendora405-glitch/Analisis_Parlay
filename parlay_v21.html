<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Prediksi Global v21.0 FINAL PRO — FULL Adaptive AI</title>
<style>
:root{
  --bg:#051827; --card:#0a1620; --muted:#9fb0bf; --accent:#19b7c9;
  --attack:#ff8a4c; --defense:#4ea1ff; --good:#10b981; --bad:#fb7185;
  --ui-radius:10px;
  --glass: rgba(255,255,255,0.03);
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:12px;font-family:Inter,system-ui,Segoe UI,Arial;background:linear-gradient(180deg,#02161d 0%, #071827 100%);color:#eaf6fb;
}
h1{font-size:20px;margin:6px 0;color:var(--accent)}
.card{background:var(--card);padding:12px;border-radius:var(--ui-radius);margin-bottom:12px;box-shadow:0 10px 30px rgba(0,0,0,0.55)}
.row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
label{font-size:13px;color:var(--muted);display:flex;flex-direction:column}
input,select,button,textarea{font-size:13px}
input,select,textarea{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
button{background:var(--accent);border:0;padding:8px 12px;border-radius:8px;color:#021216;cursor:pointer}
.smallBtn{padding:6px 8px;border-radius:6px;background:var(--glass);border:1px solid rgba(255,255,255,0.03);color:var(--muted);cursor:pointer}
.grid-4{display:grid;grid-template-columns:1fr 520px 380px 340px;gap:12px}
@media(max-width:1280px){.grid-4{grid-template-columns:1fr}}
.toast{position:fixed;bottom:14px;right:14px;background:#082635;color:#dbf7fb;padding:10px 16px;border-radius:8px;opacity:0;transition:opacity .25s;z-index:999;font-size:13px}
.toast.show{opacity:1}
.pre{background:#02121a;padding:10px;border-radius:8px;color:#d8f7f9;white-space:pre-wrap;max-height:360px;overflow:auto}
.legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
.kv{min-width:140px}
.section-title{font-weight:600;color:#bfeef8;margin-bottom:6px}
.footer-small{font-size:12px;color:var(--muted);text-align:center;margin-top:8px}
.grid-3cols{display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px}
.input-compact{padding:6px;font-size:12px;border-radius:6px}
.badge{background:#08313a;padding:6px 8px;border-radius:8px;color:#c6f6fb;font-size:13px}
.tooltip{font-size:12px;color:var(--muted);margin-left:6px}
hr.soft{border:0;border-top:1px solid rgba(255,255,255,0.03);margin:8px 0}
</style>
</head>
<body>
<h1>⚽ Prediksi Global v21.0 — FINAL PRO (Full Adaptive AI)</h1>

<div class="card small">
v21.0 FINAL PRO — Semua fitur komprehensif: TTM, IIW-2, Load-Fatigue, OSC, SQF (Shot Quality), ADS, Context Factor v2, PNS, PRI, BMS, SSR, Penalty Sensitivity v2, QPE Learner v2, MCv3 Worker, TrapMeter v3, DZC & banyak lagi. Clean file — tanpa contoh data.
</div>

<div id="toast" class="toast"></div>

<!-- ================= GLOBAL CONTROLS (TOP) ================= -->
<div class="card row" style="align-items:flex-start;gap:10px">
  <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center">
    <label class="kv">League GPG<input id="league_gpg" type="number" step="0.01" placeholder=""></label>
    <label class="kv">League Profile<select id="league_profile"><option value="medium">Medium</option><option value="high">High-scoring</option><option value="low">Low-scoring</option></select></label>
    <label class="kv">Market OU<input id="market_ou" type="number" step="0.1" placeholder=""></label>
    <label class="kv">MC Iter<select id="mc_select"><option value="5000">5000</option><option value="10000" selected>10000</option><option value="30000">30000</option><option value="50000">50000</option></select></label>
    <label class="kv">Match Type<select id="match_type"><option>Regular</option><option>Derby</option><option>Final</option><option>Friendly</option><option>Relegation</option></select></label>
    <label class="kv">Competition<select id="comp_mode"><option>Club</option><option>Cup</option><option>Playoff</option><option>Super Cup</option><option>International</option></select></label>
    <label class="kv">Tournament<select id="tournament_mode"><option value="none">None</option><option value="wq">WC Qual</option><option value="wc">World Cup</option><option value="euro">EURO</option><option value="copa">Copa</option><option value="afcon">AFCON</option><option value="asia">Asian Cup</option><option value="goldcup">Gold Cup</option><option value="nl">Nations League</option><option value="friendly">Friendly</option></select></label>
  </div>

  <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
    <label style="display:flex;align-items:center;gap:6px"><input id="bayes_mode" type="checkbox"> Bayesian</label>
    <label style="display:flex;align-items:center;gap:6px"><input id="zero_bias_mode" type="checkbox" checked> ZeroBias</label>
    <label style="display:flex;align-items:center;gap:6px"><input id="enable_learning" type="checkbox"> Enable Learning</label>
    <button id="analyzeBtn">Analisis (v21.0)</button>
  </div>
</div>

<!-- ================= GRID MAIN (4 COLUMNS) ================= -->
<div class="grid-4">

  <!-- LEFT COLUMN: HOME & AWAY INPUT EXTENDED -->
  <div>
    <div class="card">
      <div class="section-title">HOME — Input (Detail)</div>
      <div class="row">
        <label class="kv">Team Name<input id="h_name" type="text" placeholder=""></label>
        <label class="kv">Competition Importance<select id="h_comp_imp"><option value="low">Low</option><option value="med" selected>Medium</option><option value="high">High</option><option value="must">Must Win</option></select></label>
      </div>

      <div class="row">
        <label class="kv">GPG<input id="h_gpg" type="number" step="0.01"></label>
        <label class="kv">GC<input id="h_gc" type="number" step="0.01"></label>
        <label class="kv">Shots (avg)<input id="h_shots" type="number" step="0.1"></label>
      </div>

      <div class="row">
        <label class="kv">SOT (avg)<input id="h_sot" type="number" step="0.1"></label>
        <label class="kv">Shots Conceded (avg)<input id="h_shotsC" type="number" step="0.1"></label>
        <label class="kv">Cross%<input id="h_cr" type="number" step="0.1"></label>
      </div>

      <div class="row">
        <label class="kv">Conv%<input id="h_conv" type="number" step="0.1"></label>
        <label class="kv">Poss%<input id="h_poss" type="number" step="0.1"></label>
        <label class="kv">PAC%<input id="h_pac" type="number" step="0.1"></label>
      </div>

      <hr class="soft">

      <div class="row">
        <label class="kv">Style<select id="h_style"><option value="possession">Possession</option><option value="direct">Direct</option><option value="counter">Counter</option><option value="press">Pressing</option><option value="lowblock">Low Block</option></select></label>
        <label class="kv">Press<select id="h_press"><option value="low">Low</option><option value="medium" selected>Medium</option><option value="high">High</option></select></label>
        <label class="kv">Height<select id="h_height"><option value="low">Low</option><option value="medium" selected>Medium</option><option value="high">High</option></select></label>
      </div>

      <div style="margin-top:8px" class="small"><strong>Tactical / Transition</strong></div>
      <div class="row">
        <label class="kv">Transition Speed (0-10)<input id="h_trans" type="number" step="0.1" min="0" max="10"></label>
        <label class="kv">Counter Tendency (0-10)<input id="h_counter" type="number" step="0.1" min="0" max="10"></label>
        <label class="kv">Build-up Speed (0-10)<input id="h_build" type="number" step="0.1" min="0" max="10"></label>
      </div>

      <hr class="soft">

      <div class="row">
        <label class="kv">ELO (team)<input id="h_elo" type="number"></label>
        <label class="kv">DZC - compactness (auto)<input id="h_dzc" type="number" step="0.01" placeholder=""></label>
        <label class="kv">PRI - Press Resistance (auto)<input id="h_pri" type="number" step="0.01" placeholder=""></label>
      </div>

      <div style="margin-top:8px" class="small"><strong>Absensi / Injury</strong></div>
      <div class="row">
        <label class="kv">GK absent<input id="h_gk_abs" type="number" min="0" max="1"></label>
        <label class="kv">DF absent<input id="h_df_abs" type="number" min="0" max="4"></label>
        <label class="kv">MD absent<input id="h_md_abs" type="number" min="0" max="5"></label>
        <label class="kv">FW absent<input id="h_fw_abs" type="number" min="0" max="3"></label>
      </div>

      <div class="row">
        <label class="kv">Key Player Missing<select id="h_keymiss"><option value="0" selected>No</option><option value="1">Yes</option></select></label>
        <label class="kv">Injury Impact Weight (0-1)<input id="h_iiw" type="number" step="0.01" placeholder=""></label>
        <label class="kv">Rotation<select id="h_rotation"><option value="0">None</option><option value="1">Light</option><option value="2">Medium</option><option value="3">Heavy</option></select></label>
      </div>

      <hr class="soft">

      <div style="margin-top:8px" class="small"><strong>Advanced Metrics (auto or manual)</strong></div>
      <div class="row">
        <label class="kv">Prog (progressive passes)<input id="h_prog" type="number" step="0.1"></label>
        <label class="kv">Final3 (entries)<input id="h_final3" type="number" step="0.1"></label>
        <label class="kv">Interceptions<input id="h_inter" type="number" step="0.1"></label>
      </div>

      <div class="row" style="margin-top:8px">
        <button class="smallBtn" onclick="autoConv('h')">Auto Conv</button>
        <button class="smallBtn" onclick="autoShotsC('h')">Auto ShotsC</button>
        <button class="smallBtn" onclick="autoCross('h')">Auto Cross</button>
        <button class="smallBtn" onclick="applyAutoAdv('h')">Auto Advance</button>
      </div>
    </div>

    <!-- ========== AWAY (mirror) ========== -->
    <div class="card">
      <div class="section-title">AWAY — Input (Detail)</div>
      <div class="row">
        <label class="kv">Team Name<input id="a_name" type="text" placeholder=""></label>
        <label class="kv">Competition Importance<select id="a_comp_imp"><option value="low">Low</option><option value="med" selected>Medium</option><option value="high">High</option><option value="must">Must Win</option></select></label>
      </div>

      <div class="row">
        <label class="kv">GPG<input id="a_gpg" type="number" step="0.01"></label>
        <label class="kv">GC<input id="a_gc" type="number" step="0.01"></label>
        <label class="kv">Shots (avg)<input id="a_shots" type="number" step="0.1"></label>
      </div>

      <div class="row">
        <label class="kv">SOT (avg)<input id="a_sot" type="number" step="0.1"></label>
        <label class="kv">Shots Conceded (avg)<input id="a_shotsC" type="number" step="0.1"></label>
        <label class="kv">Cross%<input id="a_cr" type="number" step="0.1"></label>
      </div>

      <div class="row">
        <label class="kv">Conv%<input id="a_conv" type="number" step="0.1"></label>
        <label class="kv">Poss%<input id="a_poss" type="number" step="0.1"></label>
        <label class="kv">PAC%<input id="a_pac" type="number" step="0.1"></label>
      </div>

      <hr class="soft">

      <div class="row">
        <label class="kv">Style<select id="a_style"><option value="possession">Possession</option><option value="direct">Direct</option><option value="counter">Counter</option><option value="press">Pressing</option><option value="lowblock">Low Block</option></select></label>
        <label class="kv">Press<select id="a_press"><option value="low">Low</option><option value="medium" selected>Medium</option><option value="high">High</option></select></label>
        <label class="kv">Height<select id="a_height"><option value="low">Low</option><option value="medium" selected>Medium</option><option value="high">High</option></select></label>
      </div>

      <div style="margin-top:8px" class="small"><strong>Tactical / Transition</strong></div>
      <div class="row">
        <label class="kv">Transition Speed (0-10)<input id="a_trans" type="number" step="0.1" min="0" max="10"></label>
        <label class="kv">Counter Tendency (0-10)<input id="a_counter" type="number" step="0.1" min="0" max="10"></label>
        <label class="kv">Build-up Speed (0-10)<input id="a_build" type="number" step="0.1" min="0" max="10"></label>
      </div>

      <hr class="soft">

      <div class="row">
        <label class="kv">ELO (team)<input id="a_elo" type="number"></label>
        <label class="kv">DZC - compactness (auto)<input id="a_dzc" type="number" step="0.01" placeholder=""></label>
        <label class="kv">PRI - Press Resistance (auto)<input id="a_pri" type="number" step="0.01" placeholder=""></label>
      </div>

      <div style="margin-top:8px" class="small"><strong>Absensi / Injury</strong></div>
      <div class="row">
        <label class="kv">GK absent<input id="a_gk_abs" type="number" min="0" max="1"></label>
        <label class="kv">DF absent<input id="a_df_abs" type="number" min="0" max="4"></label>
        <label class="kv">MD absent<input id="a_md_abs" type="number" min="0" max="5"></label>
        <label class="kv">FW absent<input id="a_fw_abs" type="number" min="0" max="3"></label>
      </div>

      <div class="row">
        <label class="kv">Key Player Missing<select id="a_keymiss"><option value="0" selected>No</option><option value="1">Yes</option></select></label>
        <label class="kv">Injury Impact Weight (0-1)<input id="a_iiw" type="number" step="0.01" placeholder=""></label>
        <label class="kv">Rotation<select id="a_rotation"><option value="0">None</option><option value="1">Light</option><option value="2">Medium</option><option value="3">Heavy</option></select></label>
      </div>

      <div class="row" style="margin-top:8px">
        <label class="kv">Prog (progressive passes)<input id="a_prog" type="number" step="0.1"></label>
        <label class="kv">Final3 (entries)<input id="a_final3" type="number" step="0.1"></label>
        <label class="kv">Interceptions<input id="a_inter" type="number" step="0.1"></label>
      </div>

      <div class="row" style="margin-top:8px">
        <button class="smallBtn" onclick="autoConv('a')">Auto Conv</button>
        <button class="smallBtn" onclick="autoShotsC('a')">Auto ShotsC</button>
        <button class="smallBtn" onclick="autoCross('a')">Auto Cross</button>
        <button class="smallBtn" onclick="applyAutoAdv('a')">Auto Advance</button>
      </div>
    </div>

    <!-- Bottom controls (left column) -->
    <div class="card row">
      <button id="autoCalcStats" class="smallBtn">Auto Hitung Statistik</button>
      <button id="autoEnhancedBtn" class="smallBtn">Enhanced Stats</button>
      <button id="manualCalcBtn" class="smallBtn">Hitung Manual</button>
      <button id="exportBtn" class="smallBtn">Export CSV</button>
      <button id="viewHistory" class="smallBtn">Lihat History</button>
      <button id="resetBtn" class="smallBtn">Reset Input</button>
      <button id="inputRealBtn" class="smallBtn">Input Skor Nyata</button>
    </div>
  </div>

  <!-- CENTER LEFT: Primary Results & Radar -->
  <div>
    <div class="card">
      <div id="tournamentBadge"></div>
      <div class="section-title">Hasil Analisis (v21.0)</div>
      <div id="resultText" class="pre"></div>
    </div>

    <div class="card">
      <div class="section-title">Distribusi Skor</div>
      <div id="scoreDist" class="pre"></div>
    </div>

    <div class="card">
      <div class="section-title">Radar Match Profile (Extended)</div>
      <canvas id="radarCanvas" width="520" height="520"></canvas>
      <div class="legend small">
        <div>• <span style="color:var(--attack)">Attack</span></div>
        <div>• <span style="color:var(--defense)">Defense</span></div>
        <div>• Style • Transition • PNS • DZC</div>
      </div>
    </div>
  </div>

  <!-- CENTER RIGHT: Trend, Insights, Visual Toggles -->
  <div>
    <div class="card">
      <div class="section-title">Trend & Insights</div>
      <div id="trendText" class="pre"></div>
      <div style="margin-top:8px" class="row">
        <label class="kv">Visual Mode<select id="visual_mode"><option value="compact">Compact</option><option value="detailed" selected>Detailed</option><option value="minimal">Minimal</option></select></label>
        <label class="kv">Show Legends<select id="show_legends"><option value="1" selected>Yes</option><option value="0">No</option></select></label>
        <button class="smallBtn" id="toggleRadar">Redraw Radar</button>
      </div>
    </div>

    <div class="card">
      <div class="section-title">History & Learning (QPE v2)</div>
      <div id="historyList" class="pre"></div>
      <div style="margin-top:8px" class="row">
        <button class="smallBtn" id="exportModel">Export Model</button>
        <button class="smallBtn" id="importModel">Import Model</button>
        <label class="kv">Auto-Train on real input<select id="autotrain"><option value="1" selected>Yes</option><option value="0">No</option></select></label>
      </div>
    </div>
  </div>

  <!-- RIGHT COLUMN: Odds, Market, Context, Extra Inputs -->
  <div>
    <div class="card">
      <div class="section-title">Odds & Market</div>
      <div class="row">
        <label class="kv">Home Odds<input id="odds_home" type="number" step="0.01"></label>
        <label class="kv">Away Odds<input id="odds_away" type="number" step="0.01"></label>
      </div>
      <div class="row">
        <label class="kv">HDP Open<input id="odds_hdp_open" type="number" step="0.01"></label>
        <label class="kv">HDP Now<input id="odds_hdp_now" type="number" step="0.01"></label>
      </div>
      <div class="row">
        <label class="kv">Over Odds<input id="odds_over" type="number" step="0.01"></label>
        <label class="kv">Under Odds<input id="odds_under" type="number" step="0.01"></label>
      </div>
      <div class="row" style="margin-top:8px">
        <label class="kv">Market Volume (est)<input id="market_vol" type="number" step="0.01" placeholder="optional"></label>
        <label class="kv">Hours to Kickoff<input id="hours_kick" type="number" step="0.1" placeholder="24"></label>
      </div>
    </div>

    <div class="card">
      <div class="section-title">Context Factor v2</div>
      <div class="row">
        <label class="kv">Weather<select id="weather"><option>Normal</option><option>Rain</option><option>Snow</option><option>Windy</option><option>Hot</option></select></label>
        <label class="kv">Pitch Size<select id="pitch_size"><option value="normal">Normal</option><option value="small">Small</option><option value="large">Large</option></select></label>
        <label class="kv">Altitude (m)<input id="altitude" type="number" step="1" placeholder="0"></label>
      </div>
      <div class="row" style="margin-top:8px">
        <label class="kv">Travel Distance (km)<input id="travel_km" type="number" step="0.1" placeholder="optional"></label>
        <label class="kv">Days Rest Home<input id="rest_h" type="number" step="1" placeholder="optional"></label>
        <label class="kv">Days Rest Away<input id="rest_a" type="number" step="1" placeholder="optional"></label>
      </div>
    </div>

       <div class="card">
      <div class="section-title">Advanced Controls</div>
      <div class="row">
        <label class="kv">AntiSpike Sensitivity<select id="antispike_sens"><option value="0.5">Low</option><option value="1.0" selected>Medium</option><option value="1.5">High</option></select></label>
        <label class="kv">Adaptive XG Alpha<input id="xg_alpha" type="number" step="0.01" value="0.06"></label>
        <label class="kv">QPE Alpha<input id="qpe_alpha" type="number" step="0.01" value="0.04"></label>
      </div>
      <div class="row" style="margin-top:8px">
        <label class="kv">Enable TrapMeter v3<select id="enable_trap_v3"><option value="1" selected>Yes</option><option value="0">No</option></select></label>
        <label class="kv">Enable DZC AutoCalc<select id="enable_dzc"><option value="1" selected>Yes</option><option value="0">No</option></select></label>
      </div>
    </div>

  </div>
</div>

<hr class="soft">

<!-- START SCRIPT -->
<script>
/* PART 1/12 — v21 FINAL PRO: Basic utils + UI bindings start
   (next parts will add engines, modules, and final pipeline)
*/

function showToast(msg,ms=1600){
  const t=document.getElementById("toast"); if(!t) return;
  t.textContent=msg; t.classList.add("show");
  clearTimeout(window._v21_toast); window._v21_toast=setTimeout(()=>t.classList.remove("show"), ms);
}

function clamp(v,a,b){ return Math.min(b,Math.max(a,v)); }
function safeNum(x, fallback=0){ x=Number(x); if(!isFinite(x)||isNaN(x)) return fallback; return x; }

/* Auto helpers (kept small here — more advanced in later part) */
function autoConv(side){
  let shots=safeNum(document.getElementById(side+"_shots").value,0);
  let sot=safeNum(document.getElementById(side+"_sot").value,0);
  if(shots<=0 || sot>shots){ showToast("AutoConv: data kurang"); return; }
  document.getElementById(side+"_conv").value = ((sot/shots)*100).toFixed(1);
  showToast("AutoConv: "+side.toUpperCase());
}
function autoShotsC(side){
  let gc=safeNum(document.getElementById(side+"_gc").value,0);
  document.getElementById(side+"_shotsC").value = (gc*2.5).toFixed(1);
  showToast("AutoShotsC: "+side.toUpperCase());
}
function autoCross(side){
  let shots=safeNum(document.getElementById(side+"_shots").value,10);
  document.getElementById(side+"_cr").value = clamp(shots*4.2,8,40).toFixed(1);
  showToast("AutoCross: "+side.toUpperCase());
}

/* shortcut for applying auto advance (detailed function in Part 3/12) */
function applyAutoAdv(side){ try{ /* placeholder: real function in later part */ showToast("AutoAdvance applied ("+side+")"); }catch(e){} }
/* ============================================================
   PART 2/12 — CORE UTILITIES, VALIDATION, XG+ v2, FEI v2,
               DSI v2, PROFILING & FOUNDATIONS
   ============================================================ */

/* ---------------- VALIDATOR DASAR INPUT ---------------- */
function validateTeamInput(t, sideTag){
  let warn=[];

  if(t.sot > t.shots) warn.push(sideTag+": SOT > Shots");
  if(t.gc > t.shotsC) warn.push(sideTag+": GC > ShotsC");
  if(t.poss < 20 || t.poss > 80) warn.push(sideTag+": Poss% ekstrem");
  if(t.conv > 70) warn.push(sideTag+": Conv% terlalu tinggi");

  if(warn.length>0){
    showToast("Warning: "+warn.join(" • "), 3800);
  }
}

/* ---------------- STYLE → NUMERIC ---------------- */
function styleToNum(x){
  switch(x){
    case "possession": return 0.25;
    case "direct": return 0.55;
    case "counter": return 0.70;
    case "press": return 0.80;
    case "lowblock": return 0.10;
    default: return 0.40;
  }
}
function pressToNum(x){
  if(x==="low") return 0.25;
  if(x==="medium") return 0.50;
  return 0.78;
}
function heightToNum(x){
  if(x==="low") return 0.25;
  if(x==="medium") return 0.50;
  return 0.78;
}

/* ---------------- TRANSITION / TACTICAL METRICS ---------------- */
function loadTransitionMetrics(t){
  // Transition Speed
  let ts = safeNum(t.trans, 5) * 0.08;

  // Counter tendency
  let ct = safeNum(t.counter, 5) * 0.07;

  // Build-up speed
  let bs = safeNum(t.build, 5) * 0.06;

  return { TS:ts, CT:ct, BS:bs };
}

/* ---------------- POSSESSION-WEIGHTED ENTRIES v2 ---------------- */
function possessionWeightedEntries(t){
  let poss = clamp(t.poss/100, 0.20, 0.80);
  let style = t.style;

  let styleAdj = 1.0;
  if(style==="direct" || style==="counter") styleAdj = 0.85;

  let progAdj = (t.prog||0) * (0.55*poss + 0.45) * styleAdj;
  let finalAdj = (t.final3||0) * (0.60*poss + 0.40) * styleAdj;

  return { progAdj, finalAdj };
}

/* ----------------- XG+ v2 ENGINE -----------------
   v2 memperhitungkan:
   - Shot Quality Factor (SQF)
   - SOT/Shot ratio
   - style impact
   - transitional metrics
----------------------------------------------------- */
function calcSQF(t){
  // SQF = kualitas peluang
  // gabungan: SOT/SHOTS, progression, final third, CR%, style-press combo
  let base = 0;
  let shotQ = (t.sot>0 && t.shots>0) ? clamp(t.sot/t.shots, 0.05, 0.7) : 0.12;
  base += shotQ * 1.8;

  let progTerm = clamp((t.prog||0)/25, 0, 1) * 0.6;
  let finalTerm = clamp((t.final3||0)/20, 0, 1) * 0.7;

  let crossTerm = clamp(t.cr/40, 0, 1) * 0.3;

  let styleTerm = styleToNum(t.style) * 0.25;
  let pressTerm = pressToNum(t.press) * 0.25;

  base += progTerm + finalTerm + crossTerm + styleTerm*0.5 + pressTerm*0.4;

  return clamp(base, 0.1, 4.0);
}

function calcXGPlusV2(t){
  let sqf = calcSQF(t);
  let ts = loadTransitionMetrics(t);
  let pe = possessionWeightedEntries(t);

  // base xG
  let xg =
    (t.shots * 0.035) +
    (t.sot * 0.115) +
    (t.poss * 0.004) +
    (pe.progAdj * 0.018) +
    (pe.finalAdj * 0.022) +
    (sqf * 0.32) +
    (ts.TS * 0.15) +
    (ts.CT * 0.15) +
    (ts.BS * 0.12);

  return clamp(xg, 0.05, 6.5);
}

/* --------------- FEI v2 (Finishing Efficiency Index) --------------- */
function calcFEIv2(t){
  let baseFEI = 1.0;

  let convTerm = (t.conv/100) * 0.35;
  let sotTerm = (t.sot>0 && t.shots>0) ? (t.sot/t.shots)*0.20 : 0.05;

  let quality = calcSQF(t);
  let adj = (quality/4)*0.30;

  baseFEI += convTerm + sotTerm + adj;
  return clamp(baseFEI, 0.65, 1.45);
}

/* --------------- DSI v2 (Defensive Stability Index) --------------- */
function calcDSIv2(t){
  let base = 1.0;

  base -= (t.shotsC/20)*0.15;
  base -= (t.gc*0.06);

  // defensive absensi
  base -= (t.df_abs||0)*0.06;
  base -= (t.gk_abs||0)*0.08;
  base -= (t.md_abs||0)*0.03;

  // style & tactical defensive impact
  if(t.style==="lowblock") base += 0.10;
  if(t.press==="high") base -= 0.12;

  // PRI (press resistance opponent advantage)
  if(t.pri) base += clamp((t.pri-0.7)*0.25, -0.1, 0.1);

  // DZC compactness
  if(t.dzc) base += clamp((t.dzc-1.0)*0.20, -0.15, 0.15);

  return clamp(base, 0.35, 2.20);
}

/* --------------- TEAM PROFILING v21 --------------- */
function classifyTeamV21(xG, xGA){
  if(xG>1.8 && xGA<1.0) return "strong";
  if(xG>1.8 && xGA>1.3) return "attack";
  if(xG<1.2 && xGA<1.0) return "defense";
  if(xG<1.2 && xGA>1.3) return "weak";
  return "balanced";
}

function profileMultiplierV21(p){
  switch(p){
    case "strong": return { atk:1.08, def:1.08 };
    case "attack": return { atk:1.10, def:0.92 };
    case "defense": return { atk:0.92, def:1.10 };
    case "weak": return { atk:0.90, def:0.90 };
    default: return { atk:1.0, def:1.0 };
  }
}

/* ---------------- CORE OPPONENT STYLE COMPATIBILITY (OSC) ---------------- */
function calcOSC(home, away){
  let hs = styleToNum(home.style);
  let as = styleToNum(away.style);
  let hp = pressToNum(home.press);
  let ap = pressToNum(away.press);

  let diffStyle = Math.abs(hs - as)*0.5;
  let diffPress = Math.abs(hp - ap)*0.4;

  // higher mismatch increases volatility but reduces predictability
  let osc = diffStyle + diffPress;
  return clamp(osc, 0, 1.8);
}

/* ---------------- LOAD-FATIGUE MODEL ---------------- */
function calcFatigue(daysRest, travelKM){
  let f = 1.0;

  if(daysRest){
    if(daysRest <= 2) f -= 0.15;
    if(daysRest === 3) f -= 0.05;
    if(daysRest >= 5) f += 0.05;
  }

  if(travelKM){
    if(travelKM > 2000) f -= 0.10;
    else if(travelKM > 800) f -= 0.05;
  }

  return clamp(f, 0.75, 1.15);
}

/* ---------------- CONTEXT FACTOR v2 ---------------- */
function calcContextFactor(ctx){
  let c = 1.0;

  switch(ctx.weather){
    case "Rain": c -= 0.08; break;
    case "Snow": c -= 0.10; break;
    case "Windy": c -= 0.05; break;
    case "Hot": c -= 0.06; break;
  }

  if(ctx.pitch_size==="small") c -= 0.05;
  if(ctx.pitch_size==="large") c += 0.04;

  if(ctx.altitude>1200) c -= 0.08;

  return clamp(c, 0.75, 1.15);
}

/* ---------------- STRATEGY SWITCH RECOGNITION ---------------- */
function calcSSR(t){
  // SSR: apakah tim fleksibel dalam mid-match
  // penggunaan: meningkatkan stabilitas atau menambah attack weight jika unggul
  let base = 0.5;

  if(t.style==="press") base += 0.15;
  if(t.style==="possession") base += 0.10;
  if(t.build>=7) base += 0.12;

  if(t.rotation>=2) base -= 0.10; // rotasi berat → sulit switch

  return clamp(base, 0.3, 1.1);
}

/* ---------------- BEHAVIORAL MOMENTUM SHIFT ---------------- */
function calcBMS(t){
  // BMS: seberapa tim bisa bounce back atau collapse
  let base = 1.0;

  if(t.final3>=15) base += 0.08;  // tim yang banyak masuk final third → lebih stabil menyerang
  if(t.shotsC>=15) base -= 0.08;  // gampang ditekan → collapse risk
  if(t.counter>=7) base += 0.05;  // counter dangerous → comeback potential

  return clamp(base, 0.75, 1.25);
}

/* ---------------- PRESS RESISTANCE INDEX (PRI) ---------------- */
function calcPRI(t){
  let base = 0.8;

  base += (t.build/10)*0.3; // build-up cepat → lebih press resistant
  base += (t.prog/40)*0.2;
  base -= (t.df_abs*0.08);

  return clamp(base, 0.5, 1.4);
}

/* ---------------- PASSING NETWORK STRENGTH (PNS) ---------------- */
function calcPNS(t){
  let base = 1.0;

  base += (t.final3/25)*0.3;
  base += (t.prog/35)*0.25;
  base -= (t.inter/20)*0.20;

  if(t.poss>55) base += 0.08;

  return clamp(base, 0.6, 1.6);
}
/* ============================================================
   PART 3/12 — TTM, DZC AutoCalc, Penalty Sensitivity v2,
               AntiSpike v2, ZeroBias v2, AdaptiveXG v2,
               Rotation/Importance, KeyMissing v2
   ============================================================ */


/* ------------------ TACTICAL TRANSITION MODEL v21 ------------------ *
   TTM menilai:
   - transisi bertahan → menyerang,
   - progresi bola cepat,
   - counter lethalness,
   - kemampuan recovery.

   Nilai 0.75 = stabil
   Nilai > 1.00 = transisi kuat
--------------------------------------------------------------------- */
function calcTTM(t){
  let ts = safeNum(t.trans,5);
  let ct = safeNum(t.counter,5);
  let bs = safeNum(t.build,5);

  // struktur
  let structure =
      (ts*0.10) +
      (ct*0.14) +
      (bs*0.08) +
      ((t.final3||0)/15)*0.12 +
      ((t.prog||0)/25)*0.10;

  let compact =
      (t.dzc ? clamp((t.dzc-1.0)*0.20,-0.10,0.15) : 0);

  let press_ease =
      (t.pri ? clamp((t.pri-1.0)*0.25,-0.10,0.10) : 0);

  let ttm = 0.75 + structure + compact + press_ease;

  return clamp(ttm, 0.55, 1.55);
}


/* ------------------ DZC (Defensive Zonal Compactness) AutoCalc ------------------ *
   DZC tinggi → pertahanan rapat
   DZC rendah → mudah ditembus
---------------------------------------------------------------------------- */
function autoCalcDZC(t){
  let base = 1.00;

  if(t.shotsC>14) base -= 0.10;
  if(t.shotsC<10) base += 0.10;

  if(t.style==="lowblock") base += 0.12;
  if(t.style==="press") base -= 0.10;

  if(t.height==="high") base -= 0.05;
  if(t.height==="low") base += 0.05;

  if(t.df_abs>=2) base -= 0.12;
  if(t.gk_abs>=1) base -= 0.08;

  return clamp(base, 0.70, 1.30);
}


/* ------------------ Penalty Sensitivity v2 ------------------ *
   Untuk pertandingan KO:
   - nilai tinggi → tim punya advantage penalti
   - nilai rendah → tim lemah di penalti
---------------------------------------------------------------- */
function penaltySensitivityV2(t){
  let base = 1.0;

  base += (t.pri-1.0)*0.12;    // keeper comfortable vs press
  base += (t.fw_abs*0.05)*-1;  // striker absen → lebih buruk
  base += (t.rotation>=2 ? -0.08 : 0); 
  base += (t.style==="press" ? 0.05 : 0);

  return clamp(base, 0.75, 1.20);
}


/* ------------------ AntiSpike Engine v2 ------------------ *
   AntiSpike meredam lonjakan λ terlalu besar karena:
   - xG tiba-tiba naik
   - variance besar
   - OSC mismatch ekstrem
---------------------------------------------------------------- */
function antiSpikeV2(lambda, sens=1.0){
  let max = 4.2 * sens;
  let min = 0.05;

  if(lambda > max) lambda = (lambda*0.55 + max*0.45);
  if(lambda < min) lambda = (lambda*0.55 + min*0.45);

  return lambda;
}


/* ------------------ Variance Stabilizer v21 ------------------ */
function varianceStabilizer(x){
  if(x < 0.85) return x*0.88;
  if(x > 1.30) return x*0.92;
  return x;
}


/* ------------------ ZeroBias v2 ------------------ *
   ZeroBias v2 lebih halus daripada v20:
   - gunakan OU market sebagai "neutral target"
   - redistribusi λ dengan rasio 65% model, 35% OU
---------------------------------------------------------------- */
function zeroBiasV2(lambdaH,lambdaA,market){
  let sum = lambdaH + lambdaA;
  if(sum <= 0) return { h:lambdaH, a:lambdaA };

  let target = market || 2.5;

  let ratio = 0.35;  // 35% OU, 65% model
  let adj = target / sum;

  lambdaH = lambdaH*(1-ratio) + (lambdaH*adj)*ratio;
  lambdaA = lambdaA*(1-ratio) + (lambdaA*adj)*ratio;

  return {
    h: clamp(lambdaH,0.05,5.0),
    a: clamp(lambdaA,0.05,5.0)
  };
}


/* ------------------ AdaptiveXG v2 ------------------ *
   Mengkoreksi XG+ berdasarkan:
   - Context
   - Fatigue
   - OSC
   - Stability
   - PNS
   - BMS
---------------------------------------------------------------- */
function adaptiveXGv2(baseXG, ctxF, fatF, osc, pns, bms){
  let x = baseXG;

  x *= ctxF;
  x *= fatF;

  x *= (1 + (osc-0.4)*0.15);
  x *= (1 + (pns-1.0)*0.20);
  x *= (1 + (bms-1.0)*0.12);

  return clamp(x, 0.05, 7.0);
}


/* ------------------ Rotation Penalty v2 ------------------ */
function rotationPenaltyV2(r){
  if(r===0) return 0.00;
  if(r===1) return 0.05;
  if(r===2) return 0.10;
  if(r===3) return 0.18;
  return 0.00;
}


/* ------------------ Importance Factor v3 ------------------ */
function importanceFactorV3(mode){
  switch(mode){
    case "low": return 0.90;
    case "med": return 1.00;
    case "high": return 1.08;
    case "must": return 1.15;
    default: return 1.00;
  }
}


/* ------------------ Key Missing Penalty v2 + IIW2 ------------------ */
function keyMissingPenaltyV2(isMissing, iiw){
  if(isMissing===0) return 0;

  let base = 0.12;
  if(iiw){
    base += clamp(iiw*0.40, 0, 0.40);
  }

  return clamp(base, 0.02, 0.45);
}
/* ============================================================
   PART 4/12 — AGV v3, PBCM v2, GDPM v2, XT/XTA v3,
               HT Predictor v21, HomeAdv v3,
               League Normalization v3, TrapMeter v3
   ============================================================ */

/* ---------------- AGV v3 (Adaptive Goal Volatility) --------------
   v3 memperhitungkan:
   - Tactical clash
   - OSC
   - recent momentum variance
   - match importance & tournament volatility
------------------------------------------------------------------ */
function calcAGVv3(h, a, clash, tournament, recentVariance=0.12){
  // base volatility 0.9 .. 1.5
  let base = 0.9;

  // tactical clash increases volatility
  base += clamp(clash * 0.18, 0, 0.55);

  // OSC (opponent style compatibility) increases unpredictability
  const osc = calcOSC(h,a);
  base += clamp(osc * 0.25, 0, 0.45);

  // momentum variance effect
  base += clamp(recentVariance * 0.6, 0, 0.25);

  // tournament effect
  if(tournament==="wc" || tournament==="euro") base += 0.12;
  if(tournament==="friendly") base -= 0.08;
  if(tournament==="relegation") base += 0.08;

  // fatigue influence
  const fatigueFactor = Math.max(0.95, Math.min(1.08, (calcFatigue(safeNum(h.rest,3), safeNum(h.travel_km,0)) + calcFatigue(safeNum(a.rest,3), safeNum(a.travel_km,0))) / 2 ));
  base *= fatigueFactor;

  return clamp(base, 0.6, 2.2);
}

/* ---------------- PBCM v2 (Possession Build-up Control Model) -----
   v2 memperhitungkan:
   - progression passes, build-up speed, final3, possession, PNS
------------------------------------------------------------------ */
function calcPBCMv2(t){
  let poss = clamp(safeNum(t.poss,50)/100, 0.2, 0.8);
  let prog = safeNum(t.prog, 8);
  let final3 = safeNum(t.final3, 12);
  let build = safeNum(t.build,5);
  let pns = safeNum(t.pns,1.0);

  let val = 0.4*poss + (prog/40)*0.35 + (final3/30)*0.3 + (build/10)*0.15 + (pns-1.0)*0.18;
  // normalize to 0.3 - 2.0 range
  let ret = clamp(0.6 + val, 0.3, 2.0);
  return ret;
}

/* ---------------- GDPM v2 (Game Difficulty Pressure Model) -------
   v2: average of PBCM and opponent PBCM plus possession gap, away travel, and league difficulty
------------------------------------------------------------------ */
function calcGDPMv2(h, a, leagueDiff=1.0){
  const pbcH = calcPBCMv2(h);
  const pbcA = calcPBCMv2(a);
  const possGap = Math.abs((safeNum(h.poss,50)) - (safeNum(a.poss,50))) / 100; // 0..0.8
  let travelPenalty = 0;
  if(safeNum(h.travel_km,0) > 800 || safeNum(a.travel_km,0) > 800) travelPenalty = 0.06;

  let raw = ((pbcH + pbcA)/2) + possGap*0.25 + travelPenalty;
  // leagueDiff >1 means league is harder → slightly increases GDPM
  raw *= clamp(1 + (leagueDiff-1)*0.08, 0.9, 1.2);

  return clamp(raw, 0.35, 2.0);
}

/* ---------------- XT/XTA v3 (Expected Threat & Against) ----------
   v3 incorporates:
   - progressive passes (progAdj)
   - final3 entries (finalAdj)
   - shot quality SQF
   - set-piece threat SPT
------------------------------------------------------------------ */
function calcXTv3(t){
  let sqf = calcSQF(t);
  let pe = possessionWeightedEntries(t);
  let spt = calcSPTv2(t);
  let base = (pe.progAdj * 0.020) + (pe.finalAdj * 0.028) + (t.sot * 0.06) + (sqf*0.18) + (spt*0.12);
  return clamp(base, 0.02, 2.8);
}

function calcXTAv3(t){
  // threat against includes shots conceded + opponent set-piece threat + DZC inverse
  let s = (safeNum(t.shotsC, 10) * 0.012) + (safeNum(t.gc,1) * 0.22);
  // DZC reduces xTA if compact
  let dzcFactor = t.dzc ? (1 - (t.dzc-1.0)*0.08) : 1.0;
  return clamp((s * dzcFactor), 0.01, 2.2);
}

/* ---------------- calcSPTv2 (set-piece threat) ------------------- */
function calcSPTv2(t){
  // combine crosses, final3 (set-piece entries), and PNS
  let cross = clamp(safeNum(t.cr,12)/40, 0, 1);
  let final = clamp(safeNum(t.final3,10)/30, 0, 1);
  let pns = safeNum(t.pns,1.0);
  let val = (cross*0.45) + (final*0.4) + ((pns-1.0)*0.3);
  return clamp(val, 0, 1.2);
}

/* ---------------- HT Predictor v21 (enhanced) ---------------------
   HT lambda uses enhancedHTlambda but with additional volatility & home adv
------------------------------------------------------------------ */
function calcHTv21(lambdaH, lambdaA, h, a, matchType, tournament){
  // base via enhancedHTlambda (from v20 patch)
  let htBase = enhancedHTlambda(lambdaH, lambdaA, h.mom || 1, a.mom || 1, matchType, tournament);
  // adjust using agv & importance
  let importanceBoost = Math.max(1.0, Math.min(1.18, (importanceFactorV3(h.comp_imp || h.importance) + importanceFactorV3(a.comp_imp || a.importance))/2 ));
  let agv = calcAGVv3(h,a, calcOSC(h,a), tournament, 0.12);
  htBase.htH *= clamp(1 + (agv-1)*0.08, 0.9, 1.25);
  htBase.htA *= clamp(1 + (agv-1)*0.08, 0.9, 1.25);

  // normalize HT probabilities
  let denom = htBase.htH + htBase.htA + 0.5;
  let ph = clamp(htBase.htH/denom, 0, 1);
  let pa = clamp(htBase.htA/denom, 0, 1);
  let pd = clamp(1 - (ph + pa), 0, 1);

  return { htH: htBase.htH, htA: htBase.htA, probH: ph, probD: pd, probA: pa };
}

/* ---------------- Home Advantage v3 ------------------------------
   v3 considers:
   - travel distance
   - rest advantage
   - crowd importance (matchType)
   - seasonal home advantage (leagueProfile)
------------------------------------------------------------------ */
function homeAdvV3(matchType, h_rest, a_rest, travelH, travelA, leagueProfile){
  let base = 1.03; // default small home edge

  // rest differential
  let restDiff = safeNum(h_rest,3) - safeNum(a_rest,3);
  if(restDiff >= 2) base += 0.02;
  if(restDiff <= -2) base -= 0.02;

  // travel penalty for away
  if(safeNum(travelA,0) > 800) base += 0.03;
  if(safeNum(travelA,0) > 2000) base += 0.02;

  // match type importance
  if(matchType==="Derby") base += 0.01;
  if(matchType==="Final") base += 0.00; // finals can be neutral
  if(matchType==="Relegation") base += 0.02;

  // league profile
  if(leagueProfile==="high") base += 0.01;
  if(leagueProfile==="low") base -= 0.01;

  return clamp(base, 0.95, 1.12);
}

/* ---------------- League Normalization v3 -----------------------
   v3: uses league_gpg and optional qpe aggregated league stats to softly rescale lambdas
------------------------------------------------------------------ */
function leagueNormalizationV3(lambdaH, lambdaA, leagueGPG, leagueKey){
  leagueGPG = safeNum(leagueGPG, 2.6);
  // global QPE league stats (if any)
  const st = (window._v21 && window._v21.qpe && window._v21.qpe.leagueStats && window._v21.qpe.leagueStats[leagueKey]) ? window._v21.qpe.leagueStats[leagueKey] : null;
  let total = Math.max(0.01, lambdaH + lambdaA);
  let target = leagueGPG;

  // if we have aggregated history for league, slightly prefer that
  if(st && st.count > 3){
    const avgReal = st.sumReal/st.count;
    const avgPred = st.sumPred/st.count || target;
    // blend target with avgReal
    target = (target*0.65) + (avgReal*0.35);
  }

  // gentle scaling
  let factor = Math.pow(target / total, 0.10);
  factor = clamp(factor, 0.85, 1.18);

  return { h: lambdaH * factor, a: lambdaA * factor, factor };
}

/* ---------------- TrapMeter v3 (full) ---------------------------
   Combines:
   - hdp movement
   - odds imbalance
   - market volume
   - hours to kickoff
   - implied probability divergence
   - liquidity multiplier
   - overreaction smoothing
------------------------------------------------------------------ */
function trapMeterV3(params){
  // params: {oddsH, oddsA, hdpOpen, hdpNow, marketVol, hoursToKick, overround}
  const oddsH = safeNum(params.oddsH, 0);
  const oddsA = safeNum(params.oddsA, 0);
  const hdpOpen = safeNum(params.hdpOpen, 0);
  const hdpNow = safeNum(params.hdpNow, 0);
  const marketVol = safeNum(params.marketVol, 1.0);
  const hours = Math.max(0.1, safeNum(params.hoursToKick, 24));
  const overround = safeNum(params.overround, 1.0);

  // movement
  let mov = Math.abs(hdpNow - hdpOpen) * 2.0;

  // odds imbalance (implied probabilities)
  let impH = oddsH>0 ? (1/oddsH) : 0;
  let impA = oddsA>0 ? (1/oddsA) : 0;
  let impDiv = Math.abs(impH - impA);

  // volume weighting
  let volFactor = clamp(Math.log(1 + marketVol)/Math.log(1+100), 0.7, 2.0);

  // time proximity factor (closer -> more meaningful)
  let timeFactor = clamp(1 + (24 - Math.min(24, hours))/48, 0.85, 1.30);

  // liquidity effect (overround beyond 1 indicates margin)
  let liq = clamp(1 + (overround - 1)*2.0, 0.8, 1.6);

  // base trap
  let idx = 1 + mov*0.5 + impDiv*0.18;
  idx *= volFactor * timeFactor * liq;

  // clamp and smooth
  idx = clamp(idx, 0.55, 2.4);
  // reduce extremes using tanh smoothing
  idx = 1 + Math.tanh((idx - 1)/1.6) * 1.1;

  return clamp(idx, 0.6, 2.2);
}

/* ---------------- Export small helper to use trapMeterV3 easily -------------- */
function calcTrapFromUI(){
  const oddsH = safeNum(document.getElementById("odds_home").value,0);
  const oddsA = safeNum(document.getElementById("odds_away").value,0);
  const hdpOpen = safeNum(document.getElementById("odds_hdp_open").value,0);
  const hdpNow = safeNum(document.getElementById("odds_hdp_now").value,0);
  const marketVol = safeNum(document.getElementById("market_vol").value,1.0);
  const hours = safeNum(document.getElementById("hours_kick").value,24);
  // estimate overround from odds if both present
  let overround = 1.0;
  if(oddsH>0 && oddsA>0){
    overround = (1/oddsH) + (1/oddsA); // approximate 1-book overround (ignores draw)
    overround = clamp(overround, 0.9, 1.5);
  }
  return trapMeterV3({oddsH,oddsA,hdpOpen,hdpNow,marketVol,hours,overround});
}
/* ============================================================
   PART 5/12 — MASTER LAMBDA BUILDER + MCv3 worker + runner
   ============================================================ */

/* ---------------- Load team inputs (v21) ---------------- */
function loadTeamV21(side){
  const g = id => safeNum(document.getElementById(id).value, 0);
  const s = id => (document.getElementById(id) ? document.getElementById(id).value : "");

  let t = {
    name: s(side+"_name") || (side==="h" ? "Home" : "Away"),
    gpg: g(side+"_gpg"),
    gc: g(side+"_gc"),
    shots: g(side+"_shots"),
    sot: g(side+"_sot"),
    conv: g(side+"_conv"),
    poss: g(side+"_poss"),
    shotsC: g(side+"_shotsC"),
    cr: g(side+"_cr"),
    profile: s(side+"_profile") || "auto",
    elo: g(side+"_elo"),
    pac: g(side+"_pac"),
    style: s(side+"_style"),
    press: s(side+"_press"),
    height: s(side+"_height"),
    trans: g(side+"_trans"),
    counter: g(side+"_counter"),
    build: g(side+"_build"),
    pns: g(side+"_pns") || 1.0,
    gk_abs: g(side+"_gk_abs"),
    df_abs: g(side+"_df_abs"),
    md_abs: g(side+"_md_abs"),
    fw_abs: g(side+"_fw_abs"),
    iiw: g(side+"_iiw"),
    keymiss: s(side+"_keymiss")||"0",
    rotation: safeNum(document.getElementById(side+"_rotation") ? document.getElementById(side+"_rotation").value : 0, 0),
    prog: g(side+"_prog"),
    final3: g(side+"_final3"),
    inter: g(side+"_inter"),
    comp_imp: s(side+"_comp_imp") || "med",
    pri: g(side+"_pri") || null,
    dzc: g(side+"_dzc") || null,
    rest: safeNum(document.getElementById("rest_"+(side==="h"?"h":"a")) ? document.getElementById("rest_"+(side==="h"?"h":"a")).value : 3, 3),
    travel_km: safeNum(document.getElementById("travel_km") ? document.getElementById("travel_km").value : 0, 0)
  };

  // ensure fields
  ensureTeamFields(t);
  validateTeamInput(t, side.toUpperCase());
  return t;
}

/* ------------------ MCv3 Worker (improved) ------------------ */
let _mcv3_url = null;
function buildMCv3Worker(){
  const code = `
  onmessage = function(e){
    const lh = e.data.lh, la = e.data.la, n = e.data.n || 10000;
    function randPoisson(lambda){
      // Knuth method
      const L = Math.exp(-lambda);
      let k = 0, p = 1;
      while(p > L){
        k++;
        p *= Math.random();
      }
      return k-1;
    }
    const counts = {};
    for(let i=0;i<n;i++){
      const gh = randPoisson(lh);
      const ga = randPoisson(la);
      const k = gh + "-" + ga;
      counts[k] = (counts[k] || 0) + 1;
    }
    // normalize and compute probs
    let scores = {};
    for(const k in counts) scores[k] = counts[k] / n;
    let pH=0, pD=0, pA=0;
    for(const k in scores){
      const parts = k.split("-");
      const gh = parseInt(parts[0]), ga = parseInt(parts[1]);
      if(gh>ga) pH += scores[k];
      else if(gh<ga) pA += scores[k];
      else pD += scores[k];
    }
    postMessage({prob:{home:pH,draw:pD,away:pA},scores:scores});
  };
  `;
  const blob = new Blob([code], {type: "application/javascript"});
  if(_mcv3_url) URL.revokeObjectURL(_mcv3_url);
  _mcv3_url = URL.createObjectURL(blob);
}

function runMCv3(lh, la, n){
  return new Promise((resolve) => {
    try{
      if(!_mcv3_url) buildMCv3Worker();
      const w = new Worker(_mcv3_url);
      w.onmessage = (ev) => { resolve(ev.data); w.terminate(); };
      w.onerror = (err) => { console.warn("MCv3 worker error", err); resolve(null); w.terminate(); };
      w.postMessage({lh:lh, la:la, n:n||10000});
    }catch(e){
      console.warn("MCv3 fallback", e);
      resolve(null);
    }
  });
}

/* ------------------ MASTER LAMBDA BUILDER ------------------ */
async function masterLambdaBuild(){
  // load
  const h = loadTeamV21("h");
  const a = loadTeamV21("a");

  // UI params
  const matchType = safeNum(document.getElementById("match_type") ? document.getElementById("match_type").value : "Regular");
  const tournament = document.getElementById("tournament_mode") ? document.getElementById("tournament_mode").value : "none";
  const leagueGPG = safeNum(document.getElementById("league_gpg") ? document.getElementById("league_gpg").value : 2.6, 2.6);
  const leagueKey = document.getElementById("league_profile") ? document.getElementById("league_profile").value : "medium";
  const market_ou = safeNum(document.getElementById("market_ou") ? document.getElementById("market_ou").value : 2.5, 2.5);
  const antispikeSens = safeNum(document.getElementById("antispike_sens") ? document.getElementById("antispike_sens").value : 1.0, 1.0);
  const enableZeroBias = document.getElementById("zero_bias_mode") ? document.getElementById("zero_bias_mode").checked : true;
  const enableLearning = document.getElementById("enable_learning") ? document.getElementById("enable_learning").checked : false;

  // Base XG+ v2
  h.baseXG = calcXGPlusV2(h);
  a.baseXG = calcXGPlusV2(a);

  // SQF/PE/PNS etc already accessible by functions
  h.pns = calcPNS(h);
  a.pns = calcPNS(a);

  // DZC auto if enabled
  if(safeNum(document.getElementById("enable_dzc") ? document.getElementById("enable_dzc").value : 1,1) == 1){
    h.dzc = h.dzc || autoCalcDZC(h);
    a.dzc = a.dzc || autoCalcDZC(a);
  }

  // PRI if not provided
  h.pri = h.pri || calcPRI(h);
  a.pri = a.pri || calcPRI(a);

  // TTM, BMS
  h.ttm = calcTTM(h);
  a.ttm = calcTTM(a);
  h.bms = calcBMS(h);
  a.bms = calcBMS(a);

  // Fatigue
  const fatH = calcFatigue(safeNum(document.getElementById("rest_h") ? document.getElementById("rest_h").value : h.rest, 3), safeNum(h.travel_km, 0));
  const fatA = calcFatigue(safeNum(document.getElementById("rest_a") ? document.getElementById("rest_a").value : a.rest, 3), safeNum(a.travel_km, 0));

  // Context
  const ctx = {
    weather: document.getElementById("weather") ? document.getElementById("weather").value : "Normal",
    pitch_size: document.getElementById("pitch_size") ? document.getElementById("pitch_size").value : "normal",
    altitude: safeNum(document.getElementById("altitude") ? document.getElementById("altitude").value : 0, 0)
  };
  const ctxF = calcContextFactor(ctx);

  // Adaptive XG v2
  h.adaptiveXG = adaptiveXGv2(h.baseXG, ctxF, fatH, calcOSC(h,a), h.pns, h.bms);
  a.adaptiveXG = adaptiveXGv2(a.baseXG, ctxF, fatA, calcOSC(h,a), a.pns, a.bms);

  // apply FEI / DSI adjustments (FEI v2 & DSI v2)
  h.fei = calcFEIv2(h);
  a.fei = calcFEIv2(a);
  h.dsi = calcDSIv2(h);
  a.dsi = calcDSIv2(a);

  // profile multipliers
  if(h.profile==="auto") h.profile = classifyTeamV21(h.adaptiveXG, h.gc);
  if(a.profile==="auto") a.profile = classifyTeamV21(a.adaptiveXG, a.gc);
  const pmH = profileMultiplierV21(h.profile);
  const pmA = profileMultiplierV21(a.profile);

  // base strength
  let strengthH = h.adaptiveXG * h.fei * pmH.atk * h.ttm * h.pns;
  let strengthA = a.adaptiveXG * a.fei * pmA.atk * a.ttm * a.pns;

  // defensive adjustments
  strengthH *= (1 / (a.dsi || 1)) * clamp(1 - (h.dzc ? (h.dzc-1)*0.08 : 0), 0.84, 1.12);
  strengthA *= (1 / (h.dsi || 1)) * clamp(1 - (a.dzc ? (a.dzc-1)*0.08 : 0), 0.84, 1.12);

  // apply importance, rotation, keymissing, injury impact weight
  const impH = importanceFactorV3(h.comp_imp || h.importance);
  const impA = importanceFactorV3(a.comp_imp || a.importance);
  const rotH = rotationPenaltyV2(h.rotation);
  const rotA = rotationPenaltyV2(a.rotation);
  const kmH = keyMissingPenaltyV2(safeNum(h.keymiss,0), safeNum(h.iiw,0));
  const kmA = keyMissingPenaltyV2(safeNum(a.keymiss,0), safeNum(a.iiw,0));

  strengthH *= impH * (1 - rotH) * (1 - kmH);
  strengthA *= impA * (1 - rotA) * (1 - kmA);

  // apply ELO factor (diminished influence)
  const eloF = eloFactor(h.elo, a.elo);
  strengthH *= (1 + (eloF-1)*0.6);
  strengthA *= (1 - (eloF-1)*0.6);

  // home advantage
  const homeAdv = homeAdvV3(matchType, safeNum(document.getElementById("rest_h") ? document.getElementById("rest_h").value : h.rest,3),
                               safeNum(document.getElementById("rest_a") ? document.getElementById("rest_a").value : a.rest,3),
                               safeNum(h.travel_km,0), safeNum(a.travel_km,0), leagueKey);

  strengthH *= homeAdv;

  // AGV v3 influences scaling of goals (volatility)
  const clash = tacticalClash(h,a); // tacticalClash exists in earlier parts
  const agv = calcAGVv3(h,a,clash, tournament, 0.12);

  // set piece boost
  strengthH *= (1 + calcSPTv2(h)*0.06);
  strengthA *= (1 + calcSPTv2(a)*0.06);

  // trap / market influence (if enabled)
  let trapv = 1.0;
  if(safeNum(document.getElementById("enable_trap_v3") ? document.getElementById("enable_trap_v3").value : 1,1) == 1){
    trapv = calcTrapFromUI();
  }

  // league normalization v3
  let lambdaH = clamp(strengthH, 0.03, 6.0);
  let lambdaA = clamp(strengthA, 0.03, 6.0);

  // zero-bias
  if(enableZeroBias){
    const zb = zeroBiasV2(lambdaH, lambdaA, market_ou);
    lambdaH = zb.h; lambdaA = zb.a;
  }

  // anti-spike smoothing
  lambdaH = antiSpikeV2(lambdaH, antispikeSens);
  lambdaA = antiSpikeV2(lambdaA, antispikeSens);

  // apply adaptiveXG recalibration (online learning bias) if present
  if(window._v21 && window._v21.xgCalibrator){
    lambdaH = adaptiveXG(lambdaH);
    lambdaA = adaptiveXG(lambdaA);
  }

  // QPE adjustments (if learned)
  if(window._v21 && window._v21.qpe){
    const adj = applyQPEAdjustments(lambdaH, lambdaA, leagueKey);
    lambdaH = adj.lambdaH; lambdaA = adj.lambdaA;
  }

  // final clamps
  lambdaH = clamp(lambdaH, 0.03, 6.5);
  lambdaA = clamp(lambdaA, 0.03, 6.5);

  // Poisson quick distribution for small evaluation
  const maxG = 8;
  const dist = {};
  let pHome=0, pDraw=0, pAway=0;
  for(let i=0;i<=maxG;i++){
    for(let j=0;j<=maxG;j++){
      const ph = Math.pow(lambdaH,i)*Math.exp(-lambdaH)/factorial(i);
      const pa = Math.pow(lambdaA,j)*Math.exp(-lambdaA)/factorial(j);
      const p = ph*pa;
      dist[i+"-"+j] = p;
      if(i>j) pHome += p;
      else if(i===j) pDraw += p;
      else pAway += p;
    }
  }

  // prepare result object
  const res = {
    time: new Date().toLocaleString(),
    h: h, a: a,
    lambdaH: lambdaH, lambdaA: lambdaA,
    baseProb: {home:pHome, draw:pDraw, away:pAway},
    dist: dist,
    agv: agv, trap: trapv, clash: clash, conf: null
  };

  // store last res for learning / later use
  window._lastRes = res;

  // run MCv3 (async) to refine probability
  const mcIter = parseInt(document.getElementById("mc_select") ? document.getElementById("mc_select").value : 10000);
  showToast("Running Monte Carlo ("+mcIter+") ...", 1200);
  const mc = await runMCv3(lambdaH, lambdaA, mcIter);
  if(mc){
    res.prob = mc.prob;
    res.scores = mc.scores;
  } else {
    res.prob = res.baseProb;
    res.scores = res.dist;
  }

  // compute simple confidence (function in next parts)
  res.conf = confidenceGrid ? confidenceGrid(lambdaH, lambdaA, agv, trapv) : 0.55;

  // publish to global for other parts to use (buildOutput in Part 6)
  window._lastRes = res;

  // attempt to call buildOutput if already defined (Part 6 defines it)
  try{
    if(typeof buildOutput === "function"){
      buildOutput(h,a,lambdaH,lambdaA,res.prob, calcHTv21(lambdaH, lambdaA, h, a, matchType, tournament), null, clash, trapv, res.conf, agv);
    } else {
      // fallback: show minimal text in resultText
      const el = document.getElementById("resultText");
      if(el) el.textContent = `λH: ${lambdaH.toFixed(3)} • λA: ${lambdaA.toFixed(3)}\nProb (MC): H:${(res.prob.home*100).toFixed(1)}% D:${(res.prob.draw*100).toFixed(1)}% A:${(res.prob.away*100).toFixed(1)}\nConf:${(res.conf*100).toFixed(1)}%`;
    }
  }catch(e){
    console.warn("masterLambdaBuild -> buildOutput error", e);
  }

  // return res
  return res;
}

/* ---------------- bind analyze button to master lambda (will be wrapped later) */
(function bindMaster(){
  const btn = document.getElementById("analyzeBtn");
  if(btn){
    btn.removeEventListener("click", masterLambdaBuild);
    btn.addEventListener("click", ()=>{ masterLambdaBuild(); });
  }
})();
/* ============================================================
   PART 6/12 — OUTPUT, RADAR(10), SCORE DIST, TREND, HISTORY,
               QPE AUTO-TRAIN HOOK, MODEL EXPORT/IMPORT,
               CONFIDENCE GRID, ORL (Outcome Recalibrator)
   ============================================================ */

/* ----------------- factorial helper ----------------- */
function factorial(n){
  n = Math.floor(n);
  if(n<=1) return 1;
  let r=1;
  for(let i=2;i<=n;i++) r*=i;
  return r;
}

/* ----------------- ORL: Outcome Recalibrator Layer -----------
   Slightly recalibrate model 1x2 probs toward implied market if available.
   - preserves model but respects market signal softly.
-------------------------------------------------------------- */
function ORL(modelProb){
  // modelProb: {home, draw, away}
  const oddsH = safeNum(document.getElementById("odds_home").value,0);
  const oddsA = safeNum(document.getElementById("odds_away").value,0);
  const over = safeNum(document.getElementById("odds_over").value,0);
  const under = safeNum(document.getElementById("odds_under").value,0);

  let marketProb = null;
  if(oddsH>0 && oddsA>0){
    let pH = 1/oddsH;
    let pA = 1/oddsA;
    // approximate draw residual
    let sum = pH + pA;
    let pD = Math.max(0, 1 - sum);
    // renormalize
    const total = pH + pD + pA;
    marketProb = { home: pH/total, draw: pD/total, away: pA/total };
  }

  if(!marketProb) return modelProb;

  // blending ratio based on trap (higher trap -> trust market less)
  let trap = calcTrapFromUI();
  let blend = clamp(0.22 * (2.0 - trap), 0.06, 0.35); // if trap high, smaller blend
  const out = {
    home: clamp(modelProb.home*(1-blend) + marketProb.home*blend, 0,1),
    draw: clamp(modelProb.draw*(1-blend) + marketProb.draw*blend, 0,1),
    away: clamp(modelProb.away*(1-blend) + marketProb.away*blend, 0,1)
  };
  // renormalize
  const s = out.home + out.draw + out.away;
  out.home/=s; out.draw/=s; out.away/=s;
  return out;
}

/* ----------------- confidenceGrid -----------------
   Simple multi-factor confidence estimator (0..1)
   inputs: lambdaH, lambdaA, volatility(agv), trapIndex
-------------------------------------------------- */
function confidenceGrid(lambdaH, lambdaA, agv, trap){
  let base = 0.58;

  // lower volatility increases confidence
  base += clamp((1.0 - (agv-1))*0.18, -0.16, 0.18);

  // balanced lambdas -> lower confidence for draw? we adjust
  let diff = Math.abs(lambdaH - lambdaA);
  base += clamp((1.6 - diff)*0.05, -0.08, 0.1);

  // trap reduces confidence
  base -= clamp((trap-1.0)*0.18, -0.25, 0.25);

  // very extreme lambdas increase confidence
  const extreme = Math.max(lambdaH, lambdaA);
  if(extreme > 3.0) base += 0.06;

  return clamp(base, 0.18, 0.94);
}

/* ----------------- drawRadar10 (extended radar) --------------
   10 axes: AtkH, DefH, AtkA, DefA, TTM, PNS, DZC, PRI, Transition, Clash
-------------------------------------------------------------- */
function drawRadar10(h,a,clash){
  const cv = document.getElementById("radarCanvas");
  if(!cv) return;
  const ctx = cv.getContext("2d");
  ctx.clearRect(0,0,cv.width,cv.height);
  const cx = cv.width/2, cy = cv.height/2;
  const r = Math.min(cx,cy) - 40;
  const axes = 10;
  const ang = 2*Math.PI/axes;

  // compute values scaled 0..1
  const atkH = clamp(h.xg ? h.xg/3.5 : (h.adaptiveXG ? h.adaptiveXG/3.5 : 0), 0,1);
  const defH = clamp(1/(h.dsi||1), 0,1.6);
  const atkA = clamp(a.xg ? a.xg/3.5 : (a.adaptiveXG ? a.adaptiveXG/3.5 : 0), 0,1);
  const defA = clamp(1/(a.dsi||1), 0,1.6);
  const ttm = clamp(h.ttm || 0.8, 0,1.4);
  const pns = clamp((h.pns||1)/1.6, 0,1.0);
  const dzc = clamp(h.dzc ? ((h.dzc-0.6)/0.8) : 0.5, 0,1);
  const pri = clamp((h.pri||0.9)/1.4, 0,1);
  const trans = clamp((h.trans||5)/10, 0,1);
  const cl = clamp(clash/2, 0,1);

  const vals = [atkH, defH, atkA, defA, ttm, pns, dzc, pri, trans, cl];

  // background web
  ctx.strokeStyle = "rgba(200,230,235,0.06)";
  for(let i=1;i<=4;i++){
    ctx.beginPath();
    ctx.arc(cx,cy,(r/4)*i,0,Math.PI*2);
    ctx.stroke();
  }

  // polygon
  ctx.beginPath();
  ctx.fillStyle = "rgba(24,178,201,0.06)";
  ctx.strokeStyle = "#18b2c9";
  for(let i=0;i<axes;i++){
    const rad = vals[i]*r;
    const x = cx + rad * Math.cos(ang*i - Math.PI/2);
    const y = cy + rad * Math.sin(ang*i - Math.PI/2);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // labels
  ctx.fillStyle = "#bfeef8";
  ctx.font = "12px sans-serif";
  const labels = ["AtkH","DefH","AtkA","DefA","TTM","PNS","DZC","PRI","Trans","Clash"];
  for(let i=0;i<axes;i++){
    const x = cx + (r+22) * Math.cos(ang*i - Math.PI/2);
    const y = cy + (r+22) * Math.sin(ang*i - Math.PI/2);
    ctx.fillText(labels[i], x-14, y+5);
  }
}

/* ----------------- buildOutput (v21 final renderer) -------------- */
function buildOutput(h,a,lambdaH,lambdaA,prob,ht,pen,clash,trap,conf,agv){
  // header text
  const resEl = document.getElementById("resultText");
  let s = "";
  s += `<strong>λ Home:</strong> ${lambdaH.toFixed(3)} &nbsp; <strong>λ Away:</strong> ${lambdaA.toFixed(3)}<br/>`;
  s += `<strong>Prob FT (MC):</strong> Home: ${pct(prob.home)} • Draw: ${pct(prob.draw)} • Away: ${pct(prob.away)}<br/>`;
  s += `Confidence: ${(conf*100).toFixed(1)}% &nbsp; • TrapIndex: ${trap.toFixed(2)} &nbsp; • Clash: ${clash.toFixed(2)}<br/>`;
  s += `AGV: ${agv.toFixed(2)}<br/><br/>`;

  if(ht){
    s += `<strong>HT Prediksi:</strong> HT λH: ${ht.htH.toFixed(3)} • HT λA: ${ht.htA.toFixed(3)}<br/>`;
    s += `HT Prob: Home ${pct(ht.probH)} • Draw ${pct(ht.probD)} • Away ${pct(ht.probA)}<br/><br/>`;
  }

  if(pen){
    s += `<strong>Penalti KO (jika):</strong> Home ${(pen.pH*100).toFixed(1)}% • Away ${(pen.pA*100).toFixed(1)}%<br/><br/>`;
  }

  s += `<strong>Tactical Summary:</strong><br/>`;
  s += `${h.name} — xG: ${(h.xg||h.adaptiveXG||0).toFixed(2)} | DSI: ${(h.dsi||0).toFixed(2)} | PNS: ${(h.pns||1).toFixed(2)}<br/>`;
  s += `${a.name} — xG: ${(a.xg||a.adaptiveXG||0).toFixed(2)} | DSI: ${(a.dsi||0).toFixed(2)} | PNS: ${(a.pns||1).toFixed(2)}<br/>`;

  resEl.innerHTML = s;

  // Score distribution text (top likely)
  const scoreEl = document.getElementById("scoreDist");
  const dist = window._lastRes && window._lastRes.scores ? window._lastRes.scores : window._lastRes && window._lastRes.dist ? window._lastRes.dist : {};
  if(dist){
    const entries = Object.keys(dist).map(k=>[k, dist[k]]).sort((a,b)=>b[1]-a[1]);
    let sd = "";
    for(let i=0;i<Math.min(entries.length,18);i++){
      sd += `${entries[i][0]}: ${(entries[i][1]*100).toFixed(2)}%\n`;
    }
    scoreEl.textContent = sd;
  }

  // Trend insights
  const trendEl = document.getElementById("trendText");
  let t = "";
  t += `xG Home: ${(h.adaptiveXG||h.baseXG||0).toFixed(2)} | xG Away: ${(a.adaptiveXG||a.baseXG||0).toFixed(2)}\n`;
  t += `PNS H:${(h.pns||1).toFixed(2)} A:${(a.pns||1).toFixed(2)} | DZC H:${(h.dzc||1).toFixed(2)} A:${(a.dzc||1).toFixed(2)}\n`;
  t += `TTM H:${(h.ttm||1).toFixed(2)} A:${(a.ttm||1).toFixed(2)} | BMS H:${(h.bms||1).toFixed(2)} A:${(a.bms||1).toFixed(2)}\n`;
  trendEl.textContent = t;

  // Radar
  drawRadar10(h,a,clash);

  // push history
  pushHistory({time:new Date().toLocaleString(), hname:h.name, aname:a.name, prob:prob, conf:conf, lambdaH:lambdaH, lambdaA:lambdaA, trap:trap});
}

/* ----------------- HISTORY ----------------- */
let HISTORY = [];
function pushHistory(entry){
  HISTORY.unshift(entry);
  if(HISTORY.length>300) HISTORY.pop();
  renderHistory();
}

function renderHistory(){
  const el = document.getElementById("historyList");
  if(!el) return;
  let out = "";
  for(const it of HISTORY){
    out += `[${it.time}] ${it.hname} vs ${it.aname} → H:${(it.prob.home*100).toFixed(1)}% D:${(it.prob.draw*100).toFixed(1)}% A:${(it.prob.away*100).toFixed(1)}% (C:${(it.conf*100||0).toFixed(0)}%)\n`;
  }
  el.textContent = out;
}

/* ----------------- EXPORT/IMPORT MODEL (QPE state) ----------------- */
document.getElementById("exportModel").addEventListener("click", ()=>{
  const obj = window._v21 || {};
  const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a"); a.href = url; a.download = "qpe_model_v21.json"; a.click();
  URL.revokeObjectURL(url);
  showToast("Model diekspor");
});

document.getElementById("importModel").addEventListener("click", ()=>{
  const inp = document.createElement("input");
  inp.type = "file";
  inp.accept = "application/json";
  inp.onchange = (e)=>{
    const f = e.target.files[0];
    if(!f) return;
    const r = new FileReader();
    r.onload = (ev)=>{
      try{
        const obj = JSON.parse(ev.target.result);
        window._v21 = obj;
        showToast("Model diimpor");
      }catch(err){
        showToast("Import gagal");
      }
    };
    r.readAsText(f);
  };
  inp.click();
});

/* ============/* ============================================================
   PART 6/12 — LAMBDA FINALIZER v21
   Menggabungkan: XG+, DSI, PNS, OSC, TTM, FATIGUE, IMPORTANCE,
   CONTEXT NORMALIZATION, LEAGUE GPG ADJUST, ANTI-SPIKE v2,
   ADAPTIVEXG v3, ZERO-BIAS TOTAL-GOALS
   ============================================================ */

/* -------- 1) Fungsi normalisasi liga (berdasarkan league GPG) -------- */
function leagueNormalize(lambda, leagueGPG, modelGPG=2.72){
  if(!leagueGPG || leagueGPG <= 0) return lambda;
  const factor = leagueGPG / modelGPG;
  return lambda * factor;
}

/* -------- 2) Konteks pertandingan (cuaca, altitude, pitch quality) -------- */
function contextModifier(ctx){
  if(!ctx) return 1;

  let m = 1;

  if(ctx.weather === "rain")  m *= 0.94;
  if(ctx.weather === "storm") m *= 0.88;
  if(ctx.weather === "snow")  m *= 0.90;
  if(ctx.weather === "hot")   m *= 0.96;

  if(ctx.altitude === "high") m *= 0.92;

  if(ctx.pitch === "slow")    m *= 0.95;
  if(ctx.pitch === "fast")    m *= 1.03;

  return m;
}

/* -------- 3) FATIGUE & SCHEDULE difficulty -------- */
function fatigueModifier(fat){
  if(!fat) return 1;
  return clamp(1 - (fat * 0.04), 0.82, 1.05);
}

function scheduleMod(diff){
  if(!diff) return 1;
  return clamp(1 - (diff * 0.03), 0.85, 1.05);
}

/* -------- 4) IMPORTANCE (big match, derby, elimination) -------- */
function importanceBoost(val){
  if(!val) return 1;
  return 1 + clamp(val * 0.08, -0.15, 0.15);
}

/* -------- 5) AntiSpike v2 (menstabilkan lonjakan aneh) -------- */
function antiSpike(base, indicators){
  let penalty = 0;
  if(indicators.dsi < 0.55) penalty += 0.05;
  if(indicators.pns < 0.55) penalty += 0.04;
  if(indicators.bms < 0.5)  penalty += 0.03;
  return base * (1 - penalty);
}

/* -------- 6) AdaptiveXG v3 (adjust berdasarkan finishing konversi terakhir) -------- */
function adaptiveXG(base, conv){
  if(!conv || conv <= 0) return base;
  const adj = clamp((conv - 0.11) * 0.8, -0.20, 0.22);
  return base * (1 + adj);
}

/* -------- 7) ZERO-BIAS MODEL (menyeimbangkan total gol supaya netral) -------- */
function zeroBias(lambdaH, lambdaA, marketOU){
  if(!marketOU || marketOU <= 0) return {lh: lambdaH, la: lambdaA};

  const totalModel = lambdaH + lambdaA;

  const adj = clamp((marketOU - totalModel) * 0.25, -0.55, 0.55);

  const lh = clamp(lambdaH + adj/2, 0.12, 6.0);
  const la = clamp(lambdaA + adj/2, 0.12, 6.0);

  return {lh, la};
}

/* ==================================================================
   LAMBDA FINALIZER — DIGUNAKAN OLEH masterLambdaBuild()
   ================================================================== */
function finalizeLambda(h, a, adv, ctx, leagueGPG, marketOU){
  let lambdaH = adv.xgH;
  let lambdaA = adv.xgA;

  /* --- gabung semua modul advanced --- */
  lambdaH *= adv.dsiH;
  lambdaA *= adv.dsiA;

  lambdaH *= adv.pnsH;
  lambdaA *= adv.pnsA;

  lambdaH *= adv.oscH;
  lambdaA *= adv.oscA;

  lambdaH *= adv.ttmH;
  lambdaA *= adv.ttmA;

  lambdaH *= adv.bmsH;
  lambdaA *= adv.bmsA;

  /* fatigues */
  lambdaH *= fatigueModifier(adv.fatH);
  lambdaA *= fatigueModifier(adv.fatA);

  /* schedule difficulty */
  lambdaH *= scheduleMod(adv.schedH);
  lambdaA *= scheduleMod(adv.schedA);

  /* importance */
  lambdaH *= importanceBoost(adv.impH);
  lambdaA *= importanceBoost(adv.impA);

  /* context (cuaca, pitch, altitude) */
  const cmH = contextModifier(ctx);
  const cmA = contextModifier(ctx);
  lambdaH *= cmH;
  lambdaA *= cmA;

  /* league normalization */
  lambdaH = leagueNormalize(lambdaH, leagueGPG);
  lambdaA = leagueNormalize(lambdaA, leagueGPG);

  /* antiSpike v2 */
  lambdaH = antiSpike(lambdaH, adv);
  lambdaA = antiSpike(lambdaA, adv);

  /* AdaptiveXG v3 (berdasarkan conv%) */
  lambdaH = adaptiveXG(lambdaH, h.conv);
  lambdaA = adaptiveXG(lambdaA, a.conv);

  /* zero-bias (menyeimbangkan total gol agar tidak condong) */
  const zb = zeroBias(lambdaH, lambdaA, marketOU);
  lambdaH = zb.lh;
  lambdaA = zb.la;

  /* batas aman */
  lambdaH = clamp(lambdaH, 0.15, 6.5);
  lambdaA = clamp(lambdaA, 0.15, 6.5);

  return {lambdaH, lambdaA};
}

/* ============================================================
   END OF PART 6/12
   ============================================================ 
   */================================================
   PART 7/12 — CONFIDENCE TUNING, ODDS-TRAP REFINEMENT,
               HDP (Asian Handicap) CALCULATOR,
               OVER/UNDER PROB MODEL, ODDS-TRAP VISUALS
   ============================================================ */

/* ------------- Confidence tuning (advanced) ------------- */
/* augments earlier confidenceGrid with calibration on market + MC variance */
function confidenceTuned(lambdaH, lambdaA, agv, trap, mcScores){
  // base from previous confidenceGrid
  let base = confidenceGrid(lambdaH, lambdaA, agv, trap);

  // MC variance penalty: compute variance of top N scores if mcScores provided
  if(mcScores){
    // compute mean & variance of goals difference distribution
    let diffs = [];
    for(const k in mcScores){
      const parts = k.split("-");
      const gh = Number(parts[0]), ga = Number(parts[1]);
      const p = mcScores[k];
      diffs.push({d: gh - ga, p: p});
    }
    // expected abs diff
    let eAbs = 0;
    for(const it of diffs) eAbs += Math.abs(it.d) * it.p;
    // higher expected absolute diff -> more confidence
    base += clamp((eAbs - 0.6) * 0.06, -0.06, 0.12);
  }

  // market alignment: if model and market agree -> boost
  const oddsH = safeNum(document.getElementById("odds_home").value,0);
  const oddsA = safeNum(document.getElementById("odds_away").value,0);
  if(oddsH>0 && oddsA>0){
    const market = ORL({home:0.5,draw:0,away:0}); // dummy to get market prob via ORL internal method - but we'll calculate simple
    const mpH = 1/oddsH, mpA = 1/oddsA;
    const marketDiff = Math.abs((mpH / (mpH + mpA)) - 0.5);
    base += clamp((0.03 - marketDiff) * 0.4, -0.04, 0.06);
  }

  // trap reduces confidence
  base -= clamp((trap-1.0)*0.12, -0.18, 0.18);

  return clamp(base, 0.12, 0.96);
}

/* ------------- Odds-Trap Refinement (v3+) ------------- */
/* produces structured indicators to display */
function oddsTrapRefine(res){
  // res expected: { lambdaH, lambdaA, prob, scores, trap }
  const trap = safeNum(res.trap, calcTrapFromUI());
  const modelProb = res.prob || res.baseProb || {home:0.33,draw:0.34,away:0.33};

  // implied market (simple)
  const oddsH = safeNum(document.getElementById("odds_home").value,0);
  const oddsA = safeNum(document.getElementById("odds_away").value,0);
  let marketProb = null;
  if(oddsH>0 && oddsA>0){
    let pH = 1/oddsH, pA = 1/oddsA;
    let sum = pH + pA;
    let pD = Math.max(0, 1 - sum);
    const total = pH + pD + pA;
    marketProb = { home: pH/total, draw: pD/total, away: pA/total };
  }

  // divergence metrics
  let divergence = 0;
  if(marketProb){
    divergence = Math.abs(modelProb.home - marketProb.home) + Math.abs(modelProb.draw - marketProb.draw) + Math.abs(modelProb.away - marketProb.away);
    divergence /= 3; // normalize 0..1-ish
  }

  // trap severity
  const severity = clamp(trap * (1 + divergence*0.9), 0.6, 2.4);

  return { trapIndex: trap, marketProb: marketProb, divergence: divergence, severity: severity };
}

/* ------------- Asian Handicap (HDP) Calculator ------------- */
/* returns probabilities for several common handicap lines relative to model distribution */
function calcHDP(lambdaH, lambdaA, scoresDist){
  // scoresDist: object "g-h" -> prob. If not provided, compute using Poisson up to maxG
  const maxG = 8;
  const dist = scoresDist || (function(){
    const d = {};
    for(let i=0;i<=maxG;i++){
      for(let j=0;j<=maxG;j++){
        const ph = Math.pow(lambdaH,i) * Math.exp(-lambdaH) / factorial(i);
        const pa = Math.pow(lambdaA,j) * Math.exp(-lambdaA) / factorial(j);
        d[i+"-"+j] = ph*pa;
      }
    }
    return d;
  })();

  // helper compute probability of home - away > X, =X, <X
  function probDiffGreaterThan(x){
    let p=0;
    for(const k in dist){
      const parts = k.split("-");
      const gh = Number(parts[0]), ga = Number(parts[1]);
      if((gh - ga) > x) p += dist[k];
    }
    return p;
  }
  function probDiffEquals(x){
    let p=0;
    for(const k in dist){
      const parts = k.split("-");
      const gh = Number(parts[0]), ga = Number(parts[1]);
      if((gh - ga) === x) p += dist[k];
    }
    return p;
  }
  function probDiffLessThan(x){
    let p=0;
    for(const k in dist){
      const parts = k.split("-");
      const gh = Number(parts[0]), ga = Number(parts[1]);
      if((gh - ga) < x) p += dist[k];
    }
    return p;
  }

  // compute common HDP lines: -1.5, -1, -0.5, 0, +0.5, +1, +1.5
  const lines = [-1.5, -1, -0.5, 0, 0.5, 1, 1.5];
  const out = {};
  for(const L of lines){
    // For split handicaps like 0.5, 1.5 it's straightforward.
    // For quarter lines (-0.25, +0.25) we might combine; here we compute as per common interpretation:
    // P(home wins after applying handicap) = P(diff > L) + 0.5*P(diff == L) for half-lines treated appropriately.
    const floorL = Math.floor(L);
    let pWin = probDiffGreaterThan(L);
    let pDraw = probDiffEquals(L);
    let pLose = probDiffLessThan(L);
    // For betting settlement: wins if diff > L, push if diff == L for integer L, for half-lines no push.
    out[L] = { win: pWin, push: pDraw, lose: pLose };
  }

  return out;
}

/* ------------- Over/Under advanced probabilistic model ------------- */
/* calculates probabilities for common OU lines using total lambda and Poisson for combined goals */
function calcOverUnderProbs(lambdaH, lambdaA, maxT=8){
  const total = lambdaH + lambdaA;
  const probs = {}; // key = line (0.5,1.5,2.5...) -> overProb
  // compute distribution of total goals using convolution of Poissons (which is Poisson(total))
  // total goals follow Poisson(total)
  const maxG = maxT;
  const mass = [];
  for(let k=0;k<=maxG;k++){
    mass[k] = Math.pow(total, k) * Math.exp(-total) / factorial(k);
  }
  // tail beyond maxG
  let tail = 1 - mass.reduce((a,b)=>a+b, 0);
  // OU lines
  const lines = [0.5,1.5,2.5,3.5,4.5,5.5];
  for(const L of lines){
    const floorL = Math.floor(L);
    // P(over L) = 1 - P(total <= floor(L))
    let cdf = 0;
    for(let k=0;k<=floorL;k++) cdf += mass[k] || 0;
    // include tail if floorL >= maxG
    if(floorL >= maxG) cdf -= tail; // approximate correction
    probs[L] = clamp(1 - cdf, 0, 1);
  }
  return probs;
}

/* ------------- HDP & OU integration helper - builds UI friendly summary ------------- */
function buildOddsSummary(res){
  const lambdaH = safeNum(res.lambdaH, (res.h ? res.h.adaptiveXG : 0.8));
  const lambdaA = safeNum(res.lambdaA, (res.a ? res.a.adaptiveXG : 0.8));
  const dist = res.scores || res.dist || null;

  const hdp = calcHDP(lambdaH, lambdaA, dist);
  const ou = calcOverUnderProbs(lambdaH, lambdaA, 10);
  const trapInfo = oddsTrapRefine(res);

  // compute recommended "market-aware" suggestions (neutral, not directive)
  const suggestions = {
    hdp: hdp,
    ou: ou,
    trap: trapInfo
  };

  return suggestions;
}

/* ------------- Odds-trap visual indicator ------------- */
/* will add small colored badge in tournamentBadge element */
function updateOddsIndicator(res){
  const badgeEl = document.getElementById("tournamentBadge");
  if(!badgeEl) return;
  const info = oddsTrapRefine(res);
  // color coding: green (safe model), amber (divergent), red (trap)
  let color = "#0ea5a4"; let text = "Market aligned";
  if(info.severity > 1.35 && info.divergence > 0.12){ color = "#f59e0b"; text = "Market Divergence"; }
  if(info.severity > 1.7 && info.divergence > 0.22){ color = "#ef4444"; text = "High Trap Risk"; }
  badgeEl.innerHTML = `<span class="badge" style="background:${color}">${text} • Trap ${info.trapIndex.toFixed(2)}</span>`;
}

/* ------------- Hook into buildOutput / master result ------------- */
/* Override buildOutput to also compute & display odds summary badges (if buildOutput already exists, it's okay) */
(function hookOddsSummary(){
  const orig = window.buildOutput || null;
  window.buildOutput = function(h,a,lambdaH,lambdaA,prob,ht,pen,clash,trap,conf,agv){
    // call orig if exists (it is the same in Part6, this will override but call same logic)
    if(orig) orig(h,a,lambdaH,lambdaA,prob,ht,pen,clash,trap,conf,agv);
    // now compute odds summary from window._lastRes
    const res = window._lastRes || { lambdaH: lambdaH, lambdaA: lambdaA, scores: window._lastRes && window._lastRes.scores ? window._lastRes.scores : null, prob:prob, trap:trap };
    const summary = buildOddsSummary(res);
    // render small OU & HDP summary under resultText
    const resEl = document.getElementById("resultText");
    if(resEl){
      let extra = "<div style='margin-top:8px'><strong>Odds Summary</strong><br/>";
      // OU
      extra += "OU:";
      for(const L in summary.ou){
        extra += ` ${L}=${(summary.ou[L]*100).toFixed(1)}%`;
      }
      extra += "<br/>HDP sample:";
      const lines = Object.keys(summary.hdp).slice(0,5);
      for(const L of lines){
        const obj = summary.hdp[L];
        extra += ` ${L} W:${(obj.win*100).toFixed(1)}% P:${(obj.push*100).toFixed(1)}% L:${(obj.lose*100).toFixed(1)}%;`;
      }
      extra += "</div>";
      resEl.innerHTML += extra;
    }
    // update visual badge
    updateOddsIndicator(res);
  };
})();
/* ============================================================
   PART 8/12 — HDP Payout Simulator, Trend Predictor,
               MC Variance Analysis, Worker Diagnostics
   ============================================================ */

/* ---------------- HDP PAYOUT SIMULATOR ------------------
   Simulate payout for a given handicap line and stake.
   Inputs:
     - line (e.g., 0, -0.5, +0.5, -1, -1.5)
     - stake (numeric)
     - odds for Home/Away (decimal)
     - scoresDist (probabilities)
   Output: expected return (EV), win% , loss% , push%
----------------------------------------------------------- */
function simulateHDP(line, stake, oddsHome, oddsAway, scoresDist){
  // Build distribution if not provided
  const dist = scoresDist || (window._lastRes && (window._lastRes.scores || window._lastRes.dist)) || null;
  if(!dist) return null;

  let ev = 0, win=0, lose=0, push=0;

  for(const k in dist){
    const p = dist[k];
    const parts = k.split("-");
    const gh = Number(parts[0]), ga = Number(parts[1]);
    const diff = gh - ga;
    // settlement:
    // if line is integer (0,1,2): push if diff == line; win if diff > line; lose if diff < line
    // if line has .5 -> no push
    if(line % 1 === 0){ // integer
      if(diff > line){ win += p; ev += p * (stake * (oddsHome - 1)); }
      else if(diff === line){ push += p; ev += p * 0; }
      else { lose += p; ev -= p * stake; }
    } else { // half line
      if(diff > line){ win += p; ev += p * (stake * (oddsHome - 1)); }
      else { lose += p; ev -= p * stake; }
    }
  }

  return { ev: ev, win: win, lose: lose, push: push };
}

/* ---------------- Advanced Trend Predictor ----------------
   Uses HISTORY to infer:
   - streaks (W/D/L) for each team
   - form index (EWMA of outcome vs expectation)
   - recent goal timing biases (early, late)
----------------------------------------------------------- */
function analyzeTrends(teamName, lookback=12){
  // traverse HISTORY and compute metrics for matches involving teamName
  let rec = [];
  for(const it of HISTORY){
    if(it.hname === teamName || it.aname === teamName){
      rec.push(it);
    }
    if(rec.length >= lookback) break;
  }
  if(rec.length === 0) return null;

  // compute WDL sequence relative to team
  let seq = [];
  let goalsFor = 0, goalsAgainst = 0;
  for(const it of rec){
    const isHome = (it.hname === teamName);
    const gf = isHome ? (it.real_home !== undefined ? it.real_home : null) : (it.real_away !== undefined ? it.real_away : null);
    const ga = isHome ? (it.real_away !== undefined ? it.real_away : null) : (it.real_home !== undefined ? it.real_home : null);
    if(gf===null || ga===null) continue; // skip if no real score
    goalsFor += gf; goalsAgainst += ga;
    if(gf > ga) seq.push("W");
    else if(gf === ga) seq.push("D");
    else seq.push("L");
  }

  // streak detection
  let streak = 0, curr = seq[0] || null;
  for(const c of seq){
    if(c === curr) streak++; else break;
  }

  // form index: EWMA of result points (W=3,D=1,L=0) normalized vs expectation (if prob exists)
  let alpha = 0.12;
  let ewma = 0;
  for(const it of rec.reverse()){
    const prob = it.prob || { home:0.33, draw:0.34, away:0.33 };
    let expectedPts = 0;
    const isHome = (it.hname === teamName);
    if(isHome) expectedPts = prob.home*3 + prob.draw*1;
    else expectedPts = prob.away*3 + prob.draw*1;

    let actualPts = 0;
    if(it.real_home !== undefined && it.real_away !== undefined){
      const isHome = (it.hname === teamName);
      const gf = isHome ? it.real_home : it.real_away;
      const ga = isHome ? it.real_away : it.real_home;
      if(gf > ga) actualPts = 3;
      else if(gf === ga) actualPts = 1;
      else actualPts = 0;
    } else {
      actualPts = expectedPts; // fallback
    }
    // normalized diff
    const diff = (actualPts - expectedPts);
    ewma = ewma*(1-alpha) + alpha*diff;
  }

  // goal timing bias (if detailed timestamps exist in history future feature)
  // placeholder -> return zeros
  const earlyBias = 0;
  const lateBias = 0;

  return { seq: seq, streak: streak, goalsFor: goalsFor, goalsAgainst: goalsAgainst, formEWMA: ewma, earlyBias, lateBias };
}

/* ---------------- Monte Carlo Variance Analysis --------------- 
   Given MC scores object from worker, compute:
    - expected total goals
    - variance of total goals
    - CI for probabilities
-------------------------------------------------------------- */
function mcVarianceAnalysis(mcScores){
  if(!mcScores) return null;
  let meanTotal = 0;
  let meanDiff = 0;
  let varTotal = 0;
  let varDiff = 0;
  // compute mean and variance
  for(const k in mcScores){
    const p = mcScores[k];
    const parts = k.split("-");
    const gh = Number(parts[0]), ga = Number(parts[1]);
    const tot = gh + ga;
    const diff = gh - ga;
    meanTotal += tot * p;
    meanDiff += diff * p;
  }
  // variance
  for(const k in mcScores){
    const p = mcScores[k];
    const parts = k.split("-");
    const gh = Number(parts[0]), ga = Number(parts[1]);
    const tot = gh + ga;
    const diff = gh - ga;
    varTotal += ((tot - meanTotal)*(tot - meanTotal)) * p;
    varDiff += ((diff - meanDiff)*(diff - meanDiff)) * p;
  }

  return { meanTotal, varTotal, meanDiff, varDiff, sdTotal: Math.sqrt(varTotal), sdDiff: Math.sqrt(varDiff) };
}

/* ---------------- Worker Diagnostics & Health ---------------- */
function diagWorkerHealth(){
  const out = { workerURLExists: !!_mcv3_url, lastResExists: !!window._lastRes, lastRunTime: window._lastRes ? window._lastRes.time : null, mcv3BlobSize: null };
  try{
    // get blob size estimate if possible
    if(_mcv3_url){
      // cannot introspect blob size reliably; we show presence only
      out.mcv3BlobSize = "n/a";
    }
  }catch(e){
    out.mcv3BlobSize = "err";
  }
  console.log("Worker Diagnostics:", out);
  return out;
}

/* ---------------- Debug helpers ---------------- */
function printLastRes(){
  console.log("=== LAST RES ===");
  console.log(window._lastRes);
  return window._lastRes;
}

/* ---------------- bind a quick diagnostics button to console ---------------- */
(function bindDiag(){
  const btn = document.getElementById("manualCalcBtn");
  if(btn){
    btn.removeEventListener("click", printLastRes);
    btn.addEventListener("click", ()=>{
      const r = printLastRes();
      showToast("Check console for last result & worker health");
      console.log("Worker health:", diagWorkerHealth());
    });
  }
})();
/* ============================================================
   PART 9/12 — UI POLISH, EXPORT (CSV full), EXPORT PROJECT HTML,
               Simple Form Line Chart, Tooltips, Accessibility
   ============================================================ */

/* ---------------- small util: pct formatting ---------------- */
function pct(x){ return (safeNum(x,0)*100).toFixed(1) + "%"; }

/* ---------------- Tooltip helper (simple) ---------------- */
function attachTooltip(el, text){
  if(!el) return;
  el.setAttribute("title", text);
  el.setAttribute("aria-label", text);
}

/* ---------------- Add tooltips to important controls on load ---------------- */
window.addEventListener("load", ()=>{
  attachTooltip(document.getElementById("league_gpg"), "Rata-rata total gol liga (optional) — gunakan untuk normalisasi");
  attachTooltip(document.getElementById("market_ou"), "Pasang market over/under sebagai target zero-bias (opsional)");
  attachTooltip(document.getElementById("mc_select"), "Jumlah iterasi Monte Carlo (lebih besar = stabilitas lebih baik, tapi lebih lama)");
  attachTooltip(document.getElementById("analyzeBtn"), "Klik untuk menjalankan analisis lengkap v21.0");
  attachTooltip(document.getElementById("inputRealBtn"), "Masukkan hasil pertandingan nyata untuk melatih model jika learning aktif");
});

/* ---------------- EXPORT FULL HISTORY CSV (all) ---------------- */
function exportFullHistoryCSV(){
  if(HISTORY.length === 0){ showToast("History kosong"); return; }
  const header = ["time","home","away","lambdaH","lambdaA","pHome","pDraw","pAway","conf","trap","real_home","real_away"];
  const rows = [header];
  for(const it of HISTORY){
    rows.push([
      `"${it.time}"`,
      `"${it.hname}"`,
      `"${it.aname}"`,
      safeNum(it.lambdaH,0),
      safeNum(it.lambdaA,0),
      safeNum(it.prob ? it.prob.home : (it.pHome||0),0),
      safeNum(it.prob ? it.prob.draw : (it.pDraw||0),0),
      safeNum(it.prob ? it.prob.away : (it.pAway||0),0),
      safeNum(it.conf,0),
      safeNum(it.trap,1),
      it.real_home !== undefined ? it.real_home : "",
      it.real_away !== undefined ? it.real_away : ""
    ]);
  }
  const csv = rows.map(r => r.join(",")).join("\n");
  const blob = new Blob([csv], {type: "text/csv"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a"); a.href = url; a.download = "prediksi_v21_history_full.csv"; a.click();
  URL.revokeObjectURL(url);
  showToast("History CSV sudah dibuat");
}

/* bind to viewHistory button to open export modal / or trigger export */
document.getElementById("viewHistory").addEventListener("click", ()=>{
  // small modal-like prompt (simple)
  if(HISTORY.length === 0){ showToast("History kosong"); return; }
  const txt = HISTORY.slice(0,30).map(it=>`[${it.time}] ${it.hname} vs ${it.aname} → H:${(it.prob.home*100).toFixed(1)}% D:${(it.prob.draw*100).toFixed(1)}% A:${(it.prob.away*100).toFixed(1)}% (C:${(it.conf*100||0).toFixed(0)}%)`).join("\n");
  // show in prompt for quick view + option to export full CSV
  if(confirm("Lihat 30 hasil terakhir di console?\n- OK: print ke console\n- Cancel: export full CSV")){
    console.log("History (latest 30):\n" + txt);
    showToast("History diprint di console");
  } else {
    exportFullHistoryCSV();
  }
});

/* ---------------- Export project as HTML (snapshot of current page) ----------------
   Creates a downloadable HTML file containing current DOM (inline script/styles remain)
   Useful for backup / sharing.
------------------------------------------------------------------ */
document.getElementById("exportModel").insertAdjacentHTML("afterend", "<button id='exportProjectHTML' class='smallBtn'>Export Project (HTML)</button>");
document.getElementById("exportProjectHTML").addEventListener("click", ()=>{
  try{
    // Clone current document and inline current state into HTML string
    const docClone = document.documentElement.cloneNode(true);
    // remove file-upload inputs / blobs if any for safety
    const htmlStr = "<!doctype html>\n" + docClone.outerHTML;
    const blob = new Blob([htmlStr], {type: "text/html"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a"); a.href = url; a.download = "prediksi_v21_snapshot.html"; a.click();
    URL.revokeObjectURL(url);
    showToast("Project HTML dibuat (snapshot)");
  }catch(e){
    console.warn("export project error", e);
    showToast("Export gagal - lihat console");
  }
});

/* ---------------- Simple Form Line Chart (canvas) ---------------- */
/* small, dependency-free chart: x-axis = recent MATCHES, y-axis = performance index (EWMA points) */
(function addFormChartArea(){
  const parent = document.getElementById("historyList");
  if(!parent) return;
  parent.insertAdjacentHTML("afterend", "<div class='card'><div class='section-title'>Form Chart (Recent)</div><canvas id='formChart' width='520' height='180'></canvas></div>");
})();

function drawFormChart(teamName, lookback=12){
  const canvas = document.getElementById("formChart");
  if(!canvas) return;
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // gather sequence of EWMA points for team
  const rec = analyzeTrends(teamName, lookback);
  if(!rec || rec.seq.length===0){
    // show placeholder
    ctx.fillStyle = "#0b2b30";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = "#bfeef8";
    ctx.fillText("No recent real results to plot form chart.", 12, 24);
    return;
  }

  // build numeric series: W=3 D=1 L=0
  let series = [];
  for(const it of HISTORY){
    if(it.hname === teamName || it.aname === teamName){
      if(it.real_home === undefined || it.real_away === undefined) continue;
      const isHome = (it.hname === teamName);
      const gf = isHome ? it.real_home : it.real_away;
      const ga = isHome ? it.real_away : it.real_home;
      let pts = gf>ga ? 3 : (gf===ga ? 1 : 0);
      series.push(pts);
      if(series.length >= lookback) break;
    }
  }
  if(series.length===0){
    ctx.fillStyle = "#bfeef8"; ctx.fillText("No recent real results to plot.",12,24); return;
  }
  series = series.reverse();

  // compute simple moving average (window=3)
  const sma = [];
  for(let i=0;i<series.length;i++){
    const win = series.slice(Math.max(0,i-2), i+1);
    const avg = win.reduce((a,b)=>a+b,0)/win.length;
    sma.push(avg);
  }

  // draw axes
  const margin = 28;
  const w = canvas.width - margin*2;
  const h = canvas.height - margin*2;
  ctx.strokeStyle = "rgba(190,238,248,0.15)"; ctx.lineWidth = 1;
  ctx.strokeRect(margin, margin, w, h);

  // y scale 0..3
  ctx.beginPath(); ctx.moveTo(margin, margin + h); ctx.lineTo(margin + w, margin + h); ctx.stroke();

  // plot line
  ctx.beginPath();
  for(let i=0;i<sma.length;i++){
    const x = margin + (i/(sma.length-1 || 1))*w;
    const y = margin + h - (sma[i]/3)*h;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.strokeStyle = "#18b2c9"; ctx.lineWidth = 2;
  ctx.stroke();

  // draw dots
  ctx.fillStyle = "#bfeef8";
  for(let i=0;i<sma.length;i++){
    const x = margin + (i/(sma.length-1 || 1))*w;
    const y = margin + h - (sma[i]/3)*h;
    ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill();
  }

  // label
  ctx.fillStyle = "#bfeef8"; ctx.font = "12px sans-serif";
  ctx.fillText("Team: "+teamName+" (recent form)", margin, 14);
}

/* ---------------- Auto-draw form chart when importing or pushing history ------------- */
(function hookFormChart(){
  const origPush = pushHistory;
  window.pushHistory = function(entry){
    origPush(entry);
    // draw for home if present
    if(entry && entry.hname) drawFormChart(entry.hname, 12);
  };
})();
/* ============================================================
   PART 10/12 — WORKER OPTIMIZATIONS, PERFORMANCE GUARDS,
                 FALLBACKS, EARLY-STOP, PROGRESS UI,
                 DEBOUNCE, ACCESSIBILITY SHORTCUTS
   ============================================================ */

/* ----------------- Progress indicator util ----------------- */
function setProgress(msg, busy=true){
  const badge = document.getElementById("tournamentBadge");
  if(!badge) return;
  if(busy){
    badge.innerHTML = `<span class="badge" style="background:#0b94a3">${msg}</span>`;
  } else {
    // leave existing badge if trap was displayed later
    // fallback small message
    badge.innerHTML = `<span class="badge" style="background:#08313a">${msg}</span>`;
    setTimeout(()=>{ if(window._lastRes) updateOddsIndicator(window._lastRes); }, 900);
  }
}

/* ----------------- Debounce helper for heavy actions ----------------- */
function debounce(fn, wait){
  let t;
  return function(...args){
    clearTimeout(t);
    t = setTimeout(()=>fn.apply(this,args), wait);
  };
}

/* ----------------- Worker early-stop guard (wrap runMCv3) ------------ */
async function runMCv3WithTimeout(lh, la, n, timeoutMs=8000){
  // run worker but stop if not responding within timeoutMs
  setProgress("MC running...", true);
  const start = Date.now();
  let timedOut = false;
  return new Promise((resolve) => {
    let finished = false;
    const timer = setTimeout(()=>{
      timedOut = true;
      finished = true;
      console.warn("MCv3 timed out after", timeoutMs);
      setProgress("MC timeout — using Poisson", false);
      resolve(null);
    }, timeoutMs);

    runMCv3(lh, la, n).then((res)=>{
      if(finished) return;
      clearTimeout(timer);
      finished = true;
      setProgress("MC done", false);
      resolve(res);
    }).catch((e)=>{
      if(finished) return;
      clearTimeout(timer);
      finished = true;
      setProgress("MC error", false);
      resolve(null);
    });
  }).finally(()=>{
    const dur = Date.now() - start;
    // if ran long, small log
    if(dur > timeoutMs*0.9) console.warn("MCv3 near timeout:", dur);
  });
}

/* ----------------- Graceful worker fallback ----------------- */
async function safeRunMC(lh, la, n){
  // try runMCv3WithTimeout first, then fall back to runMCWorker (v2) or Poisson quick
  try{
    const mc = await runMCv3WithTimeout(lh, la, n, Math.max(5000, Math.min(20000, n*0.7)));
    if(mc) return mc;
    // fallback to runMCv2 if exists
    if(typeof runMCv2 === "function"){
      setProgress("Fallback MCv2...", true);
      const mc2 = await runMCv2(lh, la, Math.max(2000, Math.floor(n/3)));
      setProgress("MCv2 done", false);
      if(mc2) return mc2;
    }
  }catch(e){
    console.warn("safeRunMC error", e);
  }
  // absolute fallback: quick Poisson grid
  setProgress("Using Poisson fallback", false);
  const maxG = 8;
  const dist = {};
  let pHome = 0, pDraw = 0, pAway = 0;
  for(let i=0;i<=maxG;i++){
    for(let j=0;j<=maxG;j++){
      const ph = Math.pow(lh,i)*Math.exp(-lh)/factorial(i);
      const pa = Math.pow(la,j)*Math.exp(-la)/factorial(j);
      const p = ph*pa;
      dist[i+"-"+j] = p;
      if(i>j) pHome+=p; else if(i===j) pDraw+=p; else pAway+=p;
    }
  }
  return { prob:{home:pHome,draw:pDraw,away:pAway}, scores: dist };
}

/* ----------------- Performance guard: heavy input check ----------------- */
function performanceGuard(){
  // if many inputs empty or too large MC selected, warn user
  const mcIter = parseInt(document.getElementById("mc_select") ? document.getElementById("mc_select").value : 10000);
  if(mcIter > 30000 && navigator.hardwareConcurrency && navigator.hardwareConcurrency < 4){
    if(!confirm("MC iterations set high ("+mcIter+"). Device CPU cores low ("+(navigator.hardwareConcurrency||"n/a")+") — continue?")) return false;
  }
  return true;
}

/* ----------------- Safe analyze wrapper (debounced) ----------------- */
const safeAnalyze = debounce(async function(){
  try{
    if(!performanceGuard()) return;
    setProgress("Preparing analysis...", true);
    // call master lambda but replace MC call with safeRunMC
    const res = await masterLambdaBuild(); // this will run MC originally, but we stored window._lastRes; we'll re-run safe MC to refine
    if(!res) { setProgress("No result", false); return; }
    // re-run MC safely
    const mcIter = parseInt(document.getElementById("mc_select") ? document.getElementById("mc_select").value : 10000);
    const mc = await safeRunMC(res.lambdaH, res.lambdaA, mcIter);
    if(mc){
      res.prob = mc.prob;
      res.scores = mc.scores;
    }
    // recompute confidence tuned
    res.conf = confidenceTuned(res.lambdaH, res.lambdaA, res.agv || 1.0, res.trap || 1.0, res.scores);
    window._lastRes = res;
    // call buildOutput with recalculated values
    try{
      buildOutput(res.h, res.a, res.lambdaH, res.lambdaA, res.prob, calcHTv21(res.lambdaH,res.lambdaA,res.h,res.a, document.getElementById("match_type").value, document.getElementById("tournament_mode").value), null, res.clash||0, res.trap||1, res.conf, res.agv||1);
    }catch(e){
      console.warn("safeAnalyze -> buildOutput failed", e);
    }
    setProgress("Analisis selesai", false);
  }catch(e){
    console.error("safeAnalyze error", e);
    setProgress("Analisis error", false);
  }
}, 320);

/* replace analyze button binding to safeAnalyze (debounced) */
(function bindSafeAnalyze(){
  const btn = document.getElementById("analyzeBtn");
  if(btn){
    btn.removeEventListener("click", masterLambdaBuild);
    btn.removeEventListener("click", adaptMainAnalyze);
    btn.removeEventListener("click", mainAnalyze);
    btn.addEventListener("click", ()=>{ safeAnalyze(); });
  }
})();

/* ----------------- Accessibility: Keyboard shortcuts ----------------- */
/* - Enter on any input runs analyze (unless focused on textarea) */
/* - Ctrl+S exports model (prevent default browser save) */
/* - Ctrl+E exports history CSV */
window.addEventListener("keydown", function(e){
  if(e.key === "Enter" && (document.activeElement && document.activeElement.tagName !== "TEXTAREA")){
    e.preventDefault(); safeAnalyze();
  }
  if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's'){
    e.preventDefault();
    document.getElementById("exportModel").click();
    showToast("Export model (Ctrl+S)");
  }
  if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'e'){
    e.preventDefault();
    exportFullHistoryCSV();
    showToast("Export history (Ctrl+E)");
  }
});

/* ----------------- Resource sanity check on load ----------------- */
window.addEventListener("load", ()=>{
  try{
    const cores = navigator.hardwareConcurrency || "n/a";
    const mem = navigator.deviceMemory || "n/a";
    console.info("Device resources — cores:", cores, "deviceMemory:", mem);
    if(cores !== "n/a" && cores < 2){
      showToast("Device CPU cores rendah — disarankan MC kecil", 3200);
    }
  }catch(e){}
});

/* ----------------- Final small guard: prevent NaN outputs ----------------- */
(function guardNaNOutputs(){
  const origBuild = window.buildOutput;
  window.buildOutput = function(...args){
    // sanitize numeric args in-place
    for(let i=0;i<args.length;i++){
      if(typeof args[i] === "number" && (!isFinite(args[i]) || isNaN(args[i]))){
        args[i] = 0;
      }
    }
    try{ if(origBuild) origBuild.apply(this,args); }catch(e){ console.warn("guardNaNOutputs -> origBuild failed", e); }
  };
})();

/* ----------------- Minor UI polish: focus first input ----------------- */
window.addEventListener("load", ()=>{
  const el = document.getElementById("h_name");
  if(el){ el.focus(); el.select && el.select(); }
});
/* ============================================================
   PART 11/12 — PROJECT BUNDLE EXPORT, MODEL VIEWER,
                 QA / SANITY CHECKS, API HOOK PLACEHOLDERS
   ============================================================ */

/* ----------------- Utility: collect current project files -----------------
   We'll collect:
   - current HTML outerHTML snapshot
   - current model state (window._v21)
   - history (HISTORY)
   - lastRes (window._lastRes)
   Returns an object { "filename": "content" }
-------------------------------------------------------------------------- */
function collectProjectFiles(){
  // snapshot HTML
  let htmlSnap = "<!doctype html>\n" + document.documentElement.outerHTML;

  // model state
  const model = window._v21 ? JSON.stringify(window._v21, null, 2) : "{}";

  // history
  const hist = JSON.stringify(HISTORY || [], null, 2);

  // last res
  const last = JSON.stringify(window._lastRes || {}, null, 2);

  return {
    "snapshot_prediksi_v21.html": htmlSnap,
    "model_v21_state.json": model,
    "history_v21.json": hist,
    "lastres_v21.json": last,
    "readme.txt": "Prediksi v21 FINAL PRO — exported bundle. Files: snapshot_prediksi_v21.html, model_v21_state.json, history_v21.json, lastres_v21.json"
  };
}

/* ----------------- Export bundle (ZIP if JSZip available, fallback to JSON bundle) -------------- */
async function exportProjectBundle(){
  const files = collectProjectFiles();

  // if JSZip is available on page (rare), use it
  if(window.JSZip){
    try{
      const zip = new JSZip();
      for(const name in files) zip.file(name, files[name]);
      const content = await zip.generateAsync({type:"blob"});
      const url = URL.createObjectURL(content);
      const a = document.createElement("a"); a.href = url; a.download = "prediksi_v21_bundle.zip"; a.click();
      URL.revokeObjectURL(url);
      showToast("Bundle ZIP dibuat (via JSZip)");
      return;
    }catch(e){
      console.warn("JSZip export failed", e);
    }
  }

  // fallback: create single JSON manifest file containing all parts
  const manifest = { created: new Date().toISOString(), files: {} };
  for(const name in files) manifest.files[name] = files[name];
  const blob = new Blob([JSON.stringify(manifest, null, 2)], {type: "application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a"); a.href = url; a.download = "prediksi_v21_bundle.json"; a.click();
  URL.revokeObjectURL(url);
  showToast("Bundle JSON dibuat (fallback). Untuk ZIP otomatis, tambahkan JSZip ke halaman.");
}

/* --- bind export button (adds new button near exportProjectHTML if present) --- */
(function addBundleBtn(){
  const ref = document.getElementById("exportProjectHTML");
  if(ref && !document.getElementById("exportBundleBtn")){
    ref.insertAdjacentHTML("afterend", "<button id='exportBundleBtn' class='smallBtn'>Export Bundle (ZIP/JSON)</button>");
    document.getElementById("exportBundleBtn").addEventListener("click", exportProjectBundle);
  }
})();

/* ----------------- MODEL STATE VIEWER (human readable) ---------------- */
function openModelViewer(){
  const obj = window._v21 || {};
  const w = window.open("", "_blank", "toolbar=0,location=0,menubar=0,width=900,height=700");
  if(!w) { showToast("Popup diblokir — izinkan popup untuk melihat model"); return; }
  const html = `
    <html><head><title>Model Viewer — v21</title><style>body{font-family:system-ui,Arial;background:#061a20;color:#dff6fb;padding:12px;} pre{background:#02121a;padding:12px;border-radius:8px;overflow:auto;max-height:90vh}</style></head>
    <body><h2>Model State (window._v21)</h2><pre>${JSON.stringify(obj,null,2)}</pre></body></html>
  `;
  w.document.write(html);
  w.document.close();
}

/* add quick button near model export if available */
(function addModelViewerBtn(){
  const ref = document.getElementById("exportModel");
  if(ref && !document.getElementById("viewModelBtn")){
    ref.insertAdjacentHTML("afterend", "<button id='viewModelBtn' class='smallBtn'>View Model</button>");
    document.getElementById("viewModelBtn").addEventListener("click", openModelViewer);
  }
})();

/* ----------------- QA / SANITY CHECKS (lightweight) ----------------
   Runs a set of automated checks and returns an array of issues (empty = clean).
   Checks include:
    - required DOM elements present
    - no obvious NaN in _lastRes
    - worker availability
    - basic numeric ranges on recent HISTORY
------------------------------------------------------------------ */
function runSanityChecks(){
  const issues = [];
  // DOM checks
  const requiredIds = ["h_name","a_name","analyzeBtn","resultText","radarCanvas"];
  requiredIds.forEach(id => {
    if(!document.getElementById(id)) issues.push("Missing DOM element: "+id);
  });

  // lastRes numeric check
  if(window._lastRes){
    const lr = window._lastRes;
    if(!isFinite(safeNum(lr.lambdaH)) || !isFinite(safeNum(lr.lambdaA))) issues.push("lastRes lambda not finite");
    if(lr.prob){
      if(lr.prob.home < 0 || lr.prob.home > 1) issues.push("lastRes prob.home out of range");
    }
  } else {
    issues.push("No lastRes available (run an analysis first)");
  }

  // worker check
  if(!_mcv3_url) issues.push("MCv3 worker blob not built yet (will auto-build on first run)");

  // history checks
  for(const it of HISTORY.slice(0,20)){
    if(it.prob && (it.prob.home < 0 || it.prob.home > 1)) issues.push("History contains prob out of range for match: "+it.hname+" v "+it.aname);
  }

  // resource checks
  const cores = navigator.hardwareConcurrency || 0;
  if(cores && cores < 2) issues.push("Low device cores: "+cores);

  return issues;
}

/* ----------------- UI: run QA button ----------------- */
(function addQABtn(){
  if(!document.getElementById("qaCheckBtn")){
    const el = document.createElement("button");
    el.id = "qaCheckBtn"; el.className = "smallBtn"; el.textContent = "Run QA Check";
    const ref = document.getElementById("resetBtn");
    if(ref) ref.insertAdjacentElement("afterend", el);
    el.addEventListener("click", ()=>{
      const issues = runSanityChecks();
      if(issues.length===0){
        alert("Sanity checks passed — no issues found.");
      } else {
        alert("Sanity checks found issues:\n- " + issues.join("\n- "));
        console.warn("Sanity issues:", issues);
      }
    });
  }
})();

/* ----------------- API Hook placeholders (no external calls by default) --------------
   If you want to integrate with external server later, implement these hooks.
   They are intentionally no-op and safe.
------------------------------------------------------------------------------ */
const API_HOOKS = {
  onPrediction: async function(payload){ /* payload = window._lastRes */ return {ok:true}; },
  fetchLeagueProfile: async function(leagueKey){ /* return {gpg:2.7, profile:'medium'} */ return null; },
  uploadHistory: async function(historyChunk){ return {ok:true}; }
};

/* small UI to trigger API hooks (for advanced users) */
(function addAPIButtons(){
  if(!document.getElementById("apiTestBtn")){
    const btn = document.createElement("button");
    btn.id = "apiTestBtn"; btn.className = "smallBtn"; btn.textContent = "API Test Hook";
    const ref = document.getElementById("viewModelBtn") || document.getElementById("exportBundleBtn") || document.getElementById("exportProjectHTML");
    if(ref) ref.insertAdjacentElement("afterend", btn);
    btn.addEventListener("click", async ()=>{
      try{
        const res = await API_HOOKS.onPrediction(window._lastRes || {});
        showToast("API Hook called (see console)");
        console.log("API_HOOKS.onPrediction result:", res);
      }catch(e){
        showToast("API Hook failed (see console)");
        console.error(e);
      }
    });
  }
})();

/* ----------------- Final note for Part 11 ----------------- */
console.info("v21 PRO — Part 11 loaded (bundle export, QA, model viewer, API hooks).");
/* ============================================================
   PART 12/12 — FINAL WRAP-UP, AUTO-QA, FAIL-SAFE,
                 DOM READY NOTICE, HTML CLOSER
   ============================================================ */

/* ---------------- Auto QA (ringan) setelah load ---------------- */
window.addEventListener("load", ()=>{
  try{
    const issues = runSanityChecks();
    if(issues.length === 0){
      console.info("Auto-QA: clean ✓");
    } else {
      console.warn("Auto-QA issues:", issues);
      showToast("Auto-QA mendeteksi hal kecil — lihat console", 3000);
    }
  }catch(e){
    console.warn("Auto-QA failed:", e);
  }
});

/* ---------------- Fail-safe jika main analysis error ---------------- */
window.safeAnalyzeFallback = function(){
  try{
    if(!window._lastRes){
      const msg = "Tidak ada hasil analisis. Pastikan input terisi lalu klik ANALYZE.";
      alert(msg); console.warn(msg);
      return;
    }
    console.warn("safeAnalyzeFallback invoked — using last known good result.");
    buildOutput(
      _lastRes.h, _lastRes.a,
      _lastRes.lambdaH, _lastRes.lambdaA,
      _lastRes.prob, _lastRes.ht, _lastRes.pen,
      _lastRes.clash, _lastRes.trap, _lastRes.conf, _lastRes.agv
    );
    updateOddsIndicator(_lastRes);
  }catch(e){
    console.error("Fallback failed:", e);
    alert("Gagal melakukan fallback — silakan isi ulang data dan klik ANALYZE.");
  }
};

/* ---------------- DOM ready notice (quiet) ---------------- */
window.addEventListener("load", ()=>{
  console.info("%cv21 Engine fully loaded.","color:#14c2d4; font-weight:bold;");
});

/* ---------------- Last small guard: prevent double workers ---------------- */
window.addEventListener("beforeunload", ()=>{
  try{
    if(_mcv3_url){
      URL.revokeObjectURL(_mcv3_url);
    }
  }catch(e){}
});

/* ============================================================
   END OF SCRIPT
   ============================================================ */
</script>

</body>
</html>
